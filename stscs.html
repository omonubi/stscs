<div>
    <input type='hidden' class='movement-grid-status' name='attr_movement_grid_status' value='0'/>
    <input type='hidden' class='sensors-status' name='attr_sensors_status' value='0'/>
    <input type='hidden' class='shields-grid-status' name='attr_shields_grid_status' value='0'/>
    <input type='hidden' class='ship-is-disabled' name='attr_ship-is-disabled' value='0'/>
    <input type='hidden' class='tpa-committed-status' name='attr_tpa_committed_status' value='0'/>
    <input type='hidden' class='weapons-grid-status' name='attr_weapons_grid_status' value='0'/>
    <h1>
        <span name='attr_character_name'></span>
        <span class='disable-ship' title='disabled'> &#x1F198;</span>
        <span class='warning-sensors' style='cursor: default;' title='sensors offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-movement' style='cursor: default;' title='helm offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-shields' style='cursor: default;' title='shields offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-weapons' style='cursor: default;' title='weapons offline'> &#x26A0;&#xFE0F;</span>
    </h1> 
    <input type='hidden' name='attr_current_phase' value='0'/>
    <input type='hidden' name='attr_tpa_reset' value='0'/>
    <input type='hidden' name='attr_roll20charurl'/>
    <!--------------------------------------------------------> 
    <div class='grid-6col overview-panel'>
        <span class='span2'>
            <span name='attr_class'></span>
            <span name='attr_type'></span>
        </span>
        <span class='span2'>
            <label>Size:</label>
            <span name='attr_size'></span>
        </span>
        <span class='span2'>
            <label>D / WDF / CE:</label>
            <input type='number' class='w6' name='attr_defense' min='0' step='.1' value='0'/> /
            <input type='number' class='w6' name='attr_wdf' min='0' step='.1' value='0'/> /
            <span name='attr_ce'>0</span>
        </span>

        <label>Captain:</label>
        <input type='text' class='w12' name='attr_capname' placeholder='name...'/>
        <label>Command Rating:</label>
        <input type='hidden' name='attr_caprating_ta'/>
        <input type='number' name='attr_caprating' min='0'/>   
        <label>Crew Rating:</label>
        <input type='number' name='attr_crewrating' min='0'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Damage Control</h2>

    <div class='grid-6col dc-panel'>
        <button type='action' class='btn critical roll-damage' name='act_rolldamage'>Roll Damage</button>
        <span></span>
        <label><strong>Superstructure:</strong></label>
        <span>
            <input type='hidden' class='hp-status' name='attr_hp_status' value='0'/>
            <input type='number' class='hp' name='attr_hp' value='0' readonly/>
            /
            <span name='attr_hp_max'></span>
        </span>
        <label>Damage Charts:</label>
        <span name='attr_dmg_chart'></span>

        <button type='roll' class='btn' name='roll_rollcrew' value='&{template:custom} {{title=**[@{character_name}](@{roll20charurl}@{character_id})**}} {{subtitle=Crew Efficiency Roll}} {{color=gold}} {{Efficiency=[[@{crewefficiency}]]}} {{Roll=[[d100cf<0cs>101]]}}'>Crew Check</button>
        <span></span>
        <label><strong>Crew:</strong></label>
        <input type='hidden' name='attr_crew-percent' value='100'/>
        <span >
            <input type='hidden' class='crew-status' name='attr_crew_status' value='0'/>
            <input type='number' class='w5 crew' name='attr_crew' value='0' min='0' readonly/> /
            <span name='attr_crew_max'></span>
        </span>
        <label>Efficiency:</label>
        <span>
            <input type='number' name='attr_crewefficiency' readonly/> / 
            <input type='number' name='attr_crewrollpenalty' readonly/>
        </span>

        <input type='hidden' name='attr_crewbonus_saved'/>
        <input type='hidden' name='attr_crewbonus_engineid'/>
        <select class='crew-bonus' name='attr_crewbonus'>
            <option value='0' selected>None</option>
            <option value='1'>Bonus To-Hit</option>
            <option value='2'>Bonus TPA</option>
            <option value='3'>Bonus SPA</option>
            <option value='4'>+1 Superstructure</option>
            <option value='5'>+1 Impulse</option>
            <option value='6'>+1 Warp Engine</option>
        </select>
        <span></span>
        <span>
            <label>TPA: </label>
            <span><span name='attr_tpa-percent'>100</span>%</span>
        </span>
        <span>
            <label>Sup: </label>
            <span><span name='attr_sup-percent'>100</span>%</span>
        </span>
        <span>
            <label>Shields: </label>
            <span><span name='attr_shields-percent'>100</span>%</span>
        </span>
        <span>
            <label>Wpns: </label>
            <span><span name='attr_weapons-percent'>100</span>%</span>
        </span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Engineering
        <input type='hidden' class='crewbonus2' name='attr_crewbonus2' value='0'/>
        <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
    </h2>

    <div class='grid-6col tpa-panel'>
        <button type='action' class='btn' name='act_tpa_reset'>Reset TPA</button>
        <span></span>
        <label><strong>Current TPA:</strong></label> 
        <span><strong><span name='attr_tpa'></span> / <span name='attr_tpa_max'></span></strong></span>
        <label>TPA Unallocated:</label>
        <input type='hidden' class='tpa-remaining-status' name='attr_tpa_remaining_status'/>
        <input type='number' class='tpa-remaining' name='attr_tpa_remaining'  value='0' readonly/>

        <button type='action' class='btn warning' name='act_shield_commit'>Commit TPA</button>
        <span></span>
        <label>TPA to Movement:</label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA to Warp:</label>
        <input type='number' name='attr_tpa_warp' min='0' value='0' readonly/>

        <button type='action' class='btn energize' name='act_shield_reenergize'>Re-energize</button>
        <span></span>
        <label>TPA to Shields:</label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA to Weapons:</label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
    </div>
    <br/>
    
    <div class='grid-6col engines-panel'>    
        <h4 class='span-grid'>Engines</h4>
        <div class='span-grid'>
            <label style='padding-left: 32px;'>Model</label>
            <label style='padding-left: 42px;'>Type</label>
            <label style='padding-left: 70px;'>Location</label>
            <label style='padding-left: 46px;'>Power</label>
            <label style='padding-left: 22px;'>Max</label>
        </div>
        <fieldset class='repeating_engines'>
            <input type='text' class='w10' name='attr_engine_model' placeholder='model...'/>
            <select class='w10' name='attr_engine_type'>
                <option value='0' selected>select...</option>
                <option value='1'>Impulse</option>
                <option value='2'>Warp</option>
                <option value='3'>Generator</option>
            </select>
            <select class='w10' name='attr_engine_location'>
                <option value='0' selected>select...</option>
                <option value='1'>Centerline</option>
                <option value='2'>Port</option>
                <option value='3'>Starboard</option>
            </select>
            <input type='hidden' class='engine-power-status' name='attr_engine_power_status' value='0'/>
            <input type='number' class='engine-power' name='attr_engine_power' min='0' value='0'/> / <input type='number' name='attr_engine_power_full' min='0' value='0'/>
        </fieldset>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='sensors-header header-container'>
        <h2>Sensors</h2>
        <span>
            <input type='hidden' name='attr_sensors_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_sensors_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-sensors-repair repair' name='act_sensors_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' class='sensors-destroyed' name='attr_sensors_destroyed' value='0'/>
    <div class='grid-6col sensors-panel'>
        <button type='action' class='btn btn-scan' name='act_scan'>Scan Target</button>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        
        <span class='span2'>
            <input type='text' class='scan-lock' name='attr_sensorlock' placeholder='No target lock...' readonly/>
        </span>
        <input type='hidden' class='w12' name='attr_sensorlockid'/>
        <span class='span2'>
            <select class='scan-question' name='attr_scanquestion'>
                <option value='0'>Submit a query...</option>
                <option value='1'>How much power is available?</option>
                <option value='2'>What is the relative power allocation?</option>
                <option value='3'>How are the shields powered?</option>
                <!--<option value='4'>Is a specific shield up?</option>-->
                <option value='5'>How are the beam weapons powered?</option>
                <option value='6'>How are the missile weapons powered?</option>
                <!--<option value='7'>Is a specific weapon powered?</option>-->
                <option value='8'>How much damage has the vessel taken?</option>
                <!--<option value='9'>What is the status of the ship's crew?</option>-->
                <!--<option value='10'>Are any transporters powered?</option>-->
            </select>
        </span>
        <span class='span2'><input type='text' class='scan-answer' name='attr_scananswer' placeholder='Paste the result here...'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='helm-header header-container'>
        <h2>Helm Control</h2>
        <span>
            <input type='hidden' name='attr_movement_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_movement_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-movement-grid-repair repair' name='act_movement_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col helm-panel'>
        <button type='action' class='btn warning btn-stress-turn' name='act_stress_turn'>Stress Turn</button>
        <span></span>
        <label><strong>TPA to Movement:</strong></label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA Remaining:</label> 
        <input type='hidden' class='mp-remaining-status' name='attr_mp_remaining_status'/>
        <input type='number' class='mp-remaining' name='attr_mp_remaining' value='0' readonly/>

        <label>Movement Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_mpr_1' min='1' max='12' value='1'/>
            /
            <input type='number' class='w5' name='attr_mpr_2' min='1' max='2' value='1'/>
        </span>
        <label>Movement Points:</label>
        <span>
            <input type='number' name='attr_mp' readonly/>
            <input type='hidden' class='impulse-power-status' name='attr_impulse_power_status' value='0'/>
            <span class='no-impulse-power' title='no impulse power = max 1'>&#x1F534;</span>
        </span>
        <label>MP by Phase:</label> 
        <input type='hidden' name='attr_ta'/>
        <span>
            <span name='attr_mp1'></span> | <span name='attr_mp2'></span> | <span name='attr_mp3'></span>
        </span>
    </div>
    <br/>

    <div class='grid-6col warp-panel'>
        <input type='hidden' class='warp-show-content' name='attr_warp_show_content' value='1'/>
        <div class='warp-content'>
            <h4>Warp Drive</h4>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>

            <input type='hidden' class='warp-factor-status' name='attr_warp_factor_status' value='0'/>
            <button type='action' class='btn btn-jump' name='act_jump'>Engage Warp Drive</button>
            <span></span>
            <label><strong>TPA to Warp:</strong></label>
            <input type='number' class='em' name='attr_tpa_warp' min='0' value='0' readonly/>
            <span></span>
            <span></span>

            
            <label>Warp Factor Ratio:</label>
            <input type='hidden' name='attr_wfr_jump'/>
            <input type='hidden' name='attr_wfr_cruise'/>
            <span>
                <input type='number' class='w5' name='attr_wfr_1' value='0' readonly/>
                /
                <input type='number' class='w5' name='attr_wfr_2' value='1' readonly/>
            </span>
            <label>Current Warp Factor:</label>
            <input type='hidden' class='wf-current-status' name='attr_wf_current_status'/>
            <input type='number' class='wf-current' min='0' value='0' name='attr_wf_current' readonly/>
            <label>Desired Warp Factor:</label>
            <input type='hidden' class='wf-desired-status' name='attr_wf_desired_status'/>
            <input type='number' class='em' min='0' value='0' name='attr_wf_desired'/>

            <label>Safe Cruise WF:</label>
            <input type='number' class='w5' name='attr_wf_cruise' min='0' value='0'/>
            <label>Emergency WF:</label>
            <input type='number' class='w5' name='attr_wf_emergency' min='0' value='0'/>
            <label>Stress Charts:</label>
            <span>
                <input type='text' class='w5' name='attr_stress_cruise' maxlength='1'/>
                /
                <input type='text' class='w5' name='attr_stress_emergency' maxlength='1'/> 
            </span>
        </div>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='shields-header header-container'>
        <h2>Shield Control
            <input type='hidden' class='crewbonus3' name='attr_crewbonus3' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_shields_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shields_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shields-grid-repair repair' name='act_shields_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col shields-panel'>
        <label>Shield Type:</label>
        <input type='text' class='w10' name='attr_shield_type'/>
        <label><strong>TPA to Shields:</strong></label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='sp-remaining-status' name='attr_sp_remaining_status'/>
        <input type='number' class='sp-remaining' name='attr_sp_remaining' value='0' readonly/>

        <label>Shield Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_spr_1' min='1' max='2' value='1'/>
            /        
            <input type='number' class='w5' name='attr_spr_2' min='1' max='6' value='1'/>
        </span>
        <label>Max Shield Power:</label>
        <input type='number' name='attr_shield_max' min='0' max='16' value='0'/>
        <label>SPA Remaining:</label>
        <input type='number' name='attr_sp' readonly/>
    </div>
    <br/>
    <div class='grid-6col spa-panel'>
        <h4 class='span-grid'>Shield Configuration</h4>

        <div class='shields-allocated'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1a-status' name='attr_shield_1a_status'/>
                <input type='number' class='shield-1' name='attr_shield_1' min='0' value='0' title='Shield #1 (f/p)'/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2a-status' name='attr_shield_2a_status'/>
                <input type='number' class='shield-2' name='attr_shield_2' min='0' value='0' title='Shield #2 (fwd)'/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3a-status' name='attr_shield_3a_status'/>
                <input type='number' class='shield-3' name='attr_shield_3' min='0' value='0' title='Shield #3 (f/s)'/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6a-status' name='attr_shield_6a_status'/>
                <input type='number' class='shield-6' name='attr_shield_6' min='0' value='0' title='Shield #6 (a/p)'/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                
                <input type='hidden' class='shield-5a-status' name='attr_shield_5a_status'/>
                <input type='number' class='shield-5' name='attr_shield_5' min='0' value='0' title='Shield #5 (aft)'/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4a-status' name='attr_shield_4a_status'/>
                <input type='number' class='shield-4' name='attr_shield_4' min='0' value='0' title='Shield #4 (a/s)'/>
            </span>
        </div>

        <div class='shields-current'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1c-status' name='attr_shield_1c_status'/>
                <input type='number' class='shield-1c' name='attr_shield_1c' readonly/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2c-status' name='attr_shield_2c_status'/>
                <input type='number' class='shield-2c' name='attr_shield_2c' readonly/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3c-status' name='attr_shield_3c_status'/>
                <input type='number' class='shield-3c' name='attr_shield_3c' readonly/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6c-status' name='attr_shield_6c_status'/>
                <input type='number' class='shield-6c' name='attr_shield_6c' readonly/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                <input type='hidden' class='shield-5c-status' name='attr_shield_5c_status'/>
                <input type='number' class='shield-5c' name='attr_shield_5c' readonly/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4c-status' name='attr_shield_4c_status'/>
                <input type='number' class='shield-4c' name='attr_shield_4c' readonly/>
            </span>
        </div>
    </div>
    <br/>
    <div class='grid-6col shield-status-panel'>
        <h4 class='span-grid'>Shield Generators Status</h4>

        <label>Shield #1 (<strong>f/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-1-status' name='attr_shield_1_status' value='0'/>
            <input type='hidden' name='attr_shield_1_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_1_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_1_repair'>Repair</button>
        </span>
        <label>Shield #2 (<strong>fwd</strong>):</label>
        <span>
            <input type='hidden' class='shield-2-status' name='attr_shield_2_status' value='0'/>
            <input type='hidden' name='attr_shield_2_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_2_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_2_repair'>Repair</button>
        </span>
        <label>Shield #3 (<strong>f/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-3-status' name='attr_shield_3_status' value='0'/>
            <input type='hidden' name='attr_shield_3_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_3_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_3_repair'>Repair</button>
        </span>

        <label>Shield #6 (<strong>a/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-6-status' name='attr_shield_6_status' value='0'/>
            <input type='hidden' name='attr_shield_6_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_6_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_6_repair'>Repair</button>
        </span>
        <label>Shield #5 (<strong>aft</strong>):</label>
        <span>
            <input type='hidden' class='shield-5-status' name='attr_shield_5_status' value='0'/>
            <input type='hidden' name='attr_shield_5_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_5_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_5_repair'>Repair</button>
        </span>
        <label>Shield #4 (<strong>a/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-4-status' name='attr_shield_4_status' value='0'/>
            <input type='hidden' name='attr_shield_4_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_4_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_4_repair'>Repair</button>
        </span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='fc-header header-container'>
        <h2>Fire Control
            <input type='hidden' class='crewbonus1' name='attr_crewbonus1' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_weapons_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_weapons_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-weapons-grid-repair repair' name='act_weapons_grid_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' name='attr_crewbonustohitapplied' value='0'/>
    <div class='grid-6col fc-panel'>
        <span></span>
        <span></span>
        <label><strong>TPA to Weapons:</strong></label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='wp-remaining-status' name='attr_wp_remaining_status'/>
        <input type='number' class='wp-remaining' name='attr_wp_remaining' value='0' readonly/>
    </div>
    <br/>

    
    <div class='grid-6col beams-panel'>
        <h4 class='span-grid'>Beam Weapons</h4>
        <input type='hidden' name='attr_wp_beam'/>
        <div class='span-grid'>
            <label style='padding-left: 27px;'>Desig. (Arcs)</label>
            <label style='padding-left: 26px;'>Range</label>
            <label style='padding-left: 13px;'>Chart</label>
            <label style='padding-left: 7px;'>Power</label>
            <label style='padding-left: 18px;'>Max</label>
            <label style='padding-left: 24px;'>+3</label>
            <label style='padding-left: 25px;'>+2</label>
            <label style='padding-left: 26px;'>+1</label>
            <label style='padding-left: 95px;'>Target</label>
            <label style='padding-left: 65px;'>Dist.</label>
            <label style='padding-left: 7px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_beams'>
            <input type='hidden' class='weapon-state-status' name='attr_weapon_state_status' value='0'/>
            <select class='damaged state-select weapon-state' name='attr_state' value='0'>
                <option value='0' selected>N</option>
                <option value='1'>D</option>
                <option value='2'>R</option>
                <option value='3'>X</option>
            </select>
            <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w3 firing-chart' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='hidden' class='power-status' name='attr_power_status'/>
            <input type='number' class='power' name='attr_power' min='0' max='10' value='0'/> /
            <input type='number' name='attr_power_max' min='0' max='10' value='0'/>
            <input type='text' class='w3' name='attr_bonus_3' value='-'/>
            <input type='text' class='w3' name='attr_bonus_2' value='-'/>
            <input type='text' class='w3' name='attr_bonus_1' value='-'/> 
            <span>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='text' class='w3' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/> 
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
            <button type='action' class='btn weapon-repair repair' name='act_weapon-repair'>Repair</button>
        </fieldset>
    </div>
    <br/>
        
    <div class='grid-6col missiles-panel'>
        <h4 class='span-grid'>Missile Weapons</h4>
        <input type='hidden' name='attr_wp_missile'/>
        <div class='span-grid'>
            <label style='padding-left: 27px;'>Desig. (Arcs)</label>
            <label style='padding-left: 26px;'>Range</label>
            <label style='padding-left: 13px;'>Chart</label>
            <label style='padding-left: 18px;'>Power</label>
            <label style='padding-left: 4px;'>Damage</label>
            <label style='padding-left: 7px;'>Arm</label>
            <label style='padding-left: 169px;'>Target</label>
            <label style='padding-left: 65px;'>Dist.</label>
            <label style='padding-left: 7px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_missiles'>
            <input type='hidden' class='weapon-state-status' name='attr_weapon_state_status' value='0'/>
            <select class='damaged state-select weapon-state' name='attr_state' value='0'>
                <option value='0' selected>N</option>
                <option value='1'>D</option>
                <option value='2'>R</option>
                <option value='3'>X</option>
            </select>
            <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w3 firing-chart' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='number' name='attr_cost' min='1' max='4' value='1'/>
            <input type='number' name='attr_power' min='1' max='20' value='1'/>
            <input type='hidden' class='missile-armed-status' name='attr_armed_status'/>
            <input type='checkbox' class='missile-armed' style='margin-left: 13px;' value='1' name='attr_armed'/>
            <span style='margin-left: 14px;'>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' style='margin-left: 87px;' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='text' class='w3' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/>
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
            <button type='action' class='btn weapon-repair repair' name='act_weapon-repair'>Repair</button>
        </fieldset>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Construction Data</h2> 

    <div class='grid-6col construction-panel'>
        <span class='span2'>
            <select name='attr_faction'>
                <option selected>Select faction...</option>
                <option value='federation'>United Federation of Planets</option>
                <option value='klingon'>Klingon Empire</option>
            </select>
        </span>

        <span class='span2'>
            <input type='text' class='w20' name='attr_class' placeholder='Class...'/>
        </span>

        <label>Type:</label>
        <input type='text' class='w12' name='attr_type' placeholder='Type...'/>

        <label>Date Entering Service:</label>
        <input type='text' class='w7' name='attr_date' placeholder='Date...'/>

        <label>Number Constructed:</label>
        <input type='number' class='w7' name='attr_num' min='0'/>

        <label>Control Computer Type:</label>
        <input type='text' class='w7' name='attr_computer'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Hull Data</h2>
    <div class='grid-6col hull-panel'>
        <label>Superstructure:</label>
        <input type='number' class='w7' name='attr_hp_max' min='0' value='0'/>
        
        <label>Damage Chart:</label>
        <select class='w7' name='attr_dmg_chart'>
            <option value='0' selected>Select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
        </select>

        <label>Mass (mt):</label>
        <input type='number' class='w7' name='attr_mass' min='0' max='999999' value='0'/>

        <label>Length (m):</label>
        <input type='number' class='w7' name='attr_length' min='0'/>

        <label>Width (m):</label>
        <input type='number' class='w7' name='attr_width' min='0'/>
        
        <label>Height (m):</label>
        <input type='number' class='w7' name='attr_height' min='0'/>
        
        <label>Cargo Units (SCU):</label>
        <input type='number' class='w7' name='attr_scu' min='0' value='0'/>

        <label>Cargo Capacity:</label>
        <span name='attr_scu_cap'></span>

        <label>Cargo Transporters:</label>
        <input type='number' class='w7' name='attr_scu_trans' min='0' value='0'></span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Crew Data</h2>
    <div class='grid-6col crew-panel'>
        <label>Crew:</label>
        <input type='number' class='w7' name='attr_crew_max' min='0' value='0'/>
        
        <label>Passengers/Troops:</label>
        <input type='number' class='w7' name='attr_troops_max' min='0' value='0'/>

        <label>Shuttlecraft:</label>
        <input type='number' class='w7' name='attr_shuttlecraft_max' min='0' value='0'/>

        <label>Transporters:</label>
        <input type='number' class='w7' name='attr_trans_standard' min='0' value='0'/>

        <label>Combat:</label>
        <input type='number' class='w7' name='attr_trans_combat' min='0' value='0'/>

        <label>Emergency:</label>
        <input type='number' class='w7' name='attr_trans_emergency' min='0' value='0'/>

    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Maintenance</h2>
    <div class='grid-6col maint-panel'>
        <p class='span-grid'><strong>Do not use these controls during battle!</strong></p>
        <button type='action' class='btn' name='act_repair'>Repair/Reset Vessel</button>
    </div>

<!-- Banner placeholders (see readme) -->
<input type='hidden' name='attr_banner_federationfirebeams' value='[x](https://files.d20.io/images/459374797/BrLK7l69a5n4Mfomy8M4GA/original.png)'/>
<input type='hidden' name='attr_banner_federationfiremissiles' value='[x](https://files.d20.io/images/461676845/PIWNmdJhQ8DotQAYJS7Eew/original.png)'/>
<input type='hidden' name='attr_banner_federationwarp' value='[x](https://files.d20.io/images/461519720/yapt5OaNN9fy0m-b2HhVaQ/original.png)'/>
<input type='hidden' name='attr_banner_klingonfirebeams' value='[x](https://files.d20.io/images/461674377/cX_DbSv-iBzHRa8XCK36uw/original.png)'/>
<input type='hidden' name='attr_banner_klingonfiremissiles' value='[x](https://files.d20.io/images/459155112/hNZ9AQX33_kJr7InoxYVbA/original.png)'/>
<input type='hidden' name='attr_banner_klingonwarp' value='[x](https://files.d20.io/images/461677914/LFn_ncPFcBHm_yHjz6xr9A/original.png)'/>

<script type='text/worker'>
const CREW_BONUS_WEAPONS = 1;
const CREW_BONUS_ENGINES = 2;
const CREW_BONUS_SHIELD = 3;
const CREW_BONUS_REPAIR = 4;const DAMAGE_CHART_DEFAULT = `C`;
const DAMAGE_RESULT_BEAM = `Beam Weapon`;
const DAMAGE_RESULT_BRIDGE = `Bridge 2C`;
const DAMAGE_RESULT_ENG = `Engineering`;
const DAMAGE_RESULT_IMP = `Impulse`;
const DAMAGE_RESULT_IMP_HALF = `Impulse (x1/2)`;
const DAMAGE_RESULT_MISSILE = `Missile Weapon`;
const DAMAGE_RESULT_PORT = `PWE`;
const DAMAGE_RESULT_PORT_HALF = `PWE (x1/2)`;
const DAMAGE_RESULT_SENSORS = `Sensors`;
const DAMAGE_RESULT_SHIELD = `Shield Gen`;
const DAMAGE_RESULT_STBD = `SWE`;
const DAMAGE_RESULT_STBD_HALF = `SWE (x1/2)`;
const DAMAGE_RESULT_SUP = `Sup 2C`;
const DAMAGE_RESULT_SUP_HALF = `Sup C (x1/2)`;
const DAMAGE_RESULT_SUP_PORT = `PWE/Sup C (x1/2)`;
const DAMAGE_RESULT_SUP_STBD = `SWE/Sup C (x1/2)`;
const DAMAGE_RESULT_WARP = `Any WE`;
const DAMAGE_STATUSES = [`Online`, `Dmg 1-8`, `Dmg 1-6`, `Dmg 1-4`, `Dmg 1-2`, `DEST`];
const ENGINE_LOCATION_PORT = `2`;
const ENGINE_LOCATION_STBD = `3`;
const ENGINE_TYPE_IMPULSE = 1;
const ENGINE_TYPE_WARP = 2;
const ENGINE_TYPE_GENERATOR = 3;
const ENGINE_WARP_NAME_NONE = `No Warp Drive`;
const MAX_PERCENTAGE = 100;
const ROLL20_CHAR_URL = `https://journal.roll20.net/character/`;    

// ON SHEET OPENED
on(`sheet:opened`,function(){
    getAttrs([`character_name`], function(values) {
        const charactername = values[`character_name`];
        
        const output = {};

        const SEARCH_STR = "Copy of";
        if (charactername.includes(SEARCH_STR)) {
            output[`caprating`] = 45 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
            output[`crewrating`] = output[`crewefficiency`] = 25 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
        }

        output[`roll20charurl`] = ROLL20_CHAR_URL;

        setAttrs(output);
    });
});

// Async function to return a querystring value
const extractChatData = async (query) => {
    query = await startRoll(`!{{target=[[0[response=${query}]]]}}`);
    finishRoll(query.rollId);
    return query.results.target.expression.replace(/0\[response=(.+?)\]/,`$1`);
};

// Async function to return a token name and its character id 
const extractTargetData = async () => {
    const query = await startRoll(`!{{target=[[0+{"tokenName":"@{target|token_name}","charId":"@{target|character_id}"}]]}} /direct`);
    finishRoll(query.rollId);
    const expr = query.results.target.expression;
    const jsonStr = expr.replace(/0\+\{(.+)\}/, `{$1}`);
    return JSON.parse(jsonStr);
};

// Roll a random number from MIN to MAX
function getRandomIntInclusive(min, max) {
  const minCeiled = Math.ceil(min);
  const maxFloored = Math.floor(max);
  return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);
}

// Format large numbers with commas
function formatNumber(value) {
    value = value.replace(/\D/g, ``);
    return value.replace(/\B(?=(\d{3})+(?!\d))/g, `,`);
}

// CAPTAIN RATING change
on(`change:caprating`, function(eventInfo) {
    getAttrs([`caprating`], function(values) {
        const caprating = parseInt(values[`caprating`]);

        const output = {};
        output[`caprating_ta`] = caprating * MAX_PERCENTAGE;
        setAttrs(output);
    });
});

// CARGO CAPACITY calculation
on(`change:scu`, function(eventInfo) {
    getAttrs([`scu`], function(values) {
        const scu = parseInt(values[`scu`]) || 0;

        const scuCapacity = formatNumber(String(scu * 50));

        const output = {};
        output[`scu_cap`] = `${scuCapacity} mt`;
        setAttrs(output);
    });
});

// COMBAT EFFICIENCY calculation
on(`change:defense change:wdf`, function(eventInfo) {
    getAttrs([`defense`, `wdf`], function(values) {
        const defense = parseFloat(values[`defense`]) || 0;
        const wpnDmgFactor = parseFloat(values[`wdf`]) || 0;

        const combatEfficiency = parseFloat((defense * wpnDmgFactor / MAX_PERCENTAGE).toFixed(2));

        const output = {};
        output[`ce`] = combatEfficiency;
        setAttrs(output);
    });
});

// CREW BONUS selection
on(`change:crewbonus`, async function(eventInfo) {
    try {
        const values = await getAttrsAsync([`crewbonus`, `hp`, `hp_max`, `crewbonus_saved`, `crewbonus_engineid`]);
        const crewBonus = parseInt(values[`crewbonus`]) || 0;
        const output = {};

        // Save crewBonus value to crewbonus_saved
        output[`crewbonus_saved`] = crewBonus;

        // Reset crewbonus1, crewbonus2, crewbonus3 to 0 (skip crewbonus4)
        output[`crewbonus1`] = output[`crewbonus2`] = output[`crewbonus3`] = 0;

        // If crewBonus is less than 4, set the corresponding crewbonus field to 1
        if (crewBonus < 4) {
            output[`crewbonus${crewBonus}`] = 1;
        }

        // If crewBonus = 4, increase hp by 1 (no higher than hp_max)
        if (crewBonus === 4) {
            const currentHp = parseInt(values[`hp`]) || 0;
            const maxHp = parseInt(values[`hp_max`]) || 0;
            if (currentHp == maxHp) output[`crewbonus_saved`] = 0; // Don't save if there's no hp dmg
            output[`hp`] = Math.min(currentHp + 1, maxHp);
        }

        // If crewbonus_saved = 4, decrease hp by 1 (can go below zero)
        if (parseInt(values[`crewbonus_saved`]) === 4) {
            const currentHp = parseInt(values[`hp`]) || 0;
            output[`hp`] = currentHp - 1;
        }

        // If crewBonus = 5, add +1 to the Impulse engine with lowest power
        if (crewBonus === 5) {
            const engineIds = await getSectionIDsAsync(`repeating_engines`);
            let lowestPower = Infinity;
            let lowestEngineId = null;

            // Find Impulse engine with lowest power
            for (const engineId of engineIds) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${engineId}_engine_type`,
                    `repeating_engines_${engineId}_engine_power`,
                    `repeating_engines_${engineId}_engine_power_full`
                ]);

                const engineType = parseInt(engineValues[`repeating_engines_${engineId}_engine_type`]) || 0;
                const enginePower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                const enginePowerFull = parseInt(engineValues[`repeating_engines_${engineId}_engine_power_full`]) || 0;

                if (engineType === 1 && enginePower < lowestPower && enginePower < enginePowerFull) {
                    lowestPower = enginePower;
                    lowestEngineId = engineId;
                }
            }

            // Increase power of lowest Impulse engine
            if (lowestEngineId) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${lowestEngineId}_engine_power`,
                    `repeating_engines_${lowestEngineId}_engine_power_full`
                ]);
                const currentPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power`]) || 0;
                const maxPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power_full`]) || 0;

                output[`repeating_engines_${lowestEngineId}_engine_power`] = Math.min(currentPower + 1, maxPower);
                output[`crewbonus_engineid`] = lowestEngineId;
            }
        }

        // If crewbonus_saved = 5, subtract 1 from previously modified Impulse engine
        if (parseInt(values[`crewbonus_saved`]) === 5) {
            const engineId = values[`crewbonus_engineid`];
            if (engineId) {
                const engineValues = await getAttrsAsync([`repeating_engines_${engineId}_engine_power`]);
                const currentPower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                output[`repeating_engines_${engineId}_engine_power`] = Math.max(currentPower - 1, 0);
            }
        }

        // If crewBonus = 6, add +1 to the Warp engine with lowest power
        if (crewBonus === 6) {
            const engineIds = await getSectionIDsAsync(`repeating_engines`);
            let lowestPower = Infinity;
            let lowestEngineId = null;

            // Find Warp engine with lowest power
            for (const engineId of engineIds) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${engineId}_engine_type`,
                    `repeating_engines_${engineId}_engine_power`,
                    `repeating_engines_${engineId}_engine_power_full`
                ]);

                const engineType = parseInt(engineValues[`repeating_engines_${engineId}_engine_type`]) || 0;
                const enginePower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                const enginePowerFull = parseInt(engineValues[`repeating_engines_${engineId}_engine_power_full`]) || 0;

                if (engineType === 2 && enginePower < lowestPower && enginePower < enginePowerFull) {
                    lowestPower = enginePower;
                    lowestEngineId = engineId;
                }
            }

            // Increase power of lowest Warp engine
            if (lowestEngineId) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${lowestEngineId}_engine_power`,
                    `repeating_engines_${lowestEngineId}_engine_power_full`
                ]);
                const currentPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power`]) || 0;
                const maxPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power_full`]) || 0;

                output[`repeating_engines_${lowestEngineId}_engine_power`] = Math.min(currentPower + 1, maxPower);
                output[`crewbonus_engineid`] = lowestEngineId;
            }
        }

        // If crewbonus_saved = 6, subtract 1 from previously modified Warp engine
        if (parseInt(values[`crewbonus_saved`]) === 6) {
            const engineId = values[`crewbonus_engineid`];
            if (engineId) {
                const engineValues = await getAttrsAsync([`repeating_engines_${engineId}_engine_power`]);
                const currentPower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                output[`repeating_engines_${engineId}_engine_power`] = Math.max(currentPower - 1, 0);
            }
        }

        await setAttrsAsync(output);
    } catch (error) {
        console.error(`Error in crewbonus handler:`, error);
    }
});

// CREW calculation
on(`change:crew change:crew_max`, function(eventInfo) {
    getAttrs([`crew`, `crew_max`], function(values) {
        const crew = parseInt(values[`crew`]) || 0;
        const crewMax = parseInt(values[`crew_max`]) || 0;

        const output = {};
        output[`crew-percent`] = Math.max(0, Math.round(crew / crewMax * MAX_PERCENTAGE));
        output[`crew_status`] = crew < (crewMax / 2) || crew > crewMax ? 1 : crew < crewMax ? 2 : 0;
        setAttrs(output);
    });
});

// CREW EFFICIENCY calculation
on(`change:crewrating change:crew-percent`, function(eventInfo) {
    getAttrs([`crewrating`, `crew-percent`], function(values) {
        const crewRating = parseInt(values[`crewrating`]) || 0;
        const crewPercent = values[`crew-percent`] || `0`;
        const crewCasualties = MAX_PERCENTAGE - crewPercent;

        const casualtyBrackets = [19, 39, 59, 69, MAX_PERCENTAGE];
        const rollPenalties = [0, -1, -2, -5, -10];
        const efficiencyModifiers = [0, 10, 20, 50, 50];

        let i = 0;
        while (crewCasualties > casualtyBrackets[i]) i++;

        const output = {};
        output[`crewefficiency`] = Math.max(0, crewRating - efficiencyModifiers[i]);
        output[`crewrollpenalty`] = rollPenalties[i];
        setAttrs(output);
    });
});

// DAMAGE roll
on(`clicked:rolldamage`, async () => {
    const shieldArcStr = await extractChatData(`?{Shield Arc|#1 (f/p)|#2 (fwd)|#3 (f/s)|#4 (a/s)|#5 (aft)|#6 (a/p)}`);
    const baseDamage = +await extractChatData(`?{Damage|0}`);
  
    const shieldArc = shieldArcStr.substring(1,2);
    const shieldVar = `shield_${shieldArc}c`;
    const values = await getAttrsAsync([`dmg_chart`]);
    const damageChart = values[`dmg_chart`] || DAMAGE_CHART_DEFAULT;

    const damageResults = [
        13, 16, 6, 6, 3, 8, 1, 2, 14, 12,
        13, 16, 17, 6, 3, 7, 1, 4, 14, 12,
        13, 16, 7, 7, 4, 9, 1, 2, 14, 12,
        13, 16, 7, 7, 9, 11, 1, 2, 2, 2,
        13, 16, 17, 2, 2, 10, 1, 2, 5, 15,
        13, 16, 6, 6, 8, 11, 1, 2, 2, 2,

        13, 16, 6, 6, 3, 8, 1, 2, 14, 12,
        13, 16, 17, 2, 2, 2, 1, 5, 14, 12,
        13, 16, 7, 7, 4, 9, 1, 2, 14, 12,
        13, 16, 7, 7, 4, 11, 1, 2, 2, 9,
        13, 16, 17, 6, 7, 10, 1, 2, 2, 15,
        13, 16, 6, 6, 3, 11, 1, 2, 2, 8,

        13, 16, 6, 3, 2, 2, 1, 8, 14, 12,
        13, 16, 17, 2, 2, 2, 1, 5, 14, 12,
        13, 16, 7, 4, 2, 2, 1, 9, 14, 12,
        13, 16, 7, 7, 4, 11, 1, 2, 2, 9,
        13, 16, 17, 6, 3, 10, 1, 7, 4, 15,
        13, 16, 6, 6, 3, 11, 1, 2, 2, 8
    ];

    //13, 16, 6, 3, 2, 2, 1, 8, 14, 12,

    let residualDamage = 0;
    let penetratingDamage = 0;
    let returnStr = ``;
    let rollStr = `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Damage Results (Chart ${damageChart})}} {{color=red}} {{Incoming Dmg=${baseDamage}}} {{On Shield Arc=${shieldArcStr}}} `;

    const hitRollResult = getRandomIntInclusive(0, 9);

console.log ('damageChart: ' + damageChart);
console.log ('shieldArc: ' + shieldArc);
console.log ('hitRollResult: ' + hitRollResult);
console.log('damageChart calc: ' + ((damageChart.charCodeAt(0) - 65) * 60));
console.log('shieldArc calc: ' + ((shieldArc - 1) * 10));
    const hitLocation = ((damageChart.charCodeAt(0) - 65) * 60) + ((shieldArc - 1) * 10) + hitRollResult;
console.log ('hitLocation: ' + hitLocation);
    
    const damageHandlers = {
        1: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(penetratingDamage);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage, 2);
                result += crewReturn;
            }
            return result;
        },
        2: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_HALF} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(penetratingDamage);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage);
                result += crewReturn;
            }
            return result;
        },
        3: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_PORT} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_PORT, shieldArc);
            }
            return result;
            },
        4: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_STBD} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_STBD, shieldArc);
            }
            return result;
        },
        5: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_WARP} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, null, shieldArc);
            }
            return result;
        },
        6: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_PORT_HALF} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_PORT, shieldArc);
            }
            return result;
        },
        7: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_STBD_HALF} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_STBD, shieldArc);
            }
            return result;
        },
        8: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_PORT} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                let { residualDamage, returnStr: warpReturn } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_PORT);
                result += warpReturn;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
                        penetratingDamageSup += residualDamage;
                    } else {
                        let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                        result += residualReturn;
                    }
                }
                result += warpReturn;
                let { residualDamage: supResidual, returnStr: supReturn } = await damageSup(penetratingDamageSup);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamageSup);
                result += crewReturn;
            }
            return result;
        },
        9: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_STBD} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                let { residualDamage, returnStr: warpReturn } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_STBD);
                result += warpReturn;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
                        penetratingDamageSup += residualDamage;
                    } else {
                        let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                        result += residualReturn;
                    }
                }
                result += warpReturn;
                let { residualDamage: supResidual, returnStr: supReturn } = await damageSup(penetratingDamageSup);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamageSup);
                result += crewReturn;
            }
            return result;
        },
        10: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_IMP} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: impulseReturn } = await damageImpulse(penetratingDamage);
                result += impulseReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        11: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_IMP_HALF} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: impulseReturn } = await damageImpulse(penetratingDamage);
                result += impulseReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        12: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_BRIDGE} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(1);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage, 2, true);
                result += crewReturn;
            }
            return result;
        },
        13: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SHIELD} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`shield_${shieldArc}`, penetratingDamage);
                result += systemReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        14: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SENSORS} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`sensors`, penetratingDamage);
                undoSensorLock();
                result += systemReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        15: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_ENG} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                const gridNames = [`Shields`, `Weapons`, `Movement`];
                const randomGrid = getRandomIntInclusive(0, 2);
                result += ` {{Grid=${gridNames[randomGrid]}}}`;
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`${gridNames[randomGrid].toLowerCase()}_grid`, penetratingDamage);
                result += systemReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        16: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_BEAM} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: weaponReturn } = await damageWeapon(shieldArc, `repeating_beams`, penetratingDamage);
                result += weaponReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        17: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_MISSILE} (${hitRollResult+1})}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: weaponReturn } = await damageWeapon(shieldArc, `repeating_missiles`, penetratingDamage);
                result += weaponReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        }
    };

    const hitResult = damageResults[hitLocation];
    rollStr += await damageHandlers[hitResult]?.(shieldVar, baseDamage) || ``;

    await startRoll(
        `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Damage Results}} {{color=red}} {{Incoming Dmg=${baseDamage}}} {{On Shield Arc=${shieldArcStr}}} ${rollStr}`,
        roll => finishRoll(roll.rollId)
    );
});

async function handleWarpDamage(penetratingDamage, engineLocation, shieldArc) {
    let result = ``;
    const { residualDamage, returnStr } = await damageWarp(penetratingDamage, engineLocation);
    result += returnStr;
    if (residualDamage) {
        if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
            result += (await damageSup(residualDamage)).returnStr;
        } else {
            result += (await damageResidual(residualDamage)).returnStr;
        }
    }
    return result;
}

// DAMAGE CREW
async function damageCrew(myDmg, myFactor = 1, isBridge = false) {
    const values = await getAttrsAsync([`crew`, `crew_max`, `crewrating`, `hp_max`]);
    const crew = parseInt(values[`crew`]) || 0;
    const crewMax = parseInt(values[`crew_max`]) || 0;
    const crewRating = parseInt(values[`crewrating`]) || 0;
    const maxSup = parseInt(values[`hp_max`]) || 0;

    const supIntervals = [0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 19, 34, 50, 999];
    const percentsLost = [0, MAX_PERCENTAGE, 50, 30, 25, 20, 18, 14, 10, 8, 6, 4, 2, 1];

    // Determine percentage bracket based on max sup
    let index = -1;
    do {
        index++;
    }
    while (maxSup > supIntervals[index])

    // Determine amount of crew lost
    const isCrewEffective = getRandomIntInclusive(1, MAX_PERCENTAGE) <= crewRating;
    const CREW_MAX_DMG = 5;
    const percentLost = Math.min((isBridge == true) ? 20 : MAX_PERCENTAGE, Math.floor(percentsLost[index] * Math.min(CREW_MAX_DMG, myDmg) * myFactor)) / (isCrewEffective ? 2 : 1);
    const crewLost = Math.ceil(crewMax * percentLost / MAX_PERCENTAGE);
    const newCrew = Math.max(0, crew - crewLost);

    const output = {};
    output[`crew`] = newCrew;
    await setAttrsAsync(output);
    
    const CREW_EFFECTIVE_TRUE = `Success!`;
    const CREW_EFFECTIVE_FALSE = `Failed`;
    const residualDamage = 0;
    const returnStr = ` {{Crew Check=${isCrewEffective ? CREW_EFFECTIVE_TRUE : CREW_EFFECTIVE_FALSE}}} {{Crew Lost=[[${crewLost}]]}}`;
    return { residualDamage, returnStr };
}

// DAMAGE IMPULSE ENGINE
async function damageImpulse(myDmg = 0, myFactor = 1) {
    const ids = await getSectionIDsAsync(`repeating_engines`);
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let enginePower = -1;
    let targetId = null;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
            enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            targetId = id;
        }
    });

    let residualDamage = myDmg;

    const damage = Math.floor(myDmg * myFactor);
    const newEnginePower = Math.max(0, enginePower - damage);
    residualDamage = Math.max(0, damage - enginePower);
    
    output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
    await setAttrsAsync(output);
    const returnStr = ` {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;

    return { residualDamage, returnStr };
}

// DAMAGE SHIELD
async function damageShield(myShieldVar = ``, myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync([myShieldVar]);
    const shieldPower = parseInt(values[myShieldVar]) || 0;

    const shieldPowerRemaining = Math.max(0, shieldPower - Math.floor(myDmg * myFactor));
    const myDmgAbsorbed = shieldPower - shieldPowerRemaining;
    const penetratingDamage = Math.max(0, Math.floor(myDmg * myFactor) - shieldPower);

    const output = {};
    output[myShieldVar] = shieldPowerRemaining;
    await setAttrsAsync(output);

    const returnStr = ` {{Shield Strength=${shieldPower}}} {{Absorbed=${myDmgAbsorbed}}} {{Penetrating Dmg=[[${penetratingDamage}]]}}`;
    return { penetratingDamage, returnStr };
}

// DAMAGE SYSTEM
async function damageSystem(mySystemVar = ``, myDmg = 0) {
    const values = await getAttrsAsync([`${mySystemVar}_state`]);
    const systemState = parseInt(values[`${mySystemVar}_state`]) || 0;
    const heavyDamage = Math.floor(Math.max(0, (myDmg - 5)) / 5);

    const systemStateNew = Math.min(5, systemState + 1 + heavyDamage);
    const myDmgResidual = (systemState + 1 + heavyDamage) - systemStateNew; // Excess heavy dmg not applied

    const output = {};
    output[`${mySystemVar}_state`] = systemStateNew;
    output[`${mySystemVar}_status`] = systemStateNew == 5 ? 2 : systemStateNew > 0 ? 1 : 0;
    output[`${mySystemVar}_to_repair`] = 10 - (systemStateNew * 2);
    if (mySystemVar == `shields_grid`) output[`shield_1c`] = output[`shield_2c`] = output[`shield_3c`] = output[`shield_4c`] = output[`shield_5c`] = output[`shield_6c`] = 0;
    await setAttrsAsync(output);

    const residualDamage = systemStateNew == systemState ? myDmg : (myDmgResidual * 5) + (Math.max(0, (myDmg - 5)) % 5); // HOUSE RULE: Apply all remainder dmg to resid
    const returnStr = ` {{Damage Status=${DAMAGE_STATUSES[systemStateNew]}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE
async function damageSup(myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync([`hp`]);
    const oldSup = parseInt(values[`hp`]) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output[`hp`] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure=${oldSup}}} {{Sup Damage=[[${supDamage}]]}} {{Sup Remaining=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE (RESIDUAL)
async function damageResidual(myDmg = 0, myFactor = 0.5) {
    const values = await getAttrsAsync([`hp`]);
    const oldSup = parseInt(values[`hp`]) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output[`hp`] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure (R)=${oldSup}}} {{Sup Damage (R)=[[${supDamage}]]}} {{Sup Remaining (R)=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE WARP ENGINE
async function damageWarp(myDmg = 0, myLocation = 1, myFactor = 1) {
    const ids = await getSectionIDsAsync(`repeating_engines`);

    const ENGINE_WARP_NAME_CNTR = `CWE`;
    const ENGINE_WARP_NAME_PORT = `PWE`;
    const ENGINE_WARP_NAME_STBD = `SWE`;

    const engineLocations = [
        ENGINE_WARP_NAME_NONE, 
        ENGINE_WARP_NAME_CNTR, 
        ENGINE_WARP_NAME_PORT, 
        ENGINE_WARP_NAME_STBD
        ];

    if (myLocation === 1) myLocation = getRandomIntInclusive(2, 3); // pick an engine
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let actualLocation = -1;
    let enginePower = -1;
    let targetId = null;
    let foundAtLocation = false;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP && !foundAtLocation) {
            actualLocation = parseInt(values[`repeating_engines_${id}_engine_location`]) || 0;
            if (actualLocation == myLocation) {
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                targetId = id;
                foundAtLocation = true;
            } else {
                targetId = id;
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            }
        }
    });

    let residualDamage = myDmg;
    let returnStr = ` {{Actual Location=${engineLocations[0]}}}`;

    if (enginePower > -1 && targetId) {
        const damage = Math.floor(myDmg * myFactor);
        const newEnginePower = Math.max(0, enginePower - damage);
        residualDamage = Math.max(0, damage - enginePower);
        
        output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
        await setAttrsAsync(output);
        returnStr = ` {{Actual Location=${engineLocations[actualLocation]}}} {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;
    }

    return { residualDamage, returnStr };
}

// DAMAGE WEAPON
async function damageWeapon(myShieldNum = 1, myRepeatingSection = ``, myDmg = 0) {
    // Validate that a repeating section was provided
    if (!myRepeatingSection) {
        return { residualDamage: myDmg, returnStr: `{{Weapon Damaged=Error: No section}} ` };
    }
    
    // Get all IDs for the specified repeating section
    const weaponIds = await getSectionIDsAsync(myRepeatingSection);
    
    // Count the number of weapon items
    const weaponCount = weaponIds.length;
    
    // Build array of attribute names to retrieve
    const attrNames = [];
    weaponIds.forEach(id => {
        attrNames.push(`${myRepeatingSection}_${id}_name`);
        attrNames.push(`${myRepeatingSection}_${id}_state`);
    });
    
    // Get all attributes at once
    const attrs = await getAttrsAsync(attrNames);
    
    // Build array of weapon objects with name and state
    const weapons = weaponIds.map(id => ({
        id: id,
        name: attrs[`${myRepeatingSection}_${id}_name`] || ``,
        state: attrs[`${myRepeatingSection}_${id}_state`] || `0`
    }));
    
    // Map shield number to arc letters
    const shieldArcs = {
        1: `fp`,  // f/p
        2: `f`,   // f
        3: `fs`,  // f/s
        4: `as`,  // a/s
        5: `a`,   // a
        6: `ap`   // a/p
    };
    
    // Get the arc letters for this shield
    const arcLetters = shieldArcs[myShieldNum] || ``;
    
    // Build regex to match any of the arc letters within parentheses
    const arcPattern = new RegExp(`\\([^)]*[${arcLetters}][^)]*\\)`, `i`);
    
    // Count weapons that match the shield arc
    const matchingWeapons = weapons.filter(weapon => arcPattern.test(weapon.name));
    const matchingCount = matchingWeapons.length;
    
    // Filter matching weapons to only include those with state 0 or 2
    const eligibleWeapons = matchingWeapons.filter(weapon => weapon.state == 0 || weapon.state == 2);
    const eligibleCount = eligibleWeapons.length;
    
    let residualDamage = myDmg;
    let returnStr = ``;
    
    // If no eligible weapons, return residual damage
    if (eligibleCount === 0) {
        return { residualDamage: myDmg, returnStr: `{{Weapon Damaged=None Available}} ` };
    }
    
    // If there are eligible weapons, select one randomly and damage it
    if (eligibleCount > 0) {
        const randomIndex = getRandomIntInclusive(1, eligibleCount) - 1;
        const selectedWeapon = eligibleWeapons[randomIndex];

        // Get all matching banked weapons or default to single weapon
        const wpnBankName = selectedWeapon.name.match(/#\d+\w+/);
        const bankedRows = [];
        if (wpnBankName) {
            const nameRoot = selectedWeapon.name.match(/#\d+/);
            const ids = await getSectionIDsAsync(`${myRepeatingSection}`);
            const fieldnames = ids.flatMap(id => [
                `${myRepeatingSection}_${id}_name`,
                `${myRepeatingSection}_${id}_state`
            ]);
            const values = await getAttrsAsync(fieldnames);

            // Find the selected weapon's ID first
            const selectedWeaponId = eligibleWeapons[randomIndex].id;
            const selectedState = values[`${myRepeatingSection}_${selectedWeaponId}_state`];
            if (selectedState != 1 && selectedState != 3) {
                bankedRows.push(selectedWeaponId);
            }

            // Then add remaining matches
            ids.forEach(id => {
                const name = values[`${myRepeatingSection}_${id}_name`];
                const state = values[`${myRepeatingSection}_${id}_state`];
                if (name && name.match(nameRoot) && id !== selectedWeaponId && state != 1 && state != 3) {
                    bankedRows.push(id);
                }
            });
        } else {
            // Not in a bank — damage just this weapon
            bankedRows.push(eligibleWeapons[randomIndex].id);
        }

        let bankedNames = [];
        for (const id of bankedRows) {
            const rowAttrs = await getAttrsAsync([
                `${myRepeatingSection}_${id}_name`,
                `${myRepeatingSection}_${id}_state`
            ]);
        
            // Update state: 0 → 1, 2 → 3
            let newState = parseInt(rowAttrs[`${myRepeatingSection}_${id}_state`]) || 0;
            if (newState == 0) {
                newState = 1;
            } else if (newState == 2) {
                newState = 3;
            }
            
            // Update the attribute in Roll20
            const updateObj = {};
            updateObj[`${myRepeatingSection}_${id}_state`] = newState;
            updateObj[`${myRepeatingSection}_${id}_weapon_state_status`] = newState;
            await setAttrsAsync(updateObj);
            
            bankedNames.push(rowAttrs[`${myRepeatingSection}_${id}_name`]);

            residualDamage = Math.max(0, residualDamage - 5);
            if (residualDamage < 5) break;
        }
        returnStr = `{{Weapon Damaged=${bankedNames.join(`\\n`)}}} `;
    } else {
        returnStr = `{{Weapon Damaged=None Available}} `;
    }

    await updateWeaponsPercent();
    
    return { residualDamage, returnStr, weaponCount, weapons, matchingCount, matchingWeapons, eligibleCount, eligibleWeapons };
}

// IMPULSE POWER status indicator
on(`change:repeating_engines:engine_power`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
                    const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                    totalPower += enginePower;
                }
            });
            output[`impulse_power_status`] = totalPower == 0 ? 1 : 0;
            setAttrs(output);
        });
    });
});

// MOVEMENT POINTS AVAILABLE calculation
on(`change:tpa_movement change:mpr_1 change:mpr_2`, function(eventInfo) {
    getAttrs([`tpa_movement`, `mpr_1`, `mpr_2`], function(values) {
        const power = parseInt(values[`tpa_movement`]) || 0;
        const mpr = (parseInt(values[`mpr_1`]) || 1) / (parseInt(values[`mpr_2`]) || 1);

        const mp = Math.floor(power / mpr);
        const mpPhase1 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 1
        const mpPhase2 = Math.floor(mp / 3) + (mp % 3 == 1 ? 1 : 0); // phase 2
        const mpPhase3 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 3
        const powerUnused = power % mpr;

        const output = {};
        output[`mp`] = mp;
        output[`ta`] = mp * 10000;
        output[`mp1`] = mpPhase1;
        output[`mp2`] = mpPhase2;
        output[`mp3`] = mpPhase3;
        output[`mp_remaining`] = powerUnused;
        output[`mp_remaining_status`] = power != 0 && (powerUnused < 0 ? 1 : (powerUnused > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// REPAIR SYSTEM
on(`clicked:movement_grid_repair`, function(eventInfo) { repairSystem(`movement_grid`, `Movement Grid`); });
on(`clicked:sensors_repair`, function(eventInfo) { repairSystem(`sensors`, `Sensors`); });
on(`clicked:shield_1_repair`, function(eventInfo) { repairSystem(`shield_1`, `Shield #1 (f/p)`); });
on(`clicked:shield_2_repair`, function(eventInfo) { repairSystem(`shield_2`, `Shield #2 (fwd)`); });
on(`clicked:shield_3_repair`, function(eventInfo) { repairSystem(`shield_3`, `Shield #3 (f/s)`); });
on(`clicked:shield_4_repair`, function(eventInfo) { repairSystem(`shield_4`, `Shield #4 (a/s)`); });
on(`clicked:shield_5_repair`, function(eventInfo) { repairSystem(`shield_5`, `Shield #5 (aft)`); });
on(`clicked:shield_6_repair`, function(eventInfo) { repairSystem(`shield_6`, `Shield #6 (a/p)`); });
on(`clicked:shields_grid_repair`, function(eventInfo) { repairSystem(`shields_grid`, `Shields Grid`); energizeShields()});
on(`clicked:weapons_grid_repair`, function(eventInfo) { repairSystem(`weapons_grid`, `Weapons Grid`); });
function repairSystem(mySystemVar = ``, mySystemName = ``) {
    getAttrs([`${mySystemVar}_to_repair`, `crewrollpenalty`], function(values) {
        const repairTargetBase = parseInt(values[`${mySystemVar}_to_repair`]) || 0;
        const crewRollPenalty = parseInt(values[`crewrollpenalty`]) || 0;
        let repairTargetNew = repairTargetBase;
        const repairTarget = Math.max(0, repairTargetBase + crewRollPenalty);

        const output = {};
        const repairRoll = getRandomIntInclusive(1, 10);
        if (repairRoll <= repairTarget) {
            output[`${mySystemVar}_state`] = 0;
            output[`${mySystemVar}_status`] = 0;
            repairTargetNew = 0;
        } else {
            repairTargetNew = repairTargetBase + 1;
        }

        output[`${mySystemVar}_to_repair`] = repairTargetNew;
        setAttrs(output);

        startRoll(
            `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Repair Roll}} {{color=gold}} {{System=${mySystemName}}} {{To-Repair=[[${repairTarget}]]}} {{Roll=[[${repairRoll}]]}}`,
            roll => finishRoll(roll.rollId)
        );
    });
};

// REPAIR WEAPON
on(`clicked:repeating_beams:weapon-repair clicked:repeating_missiles:weapon-repair`, async function(event) {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attrs = await getAttrsAsync([
        `${row}_name`,
        `${row}_power`,
        `${row}_power_max`,
        `${row}_state`,
        `${row}_weapon_state_status`,
        `crewrollpenalty`
    ]);

    const wpnName = attrs[`${row}_name`];
    const beamPower = attrs[`${row}_power`];
    const beamPowerMax = attrs[`${row}_power_max`];
    const currentState = attrs[`${row}_state`];
    const repairTargetBase = section === `beams` ? 8 : 6;
    const crewRollPenalty = parseInt(attrs[`crewrollpenalty`]) || 0;
    const repairTarget = Math.max(0, repairTargetBase + crewRollPenalty);

    const repairRoll = getRandomIntInclusive(1, 10);
    if (repairRoll <= repairTarget) {
        // If state is 1, change it to 2 and set weapon_state_status to 2
        if (currentState == 1) {
            const updateObj = {};
            updateObj[`${row}_state`] = 2;
            updateObj[`${row}_weapon_state_status`] = 2;

            if (section == 'beams') updateObj[`${row}_power`] = Math.min(beamPower, Math.floor(beamPowerMax / 2));

            await setAttrsAsync(updateObj);

            await updateWeaponsPercent();
        }
    }

    startRoll(
        `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Repair Roll}} {{color=gold}} {{Weapon=${wpnName}}} {{To-Repair=[[${repairTarget}]]}} {{Roll=[[${repairRoll}]]}}`,
        roll => finishRoll(roll.rollId)
    );
});

// REPAIR and RESET after combat
on(`clicked:repair`, async function(eventInfo) {

    const response = await extractChatData(`?{Confirm Repair and TPA Reset|Confirm|Cancel}`);

    if (response === `Confirm`) {
        // Repair engines
        getSectionIDs(`repeating_engines`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_engines_${id}_engine_power`] = values[`repeating_engines_${id}_engine_power_full`];
                });
                setAttrs(output);
            });
        });

        // Repair beam weapons
        getSectionIDs(`repeating_beams`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_beams_${id}_state`);
                Fieldnames.push(`repeating_beams_${id}_weapon_state_status`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_beams_${id}_state`] = 0;
                    output[`repeating_beams_${id}_weapon_state_status`] = 0;
                });
                setAttrs(output);
            });
        });

        // Repair missile weapons
        getSectionIDs(`repeating_missiles`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_missiles_${id}_state`);
                Fieldnames.push(`repeating_missiles_${id}_weapon_state_status`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_missiles_${id}_state`] = 0;
                    output[`repeating_missiles_${id}_weapon_state_status`] = 0;
                });
                setAttrs(output);
            });
        });

        // Other vars
        getAttrs([`hp_max`, `crew_max`], function(values) {
            const hpMax = parseInt(values[`hp_max`]) || 0;
            const crewMax = parseInt(values[`crew_max`]) || 0;

            const output = {};
            output[`hp`] = hpMax;
            output[`crew`] = crewMax;
            output[`wf_current`] = 0;
            output[`wf_desired`] = 0;
            output[`shield_1_state`] = output[`shield_1_status`] = output[`shield_1_to_repair`] = 0;
            output[`shield_2_state`] = output[`shield_2_status`] = output[`shield_2_to_repair`] = 0;
            output[`shield_3_state`] = output[`shield_3_status`] = output[`shield_3_to_repair`] = 0;
            output[`shield_4_state`] = output[`shield_4_status`] = output[`shield_4_to_repair`] = 0;
            output[`shield_5_state`] = output[`shield_5_status`] = output[`shield_5_to_repair`] = 0;
            output[`shield_6_state`] = output[`shield_6_status`] = output[`shield_6_to_repair`] = 0;
            output[`sensors_state`] = output[`sensors_status`] = output[`sensors_to_repair`] = output[`sensors_destroyed`] = 0;
            output[`shields_grid_state`] = output[`shields_grid_status`] = output[`shields_grid_to_repair`] = output[`shields_grid_destroyed`] = 0;
            output[`weapons_grid_state`] = output[`weapons_grid_status`] = output[`weapons_grid_to_repair`] = output[`weapons_grid_destroyed`] = 0;
            output[`movement_grid_state`] = output[`movement_grid_status`] = output[`movement_grid_to_repair`] = output[`movement_grid_destroyed`] = 0;
            setAttrs(output);
        });

        await updateWeaponsPercent();
        undoSensorLock();
        resetTPA();
    }
});

// SENSOR SCAN
on(`clicked:scan`, async (event) => {
    const output = {};

    const { tokenName, charId } = await extractTargetData(); // Destructure JSON
    const scanRoll = getRandomIntInclusive(1, 10);

    startRoll(
        `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Scan}} {{color=green}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{To-Scan=[[6]]}} {{Roll=[[${scanRoll}]]}}`,
        roll => finishRoll(roll.rollId)
    );

    if (scanRoll < 7) {
        output[`sensorlock`] = tokenName;
        output[`sensorlockid`] = charId;
    } else {
        undoSensorLock();
    }

    await setAttrsAsync(output);
}); 
function undoSensorLock() {
    const output = {};
    output[`sensorlock`] = output[`sensorlockid`] = ``;
    output[`scanquestion`] = output[`scananswer`] = ``;
    setAttrs(output);
}

// SENSOR SCAN Q&A
on(`change:scanquestion`, function(eventInfo) {
    if (eventInfo.sourceType == "player") {
        getAttrs([`sensorlock`, `sensorlockid`, `scanquestion`], function(values) {
            const sensorLock = values[`sensorlock`];
            const sensorLockId = values[`sensorlockid`];
            const questionIndex = parseInt(values[`scanquestion`]) || 0;

            const questions = [
                ``,
                `How much power is available?`,
                `What is the relative power allocation?`,
                `How are the shields powered?`,
                `Is a specific shield up?`,
                `How are the beam weapons powered?`,
                `How are the missile weapons powered?`,
                `Is a specific weapon powered?`,
                `How much damage has the vessel taken?`,
                `What is the status of the ships crew?`,
                `Are any transporters powered?`
                ];

            startRoll(`/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Query}} {{color=green}} {{Target=[${sensorLock}](${ROLL20_CHAR_URL}${sensorLockId})}} {{Query=${questions[questionIndex]}}}`, roll => {
                finishRoll(roll.rollId);
            });
        });
    }
}); 

// SHIELD POINTS calculation
on(`change:tpa_shields change:spr_1 change:spr_2 change:shield_1 change:shield_2 change:shield_3 change:shield_4 change:shield_5 change:shield_6 change:crewbonus3`, function(eventInfo) {
    getAttrs([`tpa_shields`, `spr_1`, `spr_2`, `shield_1`, `shield_2`, `shield_3`, `shield_4`, `shield_5`, `shield_6`, `crewbonus`], function(values) {
        const power = parseInt(values[`tpa_shields`]) || 0;
        const spr = (parseInt(values[`spr_1`]) || 1) / (parseInt(values[`spr_2`]) || 1);
        const shield1 = parseInt(values[`shield_1`]) || 0;
        const shield2 = parseInt(values[`shield_2`]) || 0;
        const shield3 = parseInt(values[`shield_3`]) || 0;
        const shield4 = parseInt(values[`shield_4`]) || 0;
        const shield5 = parseInt(values[`shield_5`]) || 0;
        const shield6 = parseInt(values[`shield_6`]) || 0;
        const crewBonus = parseInt(values[`crewbonus`]) || 0;

        const totalPower = power + (crewBonus == CREW_BONUS_SHIELD ? 1 : 0);
        const sp = Math.floor(totalPower / spr - shield1 - shield2 - shield3 - shield4 - shield5 - shield6);
        const powerRemaining = Math.round(totalPower - shield1 * spr - shield2 * spr - shield3 * spr - shield4 * spr - shield5 * spr - shield6 * spr);

        const output = {};
        output[`sp`] = sp;
        output[`sp_remaining`] = powerRemaining;
        output[`sp_remaining_status`] = (power != 0 || powerRemaining != 0) && (powerRemaining < 0 ? 1 : (powerRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// SHIELD POINTS ALLOCATED status indicators
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num} change:shield_${num}_state change:shield_max`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}_state`, `shield_max`], function(values) {
            const shieldSP = parseInt(values[`shield_${num}`]) || 0;
            const shieldIsDamaged = parseInt(values[`shield_${num}_state`]) || 0;
            const shieldSPMax = parseInt(values[`shield_max`]) || 0;

            const output = {};
            output[`shield_${num}a_status`] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
            output[`shield_${num}c`] = shieldIsDamaged ? 0 : shieldSP;
            setAttrs(output);
        });
    });
});

// SHIELD POINTS CURRENT status indicators
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num}c`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}c`], function(values) {
            const shieldSPAllocated = parseInt(values[`shield_${num}`]) || 0;
            const shieldSPCurrent = parseInt(values[`shield_${num}c`]) || 0;

            const output = {};
            output[`shield_${num}c_status`] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
            setAttrs(output);
        });
    });
});

// SHIELDS RE-ENERGIZED
on(`clicked:shield_reenergize`, function(eventInfo) {
    energizeShields();
});
on(`change:current_phase`, function(eventInfo) {
    energizeShields();
});
function energizeShields() {
    getAttrs([`shield_1`, `shield_2`, `shield_3`, `shield_4`, `shield_5`, `shield_6`, `shield_1_state`, `shield_2_state`, `shield_3_state`, `shield_4_state`, `shield_5_state`, `shield_6_state`], function(values) {
        const shield1Allocation = parseInt(values[`shield_1`]) || 0;
        const shield2Allocation = parseInt(values[`shield_2`]) || 0;
        const shield3Allocation = parseInt(values[`shield_3`]) || 0;
        const shield4Allocation = parseInt(values[`shield_4`]) || 0;
        const shield5Allocation = parseInt(values[`shield_5`]) || 0;
        const shield6Allocation = parseInt(values[`shield_6`]) || 0;
        const shield1IsDamaged = parseInt(values[`shield_1_state`]) || 0;
        const shield2IsDamaged = parseInt(values[`shield_2_state`]) || 0;
        const shield3IsDamaged = parseInt(values[`shield_3_state`]) || 0;
        const shield4IsDamaged = parseInt(values[`shield_4_state`]) || 0;
        const shield5IsDamaged = parseInt(values[`shield_5_state`]) || 0;
        const shield6IsDamaged = parseInt(values[`shield_6_state`]) || 0;

        const output = {};
        output[`shield_1c`] = shield1IsDamaged ? 0 : shield1Allocation;
        output[`shield_2c`] = shield2IsDamaged ? 0 : shield2Allocation;
        output[`shield_3c`] = shield3IsDamaged ? 0 : shield3Allocation;
        output[`shield_4c`] = shield4IsDamaged ? 0 : shield4Allocation;
        output[`shield_5c`] = shield5IsDamaged ? 0 : shield5Allocation;
        output[`shield_6c`] = shield6IsDamaged ? 0 : shield6Allocation;
        setAttrs(output);
    });
};

// SHIELD STATE changed
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num}_state`, function(eventInfo) {
        getAttrs([`shield_1_state`, `shield_2_state`, `shield_3_state`, `shield_4_state`, `shield_5_state`, `shield_6_state`], function(values) {

            const activeShields = Object.values(values).filter(state => state == 0).length;
            
            const output = {};
            output[`shields-percent`] = Math.max(0, Math.round(activeShields / 6 * MAX_PERCENTAGE));
            setAttrs(output);
        });
    });
});

// STRESS TURN
on(`clicked:stress_turn`, async (event) => {
    const response = await extractChatData(`?{Confirm Stress Turn|Confirm|Cancel}`);

    if (response === `Confirm`) {
        const engines = await getSectionIDsAsync(`repeating_engines`);

        const Fieldnames = [];
        engines.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
        });

        const output = {};
        const values = await getAttrsAsync([...Fieldnames, `hp`]);
        engines.forEach(id => {
            const engineType = parseInt(values[`repeating_engines_${id}_engine_type`]) || 0;
            if (engineType == ENGINE_TYPE_WARP) {
                const currentPower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                output[`repeating_engines_${id}_engine_power`] = Math.max(0, currentPower - 1);
            }
        });

        const currentSup = parseInt(values['hp']) || 0;
        output[`hp`] = Math.max(0, currentSup - 1);

        await setAttrsAsync(output);

        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Makes a Stress Turn!}} {{color=orange}}`, roll => {
            finishRoll(roll.rollId);
        });
    }   
});

// SUPERSTRUCTURE MASS and SIZE calculations
on(`change:mass`, function(eventInfo) {
    getAttrs([`mass`], function(values) {
        const shipsMass = parseInt(values[`mass`]) || 0;
        const shipsFormattedMass = formatNumber(String(shipsMass));

        const theSizes = [0,`I`,5000,`II`,15000,`III`,25000,`IV`,40000,`V`,60000,`VI`,80000,`VII`,100000,`VIII`,120000,`IX`,140000,`X`,160000,`XI`,180000,`XII`,210000,`XIII`,240000,`XIV`,300000,`XV`,350000,`XVI`,400000,`XVII`,450000,`XVIII`,500000,`XIX`,600000,`XX`,700000];
        let i = 0;
        do {
            i += 2;
        } while (shipsMass > theSizes[i]);      

        const output = {};
        output[`size`] = `${shipsFormattedMass} mt (${theSizes[i-1]})`;
        setAttrs(output);
    });
});

// SUPERSTRUCTURE status
on(`change:hp change:hp_max`, function(eventInfo) {
    getAttrs([`hp`, `hp_max`], function(values) {
        const hp = parseInt(values[`hp`]) || 0;  
        const hpMax = parseInt(values[`hp_max`]) || 0;  

        const output = {};
        output[`sup-percent`] = Math.max(0, Math.round(hp / hpMax * MAX_PERCENTAGE));
        if (hp < 1) output[`tpa_movement`] = 0; // disable movement
        output[`hp_status`] = hp < (hpMax / 2) || hp > hpMax ? 1 : hp < hpMax ? 2 : 0;
        output[`ship-is-disabled`] = hp < 1 ? 1 : 0;
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE calculation
on(`change:repeating_engines:engine_power change:repeating_engines:engine_power_full remove:repeating_engines change:crewbonus2`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });

        getAttrs([...Fieldnames, `crewbonus`], function (values) {
            const ENGINE_NO_POWER = 0;
            const crewBonus = parseInt(values[`crewbonus`] || 0);

            let tpa = 0;
            let tpaMax = 0;
            const output = {};
            ids.forEach(id => {
                const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                const enginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                
                tpa += enginePower + (enginePower > ENGINE_NO_POWER && crewBonus == CREW_BONUS_ENGINES ? 1 : 0);
                tpaMax += enginePowerMax

                output[`repeating_engines_${id}_engine_power_status`] = ((enginePower > enginePowerMax) || (enginePower == 0)) ? 1 : enginePower < enginePowerMax ? 2 : 0;
            });
            output[`tpa`] = tpa;
            output[`tpa_max`] = tpaMax;
            output[`tpa-percent`] = Math.max(0, Math.round(tpa / tpaMax * MAX_PERCENTAGE));
            setAttrs(output);
        });
    });
});

// TOTAL POWER AVAILABLE remaining calculation
on(`change:tpa change:tpa_movement change:tpa_warp change:tpa_weapons change:tpa_shields`, function(eventInfo) {
    getAttrs([`tpa`, `tpa_movement`, `tpa_warp`, `tpa_weapons`, `tpa_shields`], function(values) {
        const tpa = parseInt(values[`tpa`]) || 0;
        const tpaToMovement = parseInt(values[`tpa_movement`]) || 0;
        const tpaToWarp = parseInt(values[`tpa_warp`]) || 0;
        const tpaToWeapons = parseInt(values[`tpa_weapons`]) || 0;
        const tpaToShields = parseInt(values[`tpa_shields`]) || 0;

        const tpaRemaining = tpa - tpaToMovement - tpaToWarp - tpaToWeapons - tpaToShields;

        const output = {};
        output[`tpa_remaining`] = tpaRemaining;
        output[`tpa_remaining_status`] = (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE COMMITTED
on(`clicked:shield_commit`, async (event) => {

    const response = await extractChatData(`?{Confirm TPA Commit|Confirm|Cancel}`);

    if (response === `Confirm`) {

        startRoll(
            `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=READY!}} {{color=purple}}`,
            roll => finishRoll(roll.rollId)
        );
    
        const output = {};
        output[`tpa_committed_status`] = 0;
        setAttrs(output);
    }
});

// TOTAL POWER AVAILABLE reset
on(`clicked:tpa_reset`, async (event) => {

    const response = await extractChatData(`?{Confirm TPA Reset|Confirm|Cancel}`);

    if (response === `Confirm`) {
        resetTPA();
    }
});
on(`change:tpa_reset`, function(eventInfo) {
    resetTPA();
});
function resetTPA() {
    getSectionIDs(`repeating_beams`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_beams_${id}_power`] = 0;
                output[`repeating_beams_${id}_target_name`] = ``;
                output[`repeating_beams_${id}_target_distance`] = 0;
                output[`repeating_beams_${id}_target_tohit`] = 0;
                output[`repeating_beams_${id}_btn-target_status`] = 0;
                output[`repeating_beams_${id}_btn-fire_status`] = 0;
            });
            output[`wp_beam`] = 0;
            setAttrs(output);
        });
    });

    getSectionIDs(`repeating_missiles`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_missiles_${id}_armed`] = 0;
                output[`repeating_missiles_${id}_target_name`] = ``;
                output[`repeating_missiles_${id}_target_distance`] = 0;
                output[`repeating_missiles_${id}_target_tohit`] = 0;
                output[`repeating_missiles_${id}_btn-target_status`] = 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = 0;
            });
            output[`wp_missile`] = 0;
            setAttrs(output);
        });
    });

    const output = {};

    output[`shield_1`] = output[`shield_2`] = output[`shield_3`] = output[`shield_4`] = output[`shield_5`] = output[`shield_6`] = 0
    output[`tpa_committed_status`] = 1;
    output[`tpa_movement`] = 0;
    output[`tpa_weapons`] = 0;
    output[`tpa_shields`] = 0;

    output[`crewbonus`] = 0;
    output[`crewbonus_saved`] = 0;
    output[`crewbonus_engineid`] = ``;
    output[`crewbonustohitapplied`] = 0;
    output[`crewbonus1`] = output[`crewbonus2`] = output[`crewbonus3`] = 0;

    const SCAN_NONE = 0;
    output[`scanquestion`] = SCAN_NONE;
    output[`scananswer`] = ``;

    setAttrs(output);
}

// TYPE = STATION = no warp speed
on(`change:type`, function(eventInfo) {
    getAttrs([`type`], function(values) {
        const type = values[`type`];

        const output = {};
        const TYPE_STATION = `Station`;
        output[`warp_show_content`] = type == TYPE_STATION ? 0 : 1;
        setAttrs(output);
    });
});

// WARP FACTOR changed by player
on(`change:wf_current change:wf_desired`, function(eventInfo) {
    getAttrs([`wf_current`, `wf_desired`, `wf_cruise`, `wf_emergency`, `wfr_cruise`, `wfr_jump`], function(values) {
        const wfCurrent = parseInt(values[`wf_current`]) || 0;
        const wfDesired = parseInt(values[`wf_desired`]) || 0;
        const wfCruise = parseInt(values[`wf_cruise`]) || 0;
        const wfEmergency = parseInt(values[`wf_emergency`]) || 0;
        const wfrCruise = parseInt(values[`wfr_cruise`]) || 0;
        const wfrJump = parseInt(values[`wfr_jump`]) || 0;

        const wfrCurrent = wfDesired > wfCurrent ? wfrJump : wfrCruise;
        const tpaRequired = wfDesired > wfCurrent ? wfDesired * wfrCurrent : wfrCruise * Math.min(wfCurrent, wfDesired);

        const output = {};
        output[`wfr_1`] = wfrCurrent;
        output[`tpa_warp`] = tpaRequired;
        output[`wf_current_status`] = wfCurrent > wfEmergency ? 1 : wfCurrent > wfCruise ? 2 : 0;
        output[`wf_desired_status`] = wfDesired > wfEmergency ? 1 : wfDesired != wfCurrent || wfDesired > wfCruise ? 2 : 0;
        output[`warp_factor_status`] = wfDesired != wfCurrent ? 1 : 0;
        setAttrs(output);
    });
});

// WARP FACTOR RATIO calculations
// Note: This should not occur after initial ship setup
//  but event is triggered whenever engine power changes
on(`change:repeating_engines:engine_power_full remove:repeating_engines change:wf_emergency`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames, `wf_emergency`], function (values) {
            const wfEmergency = parseInt(values[`wf_emergency`]) || 0;

            let totalWarpEngines = 0;
            let totalWarpPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP) {
                    const theEnginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                    totalWarpEngines += 1;
                    totalWarpPower += theEnginePowerMax;
                }
            });

            output[`wf_current`] = output[`wf_desired`] = 0; // Clear settings
            output[`wfr_jump`] = output[`wfr_1`] = Math.floor(totalWarpPower / wfEmergency);
            output[`wfr_cruise`] = totalWarpEngines;
            setAttrs(output);
        });
    });
});

// WARP JUMP
on(`clicked:jump`, async (event) => {
    const response = await extractChatData(`?{Confirm Speed Change|Confirm|Cancel}`);

    if (response === `Confirm`) {
        const values = await getAttrsAsync([`wf_current`, `wf_desired`, `faction`]);
        
        const wfCurrent = parseInt(values[`wf_current`]) || 0;
        const wfDesired = parseInt(values[`wf_desired`]) || 0;
        const faction = values[`faction`];

        if (wfCurrent != wfDesired) {
            startRoll(`&{template:custom} {{title=@{banner_${faction}warp} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Warp Factor Change}} {{color=blue}} {{From=Warp Factor **@{wf_current}**}} {{To=Warp Factor **@{wf_desired}**}}`, roll => {
                finishRoll(roll.rollId);
            });

            await setAttrsAsync({'wf_current': wfDesired});
        }
    }   
});

// WEAPON POINTS calculation
on(`change:tpa_weapons change:wp_beam change:wp_missile`, function(eventInfo) {
    getAttrs([`tpa_weapons`, `wp_beam`, `wp_missile`], function(values) {
        const tpa = parseInt(values[`tpa_weapons`]) || 0;
        const tpaToBeams = parseInt(values[`wp_beam`]) || 0;
        const tpaToMissiles = parseInt(values[`wp_missile`]) || 0;

        const tpaRemaining = tpa - tpaToBeams - tpaToMissiles;

        const output = {};
        output[`wp_remaining`] = tpaRemaining;
        output[`wp_remaining_status`] = (tpa != 0 || tpaRemaining != 0) && (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// WEAPON TARGETING
on(`clicked:repeating_beams:btn-target clicked:repeating_missiles:btn-target`, async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_chart`, `${row}_maxrange`, `${row}_power`, 
        `crewbonus`, `crewbonustohitapplied`, `crewrollpenalty`
    ]);

    const wpnName = attributes[`${row}_name`];
    const wpnChart = attributes[`${row}_chart`];
    const wpnMaxRange = parseInt(attributes[`${row}_maxrange`]) || 0;
    const wpnIsPowered = parseInt(attributes[`${row}_power`]) || 0;
    const crewBonus = parseInt(attributes[`crewbonus`]) || 0;
    const crewBonusApplied = parseInt(attributes[`crewbonustohitapplied`]) || 0;
    const crewCasualtyPenalty = parseInt(attributes[`crewrollpenalty`]) || 0;

    const output = {};

    // Clear only the triggered row
    output[`${row}_target_name`] = ``;
    output[`${row}_target_id`] = ``;
    output[`${row}_target_distance`] = ``;
    output[`${row}_target_tohit`] = ``;
    output[`${row}_btn-fire_status`] = 0;

    await setAttrsAsync(output);

    // Get target input
    const { tokenName, charId } = await extractTargetData(); // Destructure JSON
    const wpnTargetDistance = +(await extractChatData(`?{How far|1}`)) || 0;
    const wpnCrewBonus = crewBonus == CREW_BONUS_WEAPONS && !crewBonusApplied ? +(await extractChatData(`?{Apply crew bonus|Yes,1|No,0}`)) || 0 : 0;
    const wpnTargetToHit = getToHit(wpnChart, wpnTargetDistance) + wpnCrewBonus + crewCasualtyPenalty;
    const wpnTargetToHitStr = `${wpnTargetToHit * 10}%`;

    // Get all matching banked weapons
    const bankedRows = [];
    const nameRoot = wpnName.match(/#\d+/);
    if (nameRoot) {
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        bankedRows.push(rowID); // Not banked — just target self
    }

    // Calculate cumulative weapon state penalty for the entire bank
    let weaponStatePenalty = 0;
    for (const id of bankedRows) {
        const targetRow = `repeating_${section}_${id}`;
        const statusAttrs = await getAttrsAsync([`${targetRow}_weapon_state_status`]);
        const weaponStateStatus = parseInt(statusAttrs[`${targetRow}_weapon_state_status`]) || 0;
        
        if (weaponStateStatus === 2) {
            weaponStatePenalty -= 1;
        }
    }

    const weaponNames = [];

    for (const id of bankedRows) {
        const targetRow = `repeating_${section}_${id}`;
        const rowAttrs = await getAttrsAsync([
            `${targetRow}_power`,
            `${targetRow}_name`
        ]);
        
        const power = parseInt(rowAttrs[`${targetRow}_power`]) || 0;

        // Skip if not powered
        if (power === 0) continue;

        // Apply cumulative weapon state penalty to all weapons in bank
        const adjustedToHit = wpnTargetToHit + weaponStatePenalty;

        weaponNames.push(rowAttrs[`${targetRow}_name`] || `Unknown Weapon`);
        output[`${targetRow}_target_name`] = tokenName;
        output[`${targetRow}_target_id`] = charId;
        output[`${targetRow}_target_distance`] = wpnTargetDistance;
        output[`${targetRow}_target_tohit`] = adjustedToHit;
        output[`${targetRow}_btn-fire_status`] = adjustedToHit ? 1 : 0;
    }   

    // Roll result
    if (!wpnTargetToHit) {
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Target Out of Range}} {{Weapon=${wpnName}}} {{Max Range=${wpnMaxRange} hexes}} {{Target=${tokenName}}} {{Distance=${wpnTargetDistance} hexes}}`, roll => finishRoll(roll.rollId));
    } else {
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Weapons Targeted}} {{color=green}} {{Weapons=${weaponNames.join(`\\n`)}}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{Distance=${wpnTargetDistance} hexes}} {{Firing Chart=${wpnChart}}} {{Chance To-Hit=${wpnTargetToHitStr}}}`, roll => finishRoll(roll.rollId));
    }

    output[`crewbonustohitapplied`] = Math.max(wpnCrewBonus, crewBonusApplied);

    await setAttrsAsync(output);
}); 

function getToHit (chart, distance) {
    // ST:STCS firing chart data
    const ranges = [
        `A`, 8, 6, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `B`, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `C`, 10, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `D`, 10, 9, 7, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `E`, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `F`, 10, 9, 7, 6, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `G`, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `H`, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `I`, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `J`, 10, 10, 9, 9, 8, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `K`, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `L`, 10, 10, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `M`, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `N`, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `O`, 10, 10, 9, 9, 8, 8, 7, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `P`, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0,
        `Q`, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `R`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        `S`, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        `T`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0,
        `U`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0,
        `V`, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0,
        `W`, 10, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0,
        `X`, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0,
        `Y`, 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1
    ];

    const index = ranges.indexOf(chart);
    const MAX_WPN_DISTANCE = 24;
    const toHit = ranges[index + Math.min(distance, MAX_WPN_DISTANCE)];

    return isNaN(toHit) ? 0 : toHit;
}

// WEAPON FIRING
on(`clicked:repeating_beams:btn-fire clicked:repeating_missiles:btn-fire`, async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_armed`, `${row}_power`, `${row}_power_max`,
        `${row}_bonus_3`, `${row}_bonus_2`, `${row}_bonus_1`,
        `${row}_target_name`, `${row}_target_id`, 
        `${row}_target_distance`, `${row}_target_tohit`, `faction`
    ]);

    const faction = attributes[`faction`];
    const wpnName = attributes[`${row}_name`];
    const wpnBankName = wpnName.match(/#\d+\w+/);
    const targetName = attributes[`${row}_target_name`];
    const targetId = attributes[`${row}_target_id`];
    const targetDistance = parseInt(attributes[`${row}_target_distance`]) || 0;
    const targetToHit = parseInt(attributes[`${row}_target_tohit`]) || 0;

    // Get all matching banked weapons or default to single weapon
    const bankedRows = [];
    if (wpnBankName) {
        const nameRoot = wpnName.match(/#\d+/);
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        // Not in a bank — fire just this weapon
        bankedRows.push(rowID);
    }

    const damageList = [];
    const weaponNames = [];

    for (const id of bankedRows) {
        const rowAttrs = await getAttrsAsync([
            `repeating_${section}_${id}_name`,
            `repeating_${section}_${id}_power`, `repeating_${section}_${id}_power_max`,
            `repeating_${section}_${id}_bonus_3`, `repeating_${section}_${id}_bonus_2`, `repeating_${section}_${id}_bonus_1`,
            `repeating_${section}_${id}_armed`,
            `repeating_${section}_${id}_target_name`, `repeating_${section}_${id}_target_tohit`
        ]);

        const wpnName = rowAttrs[`repeating_${section}_${id}_name`];
        const power = parseInt(rowAttrs[`repeating_${section}_${id}_power`]) || 0;
        const powerMax = parseInt(rowAttrs[`repeating_${section}_${id}_power_max`]) || 0;
        const bonus3 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_3`]) || 0;
        const bonus2 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_2`]) || 0;
        const bonus1 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_1`]) || 0;
        const armed = parseInt(rowAttrs[`repeating_${section}_${id}_armed`]) || 0;
        const targetName = rowAttrs[`repeating_${section}_${id}_target_name`];
        const targetToHit = parseInt(rowAttrs[`repeating_${section}_${id}_target_tohit`]) || 0;

        // Skip if not targeted
        if (!targetName || !targetToHit) continue;

        const isOCLaser = armed ? 0 : (power > powerMax ? 1 : 0);
        const powerDischarge = isOCLaser ? Math.floor(power / 2) : power;
        const totalDamage = powerDischarge + (
            targetDistance <= bonus3 ? 3 :
            targetDistance <= bonus2 ? 2 :
            targetDistance <= bonus1 ? 1 : 0
        );

        weaponNames.push(wpnName);
        damageList.push(totalDamage);

        // Reset weapon state
        const output = {};
        if (!armed) output[`repeating_${section}_${id}_power`] = isOCLaser ? powerDischarge : 0;
        output[`repeating_${section}_${id}_armed`] = 0;
        output[`repeating_${section}_${id}_btn-target_status`] = isOCLaser ? 1 : 0;
        output[`repeating_${section}_${id}_btn-fire_status`] = 0;
        output[`repeating_${section}_${id}_target_name`] = ``;
        output[`repeating_${section}_${id}_target_distance`] = 0;
        output[`repeating_${section}_${id}_target_tohit`] = 0;
        await setAttrsAsync(output);
    }   

        // Single roll with all weapons and damages
        startRoll(
            `&{template:custom} {{title=@{banner_${faction}fire${section}} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Weapons Fired}} {{color=red}} {{Weapons=${weaponNames.join(`\\n`)}}} {{Target=[${targetName}](${ROLL20_CHAR_URL}${targetId})}} {{To-Hit=[[${targetToHit}]] or less}} {{Roll=[[1d10cs>11cf<0]]}} {{Damage=${damageList.join(`, `)}}}`,
            roll => finishRoll(roll.rollId)
        );
    });

// WEAPON POWER (BEAM) ALLOCATION calculations
on(`change:repeating_beams:name change:repeating_beams:power change:repeating_beams:weapon_state_status remove:repeating_beams`, function(eventInfo) {
    getSectionIDs(`repeating_beams`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
            Fieldnames.push(`repeating_beams_${id}_weapon_state_status`);
            Fieldnames.push(`repeating_beams_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_beams_${id}_power`);
            Fieldnames.push(`repeating_beams_${id}_power_max`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToBeams = 0;
            const output = {};
            ids.forEach(id => {
                const theBeamIsLaser = values[`repeating_beams_${id}_name`].includes(`FL-`);
                const theBeamStateStatus = parseInt(values[`repeating_beams_${id}_weapon_state_status`]) || 0;
                const theBeamIsDamaged = theBeamStateStatus == 1 || theBeamStateStatus == 3 ? 1 : 0;
                const theBeamIsRepaired = theBeamStateStatus == 2 ? 1 : 0;
                const theBeamIsReady = parseInt(values[`repeating_beams_${id}_btn-fire_status`]) || 0;
                const theBeamPower = parseInt(values[`repeating_beams_${id}_power`]) || 0;
                const theBeamPowerMax = Math.floor((parseInt(values[`repeating_beams_${id}_power_max`]) || 0) / (theBeamIsRepaired + 1));
                totalPowerToBeams += theBeamPower;

                output[`repeating_beams_${id}_power_status`] = theBeamIsDamaged && !theBeamIsReady == 1 ? 1 : (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) < 0 ? 1 : (theBeamPower > 0 ? 2 : 0);
                output[`repeating_beams_${id}_btn-target_status`] = theBeamPower && !theBeamIsDamaged && (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) > -1 ? 1 : 0;
                output[`repeating_beams_${id}_btn-fire_status`] = theBeamIsReady;
            });
            output[`wp_beam`] = totalPowerToBeams;
            setAttrs(output);
        });
    });
});

// WEAPON POWER (MISSILE) ALLOCATION calculations
on(`change:repeating_missiles:damaged change:repeating_missiles:armed change:repeating_missiles:cost remove:repeating_missiles`, function(eventInfo) {
    getSectionIDs(`repeating_missiles`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_damaged`);
            Fieldnames.push(`repeating_missiles_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_missiles_${id}_armed`);
            Fieldnames.push(`repeating_missiles_${id}_cost`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToMissiles = 0;
            const output = {};
            ids.forEach(id => {
                const theMissileIsDamaged = parseInt(values[`repeating_missiles_${id}_damaged`]) || 0;
                const theMissileIsReady = parseInt(values[`repeating_missiles_${id}_btn-fire_status`]) || 0;
                const theMissilePower = (parseInt(values[`repeating_missiles_${id}_armed`]) || 0) * (parseInt(values[`repeating_missiles_${id}_cost`]) || 0);
                totalPowerToMissiles += theMissileIsDamaged && !theMissileIsReady ? 0 : theMissilePower;

                output[`repeating_missiles_${id}_armed_status`] = theMissileIsDamaged == 1 ? 1 : 0;
                output[`repeating_missiles_${id}_btn-target_status`] = theMissilePower && !theMissileIsDamaged ? 1 : 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = theMissileIsReady;
            });
            output[`wp_missile`] = totalPowerToMissiles;
            setAttrs(output);
        });
    });
});

// WEAPONS DAMAGED PERCENT calculation
async function updateWeaponsPercent() {
    let countWeapons = 0;
    let countWeaponsDamaged = 0;

    const fieldNames = [];
    let ids = await getSectionIDsAsync(`repeating_beams`);
    ids.forEach(id => {
        fieldNames.push(`repeating_beams_${id}_weapon_state_status`);
    });
    ids = await getSectionIDsAsync(`repeating_missiles`);
    ids.forEach(id => {
        fieldNames.push(`repeating_missiles_${id}_weapon_state_status`);
    });

    const values = await getAttrsAsync(fieldNames);
    Object.values(values).forEach(value => {
        countWeapons++;
        if (value != 0) countWeaponsDamaged++;
    });

    const output = {};
    output[`weapons-percent`] = Math.max(0, Math.round((countWeapons - countWeaponsDamaged) / countWeapons * MAX_PERCENTAGE));
    setAttrs(output);
}

/****************************/
function isRunningOnServer() { return self.dispatchEvent == undefined; }
function setActiveCharacterId(charId){
    var oldAcid=getActiveCharacterId();
    var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
    
    if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
        var ev = new CustomEvent("message");
        ev.data=msg; 
        self.dispatchEvent(ev);
    }else{ //otherwise, use the API (server) message processor, "onmessage"
        self.onmessage({data:msg});
    }
    return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
} 
var _sIn=setInterval;
setInterval=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sIn(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
var _sto=setTimeout
setTimeout=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sto(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
function getAttrsAsync(props){
    var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
    var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
            try{
                getAttrs(props,(values)=>{  resolve(values); }); 
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
    });
}
//use the same pattern for each of the following...
function setAttrsAsync(propObj, options){
    var acid=getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  
            try{
                setAttrs(propObj,options,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

function getSectionIDsAsync(sectionName){
    var acid = getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid = setActiveCharacterId(acid);  
            try{
                getSectionIDs(sectionName,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

</script>

<rolltemplate class="sheet-rolltemplate-custom">
    <div class="sheet-container sheet-color-{{color}}">
      <div class="sheet-header">
        {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
        {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
      </div>

      <div class="sheet-content">
        {{#allprops() title subtitle color Damage}}
        <div class="sheet-key">{{key}}</div>
        <div class="sheet-value">{{value}}</div>
        {{/allprops() title subtitle color Damage}}

        {{#^rollGreater() Roll Efficiency}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll Efficiency}}

        {{#rollGreater() Roll Efficiency}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll Efficiency}}

        {{#^rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Hit!</span></div>
        {{#Damage}}
            <div class="sheet-key">Damage</div>
            <div class="sheet-value">{{Damage}}</div>
        {{/Damage}}
        {{/^rollGreater() Roll To-Hit}}

        {{#rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Miss!</span></div>
        {{/rollGreater() Roll To-Hit}}

        {{#^rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll To-Repair}}

        {{#rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Repair}}

        {{#^rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Scanned!</span></div>
        {{/^rollGreater() Roll To-Scan}}

        {{#rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Scan}}

        {{#rollTotal() Remaining 0}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">No Damage!</span></div>
        {{/rollTotal() Remaining 0}}

        {{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
      </div>
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-menu">
    <div class="sheet-container sheet-color-{{color}}">
         <div class="sheet-header">
            {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
            {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
        </div>
         <div class="sheet-content">
            {{#allprops() title subtitle desc color}}
                <div class="sheet-key">{{key}}</div>
                <div class="sheet-value">{{value}}</div>
            {{/allprops() title subtitle desc color}}
            {{#desc}}
                <div class="sheet-desc">{{desc}}</div>
            {{/desc}}
        </div>
    </div>
</rolltemplate>