<div>
    <input type='hidden' class='movement-grid-status' name='attr_movement_grid_status' value='0'/>
    <input type='hidden' class='sensors-status' name='attr_sensors_status' value='0'/>
    <input type='hidden' class='shields-grid-status' name='attr_shields_grid_status' value='0'/>
    <input type='hidden' class='ship-is-disabled' name='attr_ship-is-disabled' value='0'/>
    <input type='hidden' class='tpa-committed-status' name='attr_shields_allocated_status' value='0'/>
    <input type='hidden' class='weapons-grid-status' name='attr_weapons_grid_status' value='0'/>
    <h1>
        <span name='attr_character_name'></span>
        <span class='disable-ship' title='disabled'> &#x1F198;</span>
        <span class='warning-sensors' style='cursor: default;' title='sensors offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-movement' style='cursor: default;' title='helm offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-shields' style='cursor: default;' title='shields offline'> &#x26A0;&#xFE0F;</span>
        <span class='warning-weapons' style='cursor: default;' title='weapons offline'> &#x26A0;&#xFE0F;</span>
    </h1> 
    <input type='hidden' name='attr_current_phase' value='0'/>
    <input type='hidden' name='attr_tpa_reset' value='0'/>
    <input type='hidden' name='attr_roll20charurl'/>
    <!--------------------------------------------------------> 
    <div class='grid-6col overview-panel'>
        <span class='span2'>
            <span name='attr_class'></span>
            <span name='attr_type'></span>
        </span>
        <span class='span2'>
            <label>Size:</label>
            <span name='attr_size'></span>
        </span>
        <span class='span2'>
            <label>D / WDF / CE:</label>
            <input type='number' class='w6' name='attr_defense' min='0' step='.1' value='0'/> /
            <input type='number' class='w6' name='attr_wdf' min='0' step='.1' value='0'/> /
            <span name='attr_ce'>0</span>
        </span>

        <label>Captain:</label>
        <input type='text' class='w12' name='attr_capname' placeholder='name...'/>
        <label>Command Rating:</label>
        <input type='hidden' name='attr_caprating_ta'/>
        <input type='number' name='attr_caprating' min='0'/>   
        <label>Crew Rating:</label>
        <input type='number' name='attr_crewrating' min='0'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Damage Control</h2>

    <div class='grid-6col dc-panel'>
        <button type='action' class='btn critical' name='act_rolldamage'>Roll Damage</button>
        <span></span>
        <label><strong>Superstructure:</strong></label>
        <span>
            <input type='hidden' class='hp-status' name='attr_hp_status' value='0'/>
            <input type='number' class='hp' name='attr_hp' value='0'/>
            /
            <span name='attr_hp_max'></span>
        </span>
        <label>Damage Charts:</label>
        <span name='attr_dmg_chart'></span>

        <button type='roll' class='btn' name='roll_rollcrew' value='&{template:custom} {{title=**[@{character_name}](@{roll20charurl}@{character_id})**}} {{subtitle=Crew Efficiency Roll}} {{color=gold}} {{Efficiency=[[@{crewefficiency}]]}} {{Roll=[[d100cf<0cs>101]]}}'>Crew Check</button>
        <span></span>
        <label><strong>Crew:</strong></label>
        <span >
            <input type='hidden' class='crew-status' name='attr_crew_status' value='0'/>
            <input type='number' class='w5 crew' name='attr_crew' value='0' min='0'/> /
            <span name='attr_crew_max'></span>
        </span>
        <label>Efficiency:</label>
        <span>
            <input type='number' name='attr_crewefficiency' readonly/> / 
            <input type='number' name='attr_crewrollpenalty' readonly/>
        </span>

        <select class='crew-bonus' name='attr_crewbonus'>
            <option value='0' selected>None</option>
            <option value='1'>Bonus To-Hit</option>
            <option value='2'>Bonus TPA</option>
            <option value='3'>Bonus SPA</option>
            <option value='4'>Repair</option>
        </select>
        <span></span>
        <span>
            <label>Sup: </label>
            <span name='attr_sup-percent'>100%</span>
        </span>
        <span>
            <label>Crew: </label>
            <span name='attr_crew-percent'>100%</span>
        </span>
        <span>
            <label>Shields: </label>
            <span name='attr_shields-percent'>100%</span>
        </span>
        <span>
            <label>Wpns: </label>
            <span name='attr_weapons-percent'>100%</span>
        </span>
    </div>
    <br/>
    <div class='grid-6col shield-status-panel'>
        <h4 class='span-grid'>Shield Generators Status</h4>

        <label>Shield #1 (<strong>f/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-1-status' name='attr_shield_1_status' value='0'/>
            <input type='hidden' name='attr_shield_1_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_1_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_1_repair'>Repair</button>
        </span>
        <label>Shield #2 (<strong>fwd</strong>):</label>
        <span>
            <input type='hidden' class='shield-2-status' name='attr_shield_2_status' value='0'/>
            <input type='hidden' name='attr_shield_2_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_2_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_2_repair'>Repair</button>
        </span>
        <label>Shield #3 (<strong>f/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-3-status' name='attr_shield_3_status' value='0'/>
            <input type='hidden' name='attr_shield_3_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_3_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_3_repair'>Repair</button>
        </span>

        <label>Shield #6 (<strong>a/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-6-status' name='attr_shield_6_status' value='0'/>
            <input type='hidden' name='attr_shield_6_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_6_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_6_repair'>Repair</button>
        </span>
        <label>Shield #5 (<strong>aft</strong>):</label>
        <span>
            <input type='hidden' class='shield-5-status' name='attr_shield_5_status' value='0'/>
            <input type='hidden' name='attr_shield_5_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_5_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_5_repair'>Repair</button>
        </span>
        <label>Shield #4 (<strong>a/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-4-status' name='attr_shield_4_status' value='0'/>
            <input type='hidden' name='attr_shield_4_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_4_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair' name='act_shield_4_repair'>Repair</button>
        </span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Engineering
        <input type='hidden' class='crewbonus2' name='attr_crewbonus2' value='0'/>
        <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
    </h2>

    <div class='grid-6col tpa-panel'>
        <button type='action' class='btn' name='act_tpa_reset'>Reset TPA</button>
        <span></span>
        <label><strong>Current TPA:</strong></label> 
        <span><strong><span name='attr_tpa'></span> / <span name='attr_tpa_max'></span></strong></span>
        <label>TPA Unallocated:</label>
        <input type='hidden' class='tpa-remaining-status' name='attr_tpa_remaining_status'/>
        <input type='number' class='tpa-remaining' name='attr_tpa_remaining'  value='0' readonly/>

        <button type='action' class='btn warning' name='act_shield_commit'>Commit TPA</button>
        <span></span>
        <label>TPA to Movement:</label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA to Warp:</label>
        <input type='number' name='attr_tpa_warp' min='0' value='0' readonly/>

        <button type='action' class='btn energize' name='act_shield_reenergize'>Re-energize</button>
        <span></span>
        <label>TPA to Shields:</label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA to Weapons:</label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
    </div>
    <br/>
    
    <div class='grid-6col engines-panel'>    
        <h4 class='span-grid'>Engines</h4>
        <div class='span-grid'>
            <label style='padding-left: 32px;'>Model</label>
            <label style='padding-left: 42px;'>Type</label>
            <label style='padding-left: 70px;'>Location</label>
            <label style='padding-left: 46px;'>Power</label>
            <label style='padding-left: 22px;'>Max</label>
        </div>
        <fieldset class='repeating_engines'>
            <input type='text' class='w10' name='attr_engine_model' placeholder='model...'/>
            <select class='w10' name='attr_engine_type'>
                <option value='0' selected>select...</option>
                <option value='1'>Impulse</option>
                <option value='2'>Warp</option>
                <option value='3'>Generator</option>
            </select>
            <select class='w10' name='attr_engine_location'>
                <option value='0' selected>select...</option>
                <option value='1'>Centerline</option>
                <option value='2'>Port</option>
                <option value='3'>Starboard</option>
            </select>
            <input type='hidden' class='engine-power-status' name='attr_engine_power_status' value='0'/>
            <input type='number' class='engine-power' name='attr_engine_power' min='0' value='0'/> / <input type='number' name='attr_engine_power_full' min='0' value='0'/>
        </fieldset>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='sensors-header header-container'>
        <h2>Sensors</h2>
        <span>
            <input type='hidden' name='attr_sensors_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_sensors_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-sensors-repair' name='act_sensors_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' class='sensors-destroyed' name='attr_sensors_destroyed' value='0'/>
    <div class='grid-6col sensors-panel'>
        <button type='action' class='btn btn-scan' name='act_scan'>Scan Target</button>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        
        <span class='span2'>
            <input type='text' class='scan-lock' name='attr_sensorlock' placeholder='No target lock...' readonly/>
        </span>
        <input type='hidden' class='w12' name='attr_sensorlockid'/>
        <span class='span2'>
            <select class='scan-question' name='attr_scanquestion'>
                <option value='0'>Submit a query...</option>
                <option value='1'>How much power is available?</option>
                <option value='2'>What is the relative power allocation?</option>
                <option value='3'>How are the shields powered?</option>
                <!--<option value='4'>Is a specific shield up?</option>-->
                <option value='5'>How are the beam weapons powered?</option>
                <option value='6'>How are the missile weapons powered?</option>
                <!--<option value='7'>Is a specific weapon powered?</option>-->
                <option value='8'>How much damage has the vessel taken?</option>
                <!--<option value='9'>What is the status of the ship's crew?</option>-->
                <!--<option value='10'>Are any transporters powered?</option>-->
            </select>
        </span>
        <span class='span2'><input type='text' class='scan-answer' name='attr_scananswer' placeholder='Paste the result here...'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='helm-header header-container'>
        <h2>Helm Control</h2>
        <span>
            <input type='hidden' name='attr_movement_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_movement_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-movement-grid-repair' name='act_movement_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col helm-panel'>
        <span></span>
        <span></span>
        <label><strong>TPA to Movement:</strong></label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA Remaining:</label> 
        <input type='hidden' class='mp-remaining-status' name='attr_mp_remaining_status'/>
        <input type='number' class='mp-remaining' name='attr_mp_remaining' value='0' readonly/>

        <label>Movement Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_mpr_1' min='1' max='12' value='1'/>
            /
            <input type='number' class='w5' name='attr_mpr_2' min='1' max='2' value='1'/>
        </span>
        <label>Movement Points:</label>
        <span>
            <input type='number' name='attr_mp' readonly/>
            <input type='hidden' class='impulse-power-status' name='attr_impulse_power_status' value='0'/>
            <span class='no-impulse-power' title='no impulse power = max 1'>&#x1F534;</span>
        </span>
        <label>MP by Phase:</label> 
        <input type='hidden' name='attr_ta'/>
        <span>
            <span name='attr_mp1'></span> | <span name='attr_mp2'></span> | <span name='attr_mp3'></span>
        </span>
    </div>
    <br/>

    <div class='grid-6col warp-panel'>
        <input type='hidden' class='warp-show-content' name='attr_warp_show_content' value='1'/>
        <div class='warp-content'>
            <h4>Warp Drive</h4>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>

            <input type='hidden' class='warp-factor-status' name='attr_warp_factor_status' value='0'/>
            <button type='action' class='btn btn-jump' name='act_jump'>Engage Warp Drive</button>
            <span></span>
            <label><strong>TPA to Warp:</strong></label>
            <input type='number' class='em' name='attr_tpa_warp' min='0' value='0' readonly/>
            <span></span>
            <span></span>

            
            <label>Warp Factor Ratio:</label>
            <input type='hidden' name='attr_wfr_jump'/>
            <input type='hidden' name='attr_wfr_cruise'/>
            <span>
                <input type='number' class='w5' name='attr_wfr_1' value='0' readonly/>
                /
                <input type='number' class='w5' name='attr_wfr_2' value='1' readonly/>
            </span>
            <label>Current Warp Factor:</label>
            <input type='hidden' class='wf-current-status' name='attr_wf_current_status'/>
            <input type='number' class='wf-current' min='0' value='0' name='attr_wf_current' readonly/>
            <label>Desired Warp Factor:</label>
            <input type='hidden' class='wf-desired-status' name='attr_wf_desired_status'/>
            <input type='number' class='em' min='0' value='0' name='attr_wf_desired'/>

            <label>Safe Cruise WF:</label>
            <input type='number' class='w5' name='attr_wf_cruise' min='0' value='0'/>
            <label>Emergency WF:</label>
            <input type='number' class='w5' name='attr_wf_emergency' min='0' value='0'/>
            <label>Stress Charts:</label>
            <span>
                <input type='text' class='w5' name='attr_stress_cruise' maxlength='1'/>
                /
                <input type='text' class='w5' name='attr_stress_emergency' maxlength='1'/> 
            </span>
        </div>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='shields-header header-container'>
        <h2>Shield Control
            <input type='hidden' class='crewbonus3' name='attr_crewbonus3' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_shields_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shields_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shields-grid-repair' name='act_shields_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col shields-panel'>
        <label>Shield Type:</label>
        <input type='text' class='w10' name='attr_shield_type'/>
        <label><strong>TPA to Shields:</strong></label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='sp-remaining-status' name='attr_sp_remaining_status'/>
        <input type='number' class='sp-remaining' name='attr_sp_remaining' value='0' readonly/>

        <label>Shield Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_spr_1' min='1' max='2' value='1'/>
            /        
            <input type='number' class='w5' name='attr_spr_2' min='1' max='6' value='1'/>
        </span>
        <label>Max Shield Power:</label>
        <input type='number' name='attr_shield_max' min='0' max='16' value='0'/>
        <label>SPA Remaining:</label>
        <input type='number' name='attr_sp' readonly/>
    </div>
    <br/>
    <div class='grid-6col spa-panel'>
        <h4 class='span-grid'>Shield Configuration</h4>

        <div class='shields-allocated'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1a-status' name='attr_shield_1a_status'/>
                <input type='number' class='shield-1' name='attr_shield_1' min='0' value='0' title='Shield #1 (f/p)'/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2a-status' name='attr_shield_2a_status'/>
                <input type='number' class='shield-2' name='attr_shield_2' min='0' value='0' title='Shield #2 (fwd)'/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3a-status' name='attr_shield_3a_status'/>
                <input type='number' class='shield-3' name='attr_shield_3' min='0' value='0' title='Shield #3 (f/s)'/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6a-status' name='attr_shield_6a_status'/>
                <input type='number' class='shield-6' name='attr_shield_6' min='0' value='0' title='Shield #6 (a/p)'/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                
                <input type='hidden' class='shield-5a-status' name='attr_shield_5a_status'/>
                <input type='number' class='shield-5' name='attr_shield_5' min='0' value='0' title='Shield #5 (aft)'/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4a-status' name='attr_shield_4a_status'/>
                <input type='number' class='shield-4' name='attr_shield_4' min='0' value='0' title='Shield #4 (a/s)'/>
            </span>
        </div>

        <div class='shields-current'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1c-status' name='attr_shield_1c_status'/>
                <input type='number' class='shield-1c' name='attr_shield_1c' readonly/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2c-status' name='attr_shield_2c_status'/>
                <input type='number' class='shield-2c' name='attr_shield_2c' readonly/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3c-status' name='attr_shield_3c_status'/>
                <input type='number' class='shield-3c' name='attr_shield_3c' readonly/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6c-status' name='attr_shield_6c_status'/>
                <input type='number' class='shield-6c' name='attr_shield_6c' readonly/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                <input type='hidden' class='shield-5c-status' name='attr_shield_5c_status'/>
                <input type='number' class='shield-5c' name='attr_shield_5c' readonly/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4c-status' name='attr_shield_4c_status'/>
                <input type='number' class='shield-4c' name='attr_shield_4c' readonly/>
            </span>
        </div>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='fc-header header-container'>
        <h2>Fire Control
            <input type='hidden' class='crewbonus1' name='attr_crewbonus1' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_weapons_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_weapons_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-weapons-grid-repair' name='act_weapons_grid_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' name='attr_crewbonustohitapplied' value='0'/>
    <div class='grid-6col fc-panel'>
        <span></span>
        <span></span>
        <label><strong>TPA to Weapons:</strong></label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='wp-remaining-status' name='attr_wp_remaining_status'/>
        <input type='number' class='wp-remaining' name='attr_wp_remaining' value='0' readonly/>
    </div>
    <br/>

    
    <div class='grid-6col beams-panel'>
        <h4 class='span-grid'>Beam Weapons</h4>
        <input type='hidden' name='attr_wp_beam'/>
        <div class='span-grid'>
            <label style='padding-left: 3px;'>X</label>
            <label style='padding-left: 8px;'>Desig. (Arcs)</label>
            <label style='padding-left: 26px;'>Range</label>
            <label style='padding-left: 15px;'>Chart</label>
            <label style='padding-left: 14px;'>Power</label>
            <label style='padding-left: 23px;'>Max</label>
            <label style='padding-left: 24px;'>+3</label>
            <label style='padding-left: 25px;'>+2</label>
            <label style='padding-left: 26px;'>+1</label>
            <label style='padding-left: 95px;'>Target</label>
            <label style='padding-left: 58px;'>Distance</label>
            <label style='padding-left: 5px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_beams'>
            <input type='checkbox' class='damaged' name='attr_damaged' value='1'/>
            <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w5' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='hidden' class='power-status' name='attr_power_status'/>
            <input type='number' class='power' name='attr_power' min='0' max='10' value='0'/> /
            <input type='number' name='attr_power_max' min='0' max='10' value='0'/>
            <input type='text' class='w3' name='attr_bonus_3' value='-'/>
            <input type='text' class='w3' name='attr_bonus_2' value='-'/>
            <input type='text' class='w3' name='attr_bonus_1' value='-'/> 
            <span>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='text' class='w3' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/> 
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
        </fieldset>
    </div>
    <br/>
        
    <div class='grid-6col missiles-panel'>
        <h4 class='span-grid'>Missile Weapons</h4>
        <input type='hidden' name='attr_wp_missile'/>
        <div class='span-grid'>
            <label style='padding-left: 3px;'>X</label>
            <label style='padding-left: 8px;'>Desig. (Arcs)</label>
            <label style='padding-left: 26px;'>Range</label>
            <label style='padding-left: 15px;'>Chart</label>
            <label style='padding-left: 18px;'>Power</label>
            <label style='padding-left: 4px;'>Damage</label>
            <label style='padding-left: 7px;'>Arm</label>
            <label style='padding-left: 175px;'>Target</label>
            <label style='padding-left: 58px;'>Distance</label>
            <label style='padding-left: 5px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_missiles'>
            <input type='checkbox' class='damaged' name='attr_damaged' value='1'/>
            <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w5' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='number' name='attr_cost' min='1' max='4' value='1'/>
            <input type='number' name='attr_power' min='1' max='20' value='1'/>
            <input type='hidden' class='missile-armed-status' name='attr_armed_status'/>
            <input type='checkbox' class='missile-armed' style='margin-left: 13px;' value='1' name='attr_armed'/>
            <span>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' style='margin-left: 95px;' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='text' class='w3' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/>
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
        </fieldset>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Construction Data</h2> 

    <div class='grid-6col construction-panel'>
        <span class='span2'>
            <select name='attr_faction'>
                <option selected>Select faction...</option>
                <option value='federation'>United Federation of Planets</option>
                <option value='klingon'>Klingon Empire</option>
            </select>
        </span>

        <span class='span2'>
            <input type='text' class='w20' name='attr_class' placeholder='Class...'/>
        </span>

        <label>Type:</label>
        <input type='text' class='w12' name='attr_type' placeholder='Type...'/>

        <label>Date Entering Service:</label>
        <input type='text' class='w7' name='attr_date' placeholder='Date...'/>

        <label>Number Constructed:</label>
        <input type='number' class='w7' name='attr_num' min='0'/>

        <label>Control Computer Type:</label>
        <input type='text' class='w7' name='attr_computer'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Hull Data</h2>
    <div class='grid-6col hull-panel'>
        <label>Superstructure:</label>
        <input type='number' class='w7' name='attr_hp_max' min='0' value='0'/>
        
        <label>Damage Chart:</label>
        <select class='w7' name='attr_dmg_chart'>
            <option value='0' selected>Select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
            <option>D</option>
        </select>

        <label>Mass (mt):</label>
        <input type='number' class='w7' name='attr_mass' min='0' max='999999' value='0'/>

        <label>Length (m):</label>
        <input type='number' class='w7' name='attr_length' min='0'/>

        <label>Width (m):</label>
        <input type='number' class='w7' name='attr_width' min='0'/>
        
        <label>Height (m):</label>
        <input type='number' class='w7' name='attr_height' min='0'/>
        
        <label>Cargo Units (SCU):</label>
        <input type='number' class='w7' name='attr_scu' min='0' value='0'/>

        <label>Cargo Capacity:</label>
        <span name='attr_scu_cap'></span>

        <label>Cargo Transporters:</label>
        <input type='number' class='w7' name='attr_scu_trans' min='0' value='0'></span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Crew Data</h2>
    <div class='grid-6col crew-panel'>
        <label>Crew:</label>
        <input type='number' class='w7' name='attr_crew_max' min='0' value='0'/>
        
        <label>Passengers/Troops:</label>
        <input type='number' class='w7' name='attr_troops_max' min='0' value='0'/>

        <label>Shuttlecraft:</label>
        <input type='number' class='w7' name='attr_shuttlecraft_max' min='0' value='0'/>

        <label>Transporters:</label>
        <input type='number' class='w7' name='attr_trans_standard' min='0' value='0'/>

        <label>Combat:</label>
        <input type='number' class='w7' name='attr_trans_combat' min='0' value='0'/>

        <label>Emergency:</label>
        <input type='number' class='w7' name='attr_trans_emergency' min='0' value='0'/>

    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Maintenance</h2>
    <div class='grid-6col maint-panel'>
        <p class='span-grid'><strong>Do not use these controls during battle!</strong></p>
        <button type='action' class='btn' name='act_repair'>Repair/Reset Vessel</button>
    </div>

<!-- Banner placeholders (see readme) -->
<input type='hidden' name='attr_banner_federationfirebeams' value='[x](https://files.d20.io/images/459374797/BrLK7l69a5n4Mfomy8M4GA/original.png)'/>
<input type='hidden' name='attr_banner_federationfiremissiles' value='[x](https://files.d20.io/images/461676845/PIWNmdJhQ8DotQAYJS7Eew/original.png)'/>
<input type='hidden' name='attr_banner_federationwarp' value='[x](https://files.d20.io/images/461519720/yapt5OaNN9fy0m-b2HhVaQ/original.png)'/>
<input type='hidden' name='attr_banner_klingonfirebeams' value='[x](https://files.d20.io/images/461674377/cX_DbSv-iBzHRa8XCK36uw/original.png)'/>
<input type='hidden' name='attr_banner_klingonfiremissiles' value='[x](https://files.d20.io/images/459155112/hNZ9AQX33_kJr7InoxYVbA/original.png)'/>
<input type='hidden' name='attr_banner_klingonwarp' value='[x](https://files.d20.io/images/461677914/LFn_ncPFcBHm_yHjz6xr9A/original.png)'/>

<script type='text/worker'>
const CREW_BONUS_WEAPONS = 1;
const CREW_BONUS_ENGINES = 2;
const CREW_BONUS_SHIELD = 3;
const CREW_BONUS_REPAIR = 4;
const DAMAGE_STATUSES = ['Online', 'Dmg 1-8', 'Dmg 1-6', 'Dmg 1-4', 'Dmg 1-2', 'DEST'];
const EMPTY_STRING = '';
const ENGINE_TYPE_IMPULSE = 1;
const ENGINE_TYPE_WARP = 2;
const ENGINE_TYPE_GENERATOR = 3;
const ENGINE_WARP_NAME_NONE = 'No Warp Drive';
const ROLL20_CHAR_URL = 'https://journal.roll20.net/character/';

// ON SHEET OPENED
on('sheet:opened',function(){
    getAttrs(['character_name'], function(values) {
        const charactername = values['character_name'];
        
        const output = {};

        const SEARCH_STR = "Copy of";
        if (charactername.includes(SEARCH_STR)) {
            output['caprating'] = 45 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
            output['crewrating'] = 25 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
        }

        output['roll20charurl'] = ROLL20_CHAR_URL;

        setAttrs(output);
    });
});

// Async function to return a querystring value
const extractChatData = async (query) => {
    query = await startRoll(`!{{target=[[0[response=${query}]]]}}`);
    finishRoll(query.rollId);
    return query.results.target.expression.replace(/0\[response=(.+?)\]/,'$1');
};

// Async function to return a token name and its character id 
const extractTargetData = async () => {
    const query = await startRoll(`!{{target=[[0+{"tokenName":"@{target|token_name}","charId":"@{target|character_id}"}]]}} /direct`);
    finishRoll(query.rollId);
    const expr = query.results.target.expression;
    const jsonStr = expr.replace(/0\+\{(.+)\}/, '{$1}');
    return JSON.parse(jsonStr);
};

// Roll a random number from MIN to MAX
function getRandomIntInclusive(min, max) {
  const minCeiled = Math.ceil(min);
  const maxFloored = Math.floor(max);
  return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);
}

// Format large numbers with commas
function formatNumber(value) {
    value = value.replace(/\D/g, '');
    return value.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// CAPTAIN RATING change
on('change:caprating', function(eventInfo) {
    getAttrs(['caprating'], function(values) {
        const caprating = parseInt(values['caprating']);

        const output = {};
        output['caprating_ta'] = caprating * 100;
        setAttrs(output);
    });
});

// CARGO CAPACITY calculation
on('change:scu', function(eventInfo) {
    getAttrs(['scu'], function(values) {
        const scu = parseInt(values['scu']) || 0;

        const scuCapacity = formatNumber(String(scu * 50));

        const output = {};
        output['scu_cap'] = `${scuCapacity} mt`;
        setAttrs(output);
    });
});

// COMBAT EFFICIENCY calculation
on('change:defense change:wdf', function(eventInfo) {
    getAttrs(['defense', 'wdf'], function(values) {
        const defense = parseFloat(values['defense']) || 0;
        const wpnDmgFactor = parseFloat(values['wdf']) || 0;

        const combatEfficiency = parseFloat((defense * wpnDmgFactor / 100).toFixed(2));

        const output = {};
        output['ce'] = combatEfficiency;
        setAttrs(output);
    });
});

// CREW BONUS selection
on('change:crewbonus', function(eventInfo) {
    getAttrs(['crewbonus'], function(values) {
        const crewBonus = parseInt(values['crewbonus']) || 0;

        const output = {};
        output['crewbonus1'] = output['crewbonus2'] = output['crewbonus3'] = output['crewbonus4'] = 0;
        output[`crewbonus${crewBonus}`] = 1;
        setAttrs(output);
    });
});

// CREW calculation
on('change:crew change:crew_max', function(eventInfo) {
    getAttrs(['crew', 'crew_max'], function(values) {
        const crew = parseInt(values['crew']) || 0;
        const crewMax = parseInt(values['crew_max']) || 0;

        const output = {};
        output['crew-percent'] = `${Math.max(0, Math.round(crew / crewMax * 100))}%`;
        output['crew_status'] = crew < (crewMax / 2) || crew > crewMax ? 1 : crew < crewMax ? 2 : 0;
        setAttrs(output);
    });
});

// CREW EFFICIENCY calculation
on('change:crewrating change:crew-percent', function(eventInfo) {
    getAttrs(['crewrating', 'crew-percent'], function(values) {
        const crewRating = parseInt(values['crewrating']) || 0;
        const crewPercent = values['crew-percent'] || '0%';
        const crewCasualties = 100 - Number(crewPercent.replace('%', EMPTY_STRING));

        const casualtyBrackets = [19, 39, 59, 69, 100];
        const rollPenalties = [0, -1, -2, -5, -10];
        const efficiencyModifiers = [0, 10, 20, 50, 50];

        let i = 0;
        while (crewCasualties > casualtyBrackets[i]) i++;

        const output = {};
        output['crewefficiency'] = Math.max(0, crewRating - efficiencyModifiers[i]);
        output['crewrollpenalty'] = rollPenalties[i];
        setAttrs(output);
    });
});

// DAMAGE roll
on('clicked:rolldamage', async () => {
    const shieldArcStr = await extractChatData('?{Shield Arc|#1 (f/p)|#2 (fwd)|#3 (f/s)|#4 (a/s)|#5 (aft)|#6 (a/p)}');
    const baseDamage = +await extractChatData('?{Damage|0}');
  
    const shieldArc = shieldArcStr.substring(1,2);
    const shieldVar = `shield_${shieldArc}c`;
    const values = await getAttrsAsync(['dmg_chart']);
    const damageChart = values['dmg_chart'] || DAMAGE_CHART_DEFAULT;

    const damageResults = [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

        15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        13, 1, 1, 2, 2, 2, 2, 5, 14, 12,
        13, 1, 7, 4, 2, 2, 1, 9, 14, 12,
        13, 1, 7, 7, 4, 1, 1, 2, 2, 9,
        13, 1, 1, 6, 3, 1, 1, 7, 4, 1,
        13, 1, 6, 6, 3, 1, 1, 2, 2, 8
    ];

    //13, 1, 6, 3, 2, 2, 1, 8, 14, 12,

    const DAMAGE_CHART_DEFAULT = 'C';
    const DAMAGE_RESULT_BRIDGE = 'Bridge 2C';
    const DAMAGE_RESULT_ENG = 'Engineering';
    const DAMAGE_RESULT_IMP = 'Impulse';
    const DAMAGE_RESULT_IMP_HALF = 'Impulse (x1/2)';
    const DAMAGE_RESULT_PORT = 'PWE';
    const DAMAGE_RESULT_PORT_HALF = 'PWE (x1/2)';
    const DAMAGE_RESULT_SENSORS = 'Sensors';
    const DAMAGE_RESULT_SHIELD = 'Shield Gen';
    const DAMAGE_RESULT_STBD = 'SWE';
    const DAMAGE_RESULT_STBD_HALF = 'SWE (x1/2)';
    const DAMAGE_RESULT_SUP = 'Sup 2C';
    const DAMAGE_RESULT_SUP_HALF = 'Sup C (x1/2)';
    const DAMAGE_RESULT_SUP_PORT = 'PWE/Sup C (x1/2)';
    const DAMAGE_RESULT_SUP_STBD = 'SWE/Sup C (x1/2)';
    const DAMAGE_RESULT_WARP = 'Any WE';

    const ENGINE_LOCATION_PORT = '2';
    const ENGINE_LOCATION_STBD = '3';

    let hitLocationStr = EMPTY_STRING;
    let residualDamage = 0;
    let penetratingDamage = 0;
    let returnStr = EMPTY_STRING;
    let rollStr = `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Damage Results}} {{color=red}} {{Incoming Dmg=${baseDamage}}} {{On Shield Arc=${shieldArcStr}}} `;
    let gridStr = EMPTY_STRING; // Used to track grid hits

    const hitRollResult = getRandomIntInclusive(0, 9);
    const hitLocation = ((damageChart.charCodeAt(0) - 65) * 60) + (hitRollResult * shieldArc);
    switch (damageResults[hitLocation]) {
        case 1:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SUP}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {           
                ({ residualDamage, returnStr } = await damageSup(penetratingDamage));
                rollStr += returnStr;
                ({ residualDamage, returnStr } = await damageCrew(penetratingDamage, 2));
                rollStr += returnStr;
            }
            break;
        case 2:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SUP_HALF}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {           
                ({ residualDamage, returnStr } = await damageSup(penetratingDamage));
                rollStr += returnStr;
                ({ residualDamage, returnStr } = await damageCrew(penetratingDamage));
                rollStr += returnStr;
            }
            break;
        case 3:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_PORT}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamage, ENGINE_LOCATION_PORT));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        ({ residualDamage, returnStr } = await damageSup(residualDamage));
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                    rollStr += returnStr;
                }
            }
            break;
        case 4:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_STBD}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamage, ENGINE_LOCATION_STBD));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        ({ residualDamage, returnStr } = await damageSup(residualDamage));
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                    rollStr += returnStr;
                }
            }
            break;
        case 5:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_WARP}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamage));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        ({ residualDamage, returnStr } = await damageSup(residualDamage));
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                    rollStr += returnStr;
                }
            }
            break;
        case 6:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_PORT_HALF}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamage, ENGINE_LOCATION_PORT));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        ({ residualDamage, returnStr } = await damageSup(residualDamage));
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                    rollStr += returnStr;
                }
            }
            break;
        case 7:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_STBD_HALF}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamage, ENGINE_LOCATION_STBD));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        ({ residualDamage, returnStr } = await damageSup(residualDamage));
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                    rollStr += returnStr;
                }
            }
            break;
        case 8:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SUP_PORT}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_PORT));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        penetratingDamageSup += residualDamage;
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                }
                rollStr += returnStr;           
                ({ residualDamage, returnStr } = await damageSup(penetratingDamageSup));
                rollStr += returnStr;
                ({ residualDamage, returnStr } = await damageCrew(penetratingDamageSup));
                rollStr += returnStr;
            }
            break;
        case 9:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SUP_STBD}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                ({ residualDamage, returnStr } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_STBD));
                rollStr += returnStr;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {           
                        penetratingDamageSup += residualDamage;
                    } else {
                        ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    }
                }
                rollStr += returnStr;           
                ({ residualDamage, returnStr } = await damageSup(penetratingDamageSup));
                rollStr += returnStr;
                ({ residualDamage, returnStr } = await damageCrew(penetratingDamageSup));
                rollStr += returnStr;
            }
            break;
        case 10:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_IMP}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageImpulse(penetratingDamage));
                rollStr += returnStr;
                if (residualDamage) {          
                    ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    rollStr += returnStr;
                }
            }
            break;
        case 11:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_IMP_HALF}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage, 0.5)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                ({ residualDamage, returnStr } = await damageImpulse(penetratingDamage));
                rollStr += returnStr;
                if (residualDamage) {          
                    ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    rollStr += returnStr;
                }
            }
            break;
        case 12:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_BRIDGE}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {           
                ({ residualDamage, returnStr } = await damageSup(1));
                rollStr += returnStr;
                ({ residualDamage, returnStr } = await damageCrew(penetratingDamage, 2, true));
                rollStr += returnStr;
            }
            break;
        case 13:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SHIELD}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {           
                ({ residualDamage, returnStr } = await damageSystem(`shield_${shieldArc}`, penetratingDamage));
                rollStr += returnStr;
                if (residualDamage) {
                    ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    rollStr += returnStr;
                }
            }
            break;
        case 14:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_SENSORS}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {  
                ({ residualDamage, returnStr } = await damageSystem(`sensors`, penetratingDamage));
                undoSensorLock();
                rollStr += returnStr;
                if (residualDamage) {
                    ({ residualDamage, returnStr } = await damageResidual(residualDamage));
                    rollStr += returnStr;
                }
            }
            break;
        case 15:
            rollStr += `{{Hit Location=${DAMAGE_RESULT_ENG}}} `;
            ({ penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage)); 
            rollStr += returnStr;
            if (penetratingDamage) {
                const gridNames = [`Shields`, `Weapons`, `Movement`];
                const damagedGrids = await selectRandomGrids();
                for (i = 0; i < damagedGrids.length; i++) {
                    gridStr += `${gridNames[damagedGrids[i]-1]}, `;
                }
                gridStr = gridStr.slice(0, -2);
                rollStr += ` {{Affected Grids=${gridStr}}}`;
                ({ residualDamage, returnStr } = await damageSup(1));
                rollStr += returnStr;
            }
            break;
    }

    await startRoll(
        `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Damage Results}} {{color=red}} {{Incoming Dmg=${baseDamage}}} {{On Shield Arc=${shieldArcStr}}} ${rollStr}`,
        roll => finishRoll(roll.rollId)
    );

    if (gridStr) damageGrids(gridStr); // Handle damage to individal grids
});

// DAMAGE CREW
async function damageCrew(myDmg, myFactor = 1, isBridge = false) {
    const values = await getAttrsAsync(['crew', 'crew_max', 'crewrating', 'hp_max']);
    const crew = parseInt(values['crew']) || 0;
    const crewMax = parseInt(values['crew_max']) || 0;
    const crewRating = parseInt(values['crewrating']) || 0;
    const maxSup = parseInt(values['hp_max']) || 0;

    const supIntervals = [0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 19, 34, 50, 999];
    const percentsLost = [0, 100, 50, 30, 25, 20, 18, 14, 10, 8, 6, 4, 2, 1];

    // Determine percentage bracket based on max sup
    let index = -1;
    do {
        index++;
    }
    while (maxSup > supIntervals[index])

    // Determine amount of crew lost
    const isCrewEffective = getRandomIntInclusive(1, 100) <= crewRating;
    const CREW_MAX_DMG = 5;
    const percentLost = Math.min((isBridge == true) ? 20 : 100, Math.floor(percentsLost[index] * Math.min(CREW_MAX_DMG, myDmg) * myFactor)) / (isCrewEffective ? 2 : 1);
    const crewLost = Math.ceil(crewMax * percentLost / 100);
    const newCrew = Math.max(0, crew - crewLost);

    const output = {};
    output['crew'] = newCrew;
    await setAttrsAsync(output);
    
    const CREW_EFFECTIVE_TRUE = 'Success!';
    const CREW_EFFECTIVE_FALSE = 'Failed';
    const residualDamage = 0;
    const returnStr = ` {{Crew Check=${isCrewEffective ? CREW_EFFECTIVE_TRUE : CREW_EFFECTIVE_FALSE}}} {{Crew Lost=[[${crewLost}]]}}`;
    return { residualDamage, returnStr };
}

// DAMAGE GRIDS
async function damageGrids(gridStr) {
    const affectedGrids = gridStr.split(`, `);
    for (i = 0; i < affectedGrids.length; i++) {
        const gridVarName = `${affectedGrids[i].toLowerCase()}_grid`;

        const output = {};
        if (affectedGrids[i] == 'Shields') output[`shield_1c`] = output[`shield_2c`] = output[`shield_3c`] = output[`shield_4c`] = output[`shield_5c`] = output[`shield_6c`] = 0;
        await setAttrsAsync(output);

        ({ residualDamage, returnStr } = await damageSystem(gridVarName, 0));
        await startRoll(
            `/w gm &{template:custom} {{subtitle=**${affectedGrids[i]}** Grid}} {{color=red}} ${returnStr}`,
            roll => finishRoll(roll.rollId)
        );
    }
}

// SELECT RANDOM GRIDS
async function selectRandomGrids() {
    const randomResult = getRandomIntInclusive(1, 10);
    
    let affectedGrids = [];
    if (randomResult <= 2) {
        affectedGrids = [1]; // shields-grid
    } else if (randomResult <= 4) {
        affectedGrids = [2]; // weapon-grid
    } else if (randomResult <= 6) {
        affectedGrids = [3]; // movement-grid
    } else if (randomResult === 7) {
        affectedGrids = [1, 2]; // shields-grid, weapon-grid
    } else if (randomResult === 8) {
        affectedGrids = [1, 3]; // shields-grid, movement-grid
    } else if (randomResult === 9) {
        affectedGrids = [2, 3]; // weapon-grid, movement-grid
    } else if (randomResult === 10) {
        affectedGrids = [1, 2, 3]; // all three grids
    }
    
    return affectedGrids;
}

// DAMAGE IMPULSE ENGINE
async function damageImpulse(myDmg = 0, myFactor = 1) {
    const ids = await getSectionIDsAsync('repeating_engines');
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let enginePower = -1;
    let targetId = null;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
            enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            targetId = id;
        }
    });

    let residualDamage = myDmg;

    const damage = Math.floor(myDmg * myFactor);
    const newEnginePower = Math.max(0, enginePower - damage);
    residualDamage = Math.max(0, damage - enginePower);
    
    output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
    await setAttrsAsync(output);
    const returnStr = ` {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;

    return { residualDamage, returnStr };
}

// DAMAGE SHIELD
async function damageShield(myShieldVar = EMPTY_STRING, myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync([myShieldVar]);
    const shieldPower = parseInt(values[myShieldVar]) || 0;

    const shieldPowerRemaining = Math.max(0, shieldPower - Math.floor(myDmg * myFactor));
    const myDmgAbsorbed = shieldPower - shieldPowerRemaining;
    const penetratingDamage = Math.max(0, Math.floor(myDmg * myFactor) - shieldPower);

    const output = {};
    output[myShieldVar] = shieldPowerRemaining;
    await setAttrsAsync(output);

    const returnStr = ` {{Shield Strength=${shieldPower}}} {{Absorbed=${myDmgAbsorbed}}} {{Penetrating Dmg=[[${penetratingDamage}]]}}`;
    return { penetratingDamage, returnStr };
}

// DAMAGE SYSTEM
async function damageSystem(mySystemVar = EMPTY_STRING, myDmg = 0) {
    const values = await getAttrsAsync([`${mySystemVar}_state`]);
    const systemState = parseInt(values[`${mySystemVar}_state`]) || 0;

    const systemStateNew = Math.min(5, systemState + 1);

    const output = {};
    output[`${mySystemVar}_state`] = systemStateNew;
    output[`${mySystemVar}_status`] = systemStateNew > 0 && systemStateNew < 5 ? 1 : 0;
    output[`${mySystemVar}_to_repair`] = 10 - (systemStateNew * 2);
    await setAttrsAsync(output);

    const residualDamage = systemStateNew == 5 ? myDmg : 2;
    const returnStr = ` {{Damage Status=${DAMAGE_STATUSES[systemStateNew]}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE
async function damageSup(myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync(['hp']);
    const oldSup = parseInt(values['hp']) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output['hp'] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure=${oldSup}}} {{Sup Damage=[[${supDamage}]]}} {{Sup Remaining=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE (RESIDUAL)
async function damageResidual(myDmg = 0, myFactor = 0.5) {
    const values = await getAttrsAsync(['hp']);
    const oldSup = parseInt(values['hp']) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output['hp'] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure (R)=${oldSup}}} {{Sup Damage (R)=[[${supDamage}]]}} {{Sup Remaining (R)=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE WARP ENGINE
async function damageWarp(myDmg = 0, myLocation = 1, myFactor = 1) {
    const ids = await getSectionIDsAsync('repeating_engines');

    const ENGINE_WARP_NAME_CNTR = 'CWE';
    const ENGINE_WARP_NAME_PORT = 'PWE';
    const ENGINE_WARP_NAME_STBD = 'SWE';

    const engineLocations = [
        ENGINE_WARP_NAME_NONE, 
        ENGINE_WARP_NAME_CNTR, 
        ENGINE_WARP_NAME_PORT, 
        ENGINE_WARP_NAME_STBD
        ];

    if (myLocation === 1) myLocation = getRandomIntInclusive(2, 3); // pick an engine
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let actualLocation = -1;
    let enginePower = -1;
    let targetId = null;
    let foundAtLocation = false;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP && !foundAtLocation) {
            actualLocation = parseInt(values[`repeating_engines_${id}_engine_location`]) || 0;
            if (actualLocation == myLocation) {
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                targetId = id;
                foundAtLocation = true;
            } else {
                targetId = id;
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            }
        }
    });

    let residualDamage = myDmg;
    let returnStr = ` {{Actual Location=${engineLocations[0]}}}`;

    if (enginePower > -1 && targetId) {
        const damage = Math.floor(myDmg * myFactor);
        const newEnginePower = Math.max(0, enginePower - damage);
        residualDamage = Math.max(0, damage - enginePower);
        
        output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
        await setAttrsAsync(output);
        returnStr = ` {{Actual Location=${engineLocations[actualLocation]}}} {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;
    }

    return { residualDamage, returnStr };
}

// IMPULSE POWER status indicator
on('change:repeating_engines:engine_power', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
                    const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                    totalPower += enginePower;
                }
            });
            output['impulse_power_status'] = totalPower == 0 ? 1 : 0;
            setAttrs(output);
        });
    });
});

// MOVEMENT POINTS AVAILABLE calculation
on('change:tpa_movement change:mpr_1 change:mpr_2', function(eventInfo) {
    getAttrs(['tpa_movement', 'mpr_1', 'mpr_2'], function(values) {
        const power = parseInt(values['tpa_movement']) || 0;
        const mpr = (parseInt(values['mpr_1']) || 1) / (parseInt(values['mpr_2']) || 1);

        const mp = Math.floor(power / mpr);
        const mpPhase1 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 1
        const mpPhase2 = Math.floor(mp / 3) + (mp % 3 == 1 ? 1 : 0); // phase 2
        const mpPhase3 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 3
        const powerUnused = power % mpr;

        const output = {};
        output['mp'] = mp;
        output['ta'] = mp * 10000;
        output['mp1'] = mpPhase1;
        output['mp2'] = mpPhase2;
        output['mp3'] = mpPhase3;
        output['mp_remaining'] = powerUnused;
        output['mp_remaining_status'] = power != 0 && (powerUnused < 0 ? 1 : (powerUnused > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// REPAIR SYSTEM
on(`clicked:movement_grid_repair`, function(eventInfo) { repairSystem(`movement_grid`, `Movement Grid`); });
on(`clicked:sensors_repair`, function(eventInfo) { repairSystem(`sensors`, `Sensors`); });
on(`clicked:shield_1_repair`, function(eventInfo) { repairSystem(`shield_1`, `Shield #1 (f/p)`); });
on(`clicked:shield_2_repair`, function(eventInfo) { repairSystem(`shield_2`, `Shield #2 (fwd)`); });
on(`clicked:shield_3_repair`, function(eventInfo) { repairSystem(`shield_3`, `Shield #3 (f/s)`); });
on(`clicked:shield_4_repair`, function(eventInfo) { repairSystem(`shield_4`, `Shield #4 (a/s)`); });
on(`clicked:shield_5_repair`, function(eventInfo) { repairSystem(`shield_5`, `Shield #5 (aft)`); });
on(`clicked:shield_6_repair`, function(eventInfo) { repairSystem(`shield_6`, `Shield #6 (a/p)`); });
on(`clicked:shields_grid_repair`, function(eventInfo) { repairSystem(`shields_grid`, `Shields Grid`); energizeShields()});
on(`clicked:weapons_grid_repair`, function(eventInfo) { repairSystem(`weapons_grid`, `Weapons Grid`); });
function repairSystem(mySystemVar = EMPTY_STRING, mySystemName = EMPTY_STRING) {
    getAttrs([`${mySystemVar}_to_repair`, 'crewrollpenalty'], function(values) {
        const repairTargetBase = parseInt(values[`${mySystemVar}_to_repair`]) || 0;
        const crewRollPenalty = parseInt(values['crewrollpenalty']) || 0;
        let repairTargetNew = repairTargetBase;
        const repairTarget = Math.max(0, repairTargetBase + crewRollPenalty);

        const output = {};
        const repairRoll = getRandomIntInclusive(1, 10);
        if (repairRoll <= repairTarget) {
            output[`${mySystemVar}_state`] = 0;
            output[`${mySystemVar}_status`] = 0;
            repairTargetNew = 0;
        } else {
            repairTargetNew = repairTargetBase + 1;
        }

        output[`${mySystemVar}_to_repair`] = repairTargetNew;
        setAttrs(output);

        startRoll(
            `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Repair Roll}} {{color=gold}} {{System=${mySystemName}}} {{To-Repair=[[${repairTarget}]]}} {{Roll=[[${repairRoll}]]}}`,
            roll => finishRoll(roll.rollId)
        );
    });
};

// REPAIR and RESET after combat
on('clicked:repair', async function(eventInfo) {

    const response = await extractChatData('?{Confirm Repair and TPA Reset|Confirm|Cancel}');

    if (response === 'Confirm') {
        // Repair engines
        getSectionIDs('repeating_engines', function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_engines_${id}_engine_power`] = values[`repeating_engines_${id}_engine_power_full`];
                });
                setAttrs(output);
            });
        });

        // Repair beam weapons
        getSectionIDs('repeating_beams', function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_beams_${id}_damaged`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_beams_${id}_damaged`] = 0;
                });
                setAttrs(output);
            });
        });

        // Repair missile weapons
        getSectionIDs('repeating_missiles', function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_missiles_${id}_damaged`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_missiles_${id}_damaged`] = 0;
                });
                setAttrs(output);
            });
        });

        // Other vars
        getAttrs([`hp_max`, `crew_max`], function(values) {
            const hpMax = parseInt(values[`hp_max`]) || 0;
            const crewMax = parseInt(values[`crew_max`]) || 0;

            const output = {};
            output[`hp`] = hpMax;
            output[`crew`] = crewMax;
            output[`wf_current`] = 0;
            output[`wf_desired`] = 0;
            output[`shield_1_state`] = output[`shield_1_status`] = output[`shield_1_to_repair`] = 0;
            output[`shield_2_state`] = output[`shield_2_status`] = output[`shield_2_to_repair`] = 0;
            output[`shield_3_state`] = output[`shield_3_status`] = output[`shield_3_to_repair`] = 0;
            output[`shield_4_state`] = output[`shield_4_status`] = output[`shield_4_to_repair`] = 0;
            output[`shield_5_state`] = output[`shield_5_status`] = output[`shield_5_to_repair`] = 0;
            output[`shield_6_state`] = output[`shield_6_status`] = output[`shield_6_to_repair`] = 0;
            output[`sensors_state`] = output[`sensors_status`] = output[`sensors_to_repair`] = output[`sensors_destroyed`] = 0;
            output[`shields_grid_state`] = output[`shields_grid_status`] = output[`shields_grid_to_repair`] = output[`shields_grid_destroyed`] = 0;
            output[`weapons_grid_state`] = output[`weapons_grid_status`] = output[`weapons_grid_to_repair`] = output[`weapons_grid_destroyed`] = 0;
            output[`movement_grid_state`] = output[`movement_grid_status`] = output[`movement_grid_to_repair`] = output[`movement_grid_destroyed`] = 0;
            setAttrs(output);
        });

        undoSensorLock();
        resetTPA();
    }
});

// SENSOR SCAN
on('clicked:scan', async (event) => {
    const output = {};

    const { tokenName, charId } = await extractTargetData(); // Destructure JSON
    const scanRoll = getRandomIntInclusive(1, 10);

    startRoll(
        `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Scan}} {{color=orange}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{To-Scan=[[6]]}} {{Roll=[[${scanRoll}]]}}`,
        roll => finishRoll(roll.rollId)
    );

    if (scanRoll < 7) {
        output['sensorlock'] = tokenName;
        output['sensorlockid'] = charId;
    } else {
        undoSensorLock();
    }

    await setAttrsAsync(output);
}); 
function undoSensorLock() {
    const output = {};
    output['sensorlock'] = output['sensorlockid'] = EMPTY_STRING;
    output['scanquestion'] = output['scananswer'] = EMPTY_STRING;
    setAttrs(output);
}

// SENSOR SCAN Q&A
on('change:scanquestion', function(eventInfo) {
    if (eventInfo.sourceType == "player") {
        getAttrs(['sensorlock', 'sensorlockid', 'scanquestion'], function(values) {
            const sensorLock = values['sensorlock'];
            const sensorLockId = values['sensorlockid'];
            const questionIndex = parseInt(values['scanquestion']) || 0;

            const questions = [
                '',
                'How much power is available?',
                'What is the relative power allocation?',
                'How are the shields powered?',
                'Is a specific shield up?',
                'How are the beam weapons powered?',
                'How are the missile weapons powered?',
                'Is a specific weapon powered?',
                'How much damage has the vessel taken?',
                'What is the status of the ships crew?',
                'Are any transporters powered?'
                ];

            startRoll(`/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Query}} {{color=orange}} {{Target=[${sensorLock}](${ROLL20_CHAR_URL}${sensorLockId})}} {{Query=${questions[questionIndex]}}}`, roll => {
                finishRoll(roll.rollId);
            });
        });
    }
}); 

// SHIELD POINTS calculation
on('change:tpa_shields change:spr_1 change:spr_2 change:shield_1 change:shield_2 change:shield_3 change:shield_4 change:shield_5 change:shield_6 change:crewbonus3', function(eventInfo) {
    getAttrs(['tpa_shields', 'spr_1', 'spr_2', 'shield_1', 'shield_2', 'shield_3', 'shield_4', 'shield_5', 'shield_6', 'crewbonus'], function(values) {
        const power = parseInt(values['tpa_shields']) || 0;
        const spr = (parseInt(values['spr_1']) || 1) / (parseInt(values['spr_2']) || 1);
        const shield1 = parseInt(values['shield_1']) || 0;
        const shield2 = parseInt(values['shield_2']) || 0;
        const shield3 = parseInt(values['shield_3']) || 0;
        const shield4 = parseInt(values['shield_4']) || 0;
        const shield5 = parseInt(values['shield_5']) || 0;
        const shield6 = parseInt(values['shield_6']) || 0;
        const crewBonus = parseInt(values['crewbonus']) || 0;

        const totalPower = power + (crewBonus == CREW_BONUS_SHIELD ? 1 : 0);
        const sp = Math.floor(totalPower / spr - shield1 - shield2 - shield3 - shield4 - shield5 - shield6);
        const powerRemaining = Math.round(totalPower - shield1 * spr - shield2 * spr - shield3 * spr - shield4 * spr - shield5 * spr - shield6 * spr);

        const output = {};
        output['sp'] = sp;
        output['sp_remaining'] = powerRemaining;
        output['sp_remaining_status'] = (power != 0 || powerRemaining != 0) && (powerRemaining < 0 ? 1 : (powerRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// SHIELD POINTS ALLOCATED status indicators
['1', '2', '3', '4', '5', '6'].forEach(num => {
    on(`change:shield_${num} change:shield_${num}_state change:shield_max`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}_state`, 'shield_max'], function(values) {
            const shieldSP = parseInt(values[`shield_${num}`]) || 0;
            const shieldIsDamaged = parseInt(values[`shield_${num}_state`]) || 0;
            const shieldSPMax = parseInt(values['shield_max']) || 0;

            const output = {};
            output[`shield_${num}a_status`] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
            output[`shield_${num}c`] = shieldIsDamaged ? 0 : shieldSP;
            setAttrs(output);
        });
    });
});

// SHIELD POINTS CURRENT status indicators
['1', '2', '3', '4', '5', '6'].forEach(num => {
    on(`change:shield_${num}c`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}c`], function(values) {
            const shieldSPAllocated = parseInt(values[`shield_${num}`]) || 0;
            const shieldSPCurrent = parseInt(values[`shield_${num}c`]) || 0;

            const output = {};
            output[`shield_${num}c_status`] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
            setAttrs(output);
        });
    });
});

// SHIELDS RE-ENERGIZED
on('clicked:shield_reenergize', function(eventInfo) {
    energizeShields();
});
on('change:current_phase', function(eventInfo) {
    energizeShields();
});
function energizeShields() {
    getAttrs(['shield_1', 'shield_2', 'shield_3', 'shield_4', 'shield_5', 'shield_6', 'shield_1_state', 'shield_2_state', 'shield_3_state', 'shield_4_state', 'shield_5_state', 'shield_6_state'], function(values) {
        const shield1Allocation = parseInt(values['shield_1']) || 0;
        const shield2Allocation = parseInt(values['shield_2']) || 0;
        const shield3Allocation = parseInt(values['shield_3']) || 0;
        const shield4Allocation = parseInt(values['shield_4']) || 0;
        const shield5Allocation = parseInt(values['shield_5']) || 0;
        const shield6Allocation = parseInt(values['shield_6']) || 0;
        const shield1IsDamaged = parseInt(values['shield_1_state']) || 0;
        const shield2IsDamaged = parseInt(values['shield_2_state']) || 0;
        const shield3IsDamaged = parseInt(values['shield_3_state']) || 0;
        const shield4IsDamaged = parseInt(values['shield_4_state']) || 0;
        const shield5IsDamaged = parseInt(values['shield_5_state']) || 0;
        const shield6IsDamaged = parseInt(values['shield_6_state']) || 0;

        const output = {};
        output['shield_1c'] = shield1IsDamaged ? 0 : shield1Allocation;
        output['shield_2c'] = shield2IsDamaged ? 0 : shield2Allocation;
        output['shield_3c'] = shield3IsDamaged ? 0 : shield3Allocation;
        output['shield_4c'] = shield4IsDamaged ? 0 : shield4Allocation;
        output['shield_5c'] = shield5IsDamaged ? 0 : shield5Allocation;
        output['shield_6c'] = shield6IsDamaged ? 0 : shield6Allocation;
        setAttrs(output);
    });
};

// SHIELD STATE changed
['1', '2', '3', '4', '5', '6'].forEach(num => {
    on(`change:shield_${num}_state`, function(eventInfo) {
        getAttrs(['shield_1_state', 'shield_2_state', 'shield_3_state', 'shield_4_state', 'shield_5_state', 'shield_6_state'], function(values) {

            const activeShields = Object.values(values).filter(state => state == 0).length;
            
            const percentage = Math.round((activeShields / 6) * 100);
            
            const output = {};
            output['shields-percent'] = `${percentage}%`;
            setAttrs(output);
        });
    });
});

// SUPERSTRUCTURE MASS and SIZE calculations
on('change:mass', function(eventInfo) {
    getAttrs(['mass'], function(values) {
        const shipsMass = parseInt(values['mass']) || 0;
        const shipsFormattedMass = formatNumber(String(shipsMass));

        const theSizes = [0,'I',5000,'II',15000,'III',25000,'IV',40000,'V',60000,'VI',80000,'VII',100000,'VIII',120000,'IX',140000,'X',160000,'XI',180000,'XII',210000,'XIII',240000,'XIV',300000,'XV',350000,'XVI',400000,'XVII',450000,'XVIII',500000,'XIX',600000,'XX',700000];
        let i = 0;
        do {
            i += 2;
        } while (shipsMass > theSizes[i]);      

        const output = {};
        output['size'] = `${shipsFormattedMass} mt (${theSizes[i-1]})`;
        setAttrs(output);
    });
});

// SUPERSTRUCTURE status
on('change:hp change:hp_max', function(eventInfo) {
    getAttrs(['hp', 'hp_max'], function(values) {
        const hp = parseInt(values['hp']) || 0;  
        const hpMax = parseInt(values['hp_max']) || 0;  

        const output = {};
        output['sup-percent'] = `${Math.max(0, Math.round(hp / hpMax * 100))}%`;
        if (hp < 1) output['tpa_movement'] = 0; // disable movement
        output['hp_status'] = hp < (hpMax / 2) || hp > hpMax ? 1 : hp < hpMax ? 2 : 0;
        output['ship-is-disabled'] = hp < 1 ? 1 : 0;
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE calculation
on('change:repeating_engines:engine_power change:repeating_engines:engine_power_full remove:repeating_engines change:crewbonus2', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });

        getAttrs([...Fieldnames, 'crewbonus'], function (values) {
            const ENGINE_NO_POWER = 0;
            const crewBonus = parseInt(values['crewbonus'] || 0);

            let tpa = 0;
            let tpaMax = 0;
            const output = {};
            ids.forEach(id => {
                const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                const enginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                
                tpa += enginePower + (enginePower > ENGINE_NO_POWER && crewBonus == CREW_BONUS_ENGINES ? 1 : 0);
                tpaMax += enginePowerMax

                output[`repeating_engines_${id}_engine_power_status`] = ((enginePower > enginePowerMax) || (enginePower == 0)) ? 1 : enginePower < enginePowerMax ? 2 : 0;
            });
            output['tpa'] = tpa;
            output['tpa_max'] = tpaMax;
            setAttrs(output);
        });
    });
});

// TOTAL POWER AVAILABLE remaining calculation
on('change:tpa change:tpa_movement change:tpa_warp change:tpa_weapons change:tpa_shields', function(eventInfo) {
    getAttrs(['tpa', 'tpa_movement', 'tpa_warp', 'tpa_weapons', 'tpa_shields'], function(values) {
        const tpa = parseInt(values['tpa']) || 0;
        const tpaToMovement = parseInt(values['tpa_movement']) || 0;
        const tpaToWarp = parseInt(values['tpa_warp']) || 0;
        const tpaToWeapons = parseInt(values['tpa_weapons']) || 0;
        const tpaToShields = parseInt(values['tpa_shields']) || 0;

        const tpaRemaining = tpa - tpaToMovement - tpaToWarp - tpaToWeapons - tpaToShields;

        const output = {};
        output['tpa_remaining'] = tpaRemaining;
        output['tpa_remaining_status'] = (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE COMMITTED
on('clicked:shield_commit', async (event) => {

    const response = await extractChatData('?{Confirm TPA Commit|Confirm|Cancel}');

    if (response === 'Confirm') {

        startRoll(
            `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=READY!}} {{color=purple}}`,
            roll => finishRoll(roll.rollId)
        );
    
        const output = {};
        output['shields_allocated_status'] = 0;
        setAttrs(output);
    }
});

// TOTAL POWER AVAILABLE reset
on('clicked:tpa_reset', async (event) => {

    const response = await extractChatData('?{Confirm TPA Reset|Confirm|Cancel}');

    if (response === 'Confirm') {
        resetTPA();
    }
});
on('change:tpa_reset', function(eventInfo) {
    resetTPA();
});
function resetTPA() {
    getSectionIDs('repeating_beams', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_beams_${id}_power`] = 0;
                output[`repeating_beams_${id}_target_name`] = '';
                output[`repeating_beams_${id}_target_distance`] = 0;
                output[`repeating_beams_${id}_target_tohit`] = 0;
                output[`repeating_beams_${id}_btn-target_status`] = 0;
                output[`repeating_beams_${id}_btn-fire_status`] = 0;
            });
            output['wp_beam'] = 0;
            setAttrs(output);
        });
    });

    getSectionIDs('repeating_missiles', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_missiles_${id}_armed`] = 0;
                output[`repeating_missiles_${id}_target_name`] = '';
                output[`repeating_missiles_${id}_target_distance`] = 0;
                output[`repeating_missiles_${id}_target_tohit`] = 0;
                output[`repeating_missiles_${id}_btn-target_status`] = 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = 0;
            });
            output['wp_missile'] = 0;
            setAttrs(output);
        });
    });

    const output = {};

    output['shield_1'] = output['shield_2'] = output['shield_3'] = output['shield_4'] = output['shield_5'] = output['shield_6'] = 0
    output['shields_allocated_status'] = 1;
    output['tpa_movement'] = 0;
    output['tpa_weapons'] = 0;
    output['tpa_shields'] = 0;

    output['crewbonus'] = 0;
    output['crewbonustohitapplied'] = 0;
    output['crewbonus1'] = output['crewbonus2'] = output['crewbonus3'] = output['crewbonus4'] = 0;

    const SCAN_NONE = 0;
    output['scanquestion'] = SCAN_NONE;
    output['scananswer'] = EMPTY_STRING;

    setAttrs(output);
}

// TYPE = STATION = no warp speed
on('change:type', function(eventInfo) {
    getAttrs(['type'], function(values) {
        const type = values['type'];

        const output = {};
        const TYPE_STATION = 'Station';
        output['warp_show_content'] = type == TYPE_STATION ? 0 : 1;
        setAttrs(output);
    });
});

// WARP FACTOR changed by player
on('change:wf_current change:wf_desired', function(eventInfo) {
    getAttrs(['wf_current', 'wf_desired', 'wf_cruise', 'wf_emergency', 'wfr_cruise', 'wfr_jump'], function(values) {
        const wfCurrent = parseInt(values['wf_current']) || 0;
        const wfDesired = parseInt(values['wf_desired']) || 0;
        const wfCruise = parseInt(values['wf_cruise']) || 0;
        const wfEmergency = parseInt(values['wf_emergency']) || 0;
        const wfrCruise = parseInt(values['wfr_cruise']) || 0;
        const wfrJump = parseInt(values['wfr_jump']) || 0;

        const wfrCurrent = wfDesired > wfCurrent ? wfrJump : wfrCruise;
        const tpaRequired = wfDesired > wfCurrent ? wfDesired * wfrCurrent : wfrCruise * Math.min(wfCurrent, wfDesired);

        const output = {};
        output['wfr_1'] = wfrCurrent;
        output['tpa_warp'] = tpaRequired;
        output['wf_current_status'] = wfCurrent > wfEmergency ? 1 : wfCurrent > wfCruise ? 2 : 0;
        output['wf_desired_status'] = wfDesired > wfEmergency ? 1 : wfDesired != wfCurrent || wfDesired > wfCruise ? 2 : 0;
        output['warp_factor_status'] = wfDesired != wfCurrent ? 1 : 0;
        setAttrs(output);
    });
});

// WARP FACTOR RATIO calculations
// Note: This should not occur after initial ship setup
//  but event is triggered whenever engine power changes
on('change:repeating_engines:engine_power_full remove:repeating_engines change:wf_emergency', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames, 'wf_emergency'], function (values) {
            const wfEmergency = parseInt(values['wf_emergency']) || 0;

            let totalWarpEngines = 0;
            let totalWarpPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP) {
                    const theEnginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                    totalWarpEngines += 1;
                    totalWarpPower += theEnginePowerMax;
                }
            });

            output['wf_current'] = output['wf_desired'] = 0; // Clear settings
            output['wfr_jump'] = output['wfr_1'] = Math.floor(totalWarpPower / wfEmergency);
            output['wfr_cruise'] = totalWarpEngines;
            setAttrs(output);
        });
    });
});

// WARP JUMP
on('clicked:jump', async (event) => {
    const response = await extractChatData('?{Confirm Speed Change|Confirm|Cancel}');

    if (response === 'Confirm') {
        const values = await getAttrsAsync(['wf_current', 'wf_desired', 'faction']);
        
        const wfCurrent = parseInt(values['wf_current']) || 0;
        const wfDesired = parseInt(values['wf_desired']) || 0;
        const faction = values['faction'];

        if (wfCurrent != wfDesired) {
            startRoll(`&{template:custom} {{title=@{banner_${faction}warp} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Warp Factor Change}} {{color=blue}} {{From=Warp Factor **@{wf_current}**}} {{To=Warp Factor **@{wf_desired}**}}`, roll => {
                finishRoll(roll.rollId);
            });

            await setAttrsAsync({'wf_current': wfDesired});
        }
    }   
});

// WEAPON POINTS calculation
on('change:tpa_weapons change:wp_beam change:wp_missile', function(eventInfo) {
    getAttrs(['tpa_weapons', 'wp_beam', 'wp_missile'], function(values) {
        const tpa = parseInt(values['tpa_weapons']) || 0;
        const tpaToBeams = parseInt(values['wp_beam']) || 0;
        const tpaToMissiles = parseInt(values['wp_missile']) || 0;

        const tpaRemaining = tpa - tpaToBeams - tpaToMissiles;

        const output = {};
        output['wp_remaining'] = tpaRemaining;
        output['wp_remaining_status'] = (tpa != 0 || tpaRemaining != 0) && (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// WEAPON TARGETING
on('clicked:repeating_beams:btn-target clicked:repeating_missiles:btn-target', async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_chart`, `${row}_maxrange`, `${row}_power`, `${row}_damaged`, 
        `crewbonus`, `crewbonustohitapplied`, `crewrollpenalty`
    ]);

    const wpnName = attributes[`${row}_name`];
    const wpnChart = attributes[`${row}_chart`];
    const wpnMaxRange = parseInt(attributes[`${row}_maxrange`]) || 0;
    const wpnIsPowered = parseInt(attributes[`${row}_power`]) || 0;
    const wpnIsDamaged = parseInt(attributes[`${row}_damaged`]) || 0;
    const crewBonus = parseInt(attributes[`crewbonus`]) || 0;
    const crewBonusApplied = parseInt(attributes[`crewbonustohitapplied`]) || 0;
    const crewCasualtyPenalty = parseInt(attributes[`crewrollpenalty`]) || 0;

    const output = {};

    // Clear only the triggered row
    output[`${row}_target_name`] = '';
    output[`${row}_target_id`] = '';
    output[`${row}_target_distance`] = '';
    output[`${row}_target_tohit`] = '';
    output[`${row}_btn-fire_status`] = 0;

    await setAttrsAsync(output);

    // Get target input
    const { tokenName, charId } = await extractTargetData(); // Destructure JSON
    const wpnTargetDistance = +(await extractChatData('?{How far|1}')) || 0;
    const wpnCrewBonus = crewBonus == CREW_BONUS_WEAPONS && !crewBonusApplied ? +(await extractChatData('?{Apply crew bonus|Yes,1|No,0}')) || 0 : 0;
    const wpnTargetToHit = getToHit(wpnChart, wpnTargetDistance) + wpnCrewBonus + crewCasualtyPenalty;
    const wpnTargetToHitStr = `${wpnTargetToHit * 10}%`;

    // Get all matching banked weapons
    const bankedRows = [];
    const nameRoot = wpnName.match(/#\d+/);
    if (nameRoot) {
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        bankedRows.push(rowID); // Not banked — just target self
    }

    const weaponNames = [];

    for (const id of bankedRows) {
        const targetRow = `repeating_${section}_${id}`;
        const power = parseInt((await getAttrsAsync([`${targetRow}_power`]))[`${targetRow}_power`]) || 0;

        // Skip if not powered
        if (power === 0) continue;

        const rowAttrs = await getAttrsAsync([`repeating_${section}_${id}_name`]);

        weaponNames.push(rowAttrs[`repeating_${section}_${id}_name`] || 'Unknown Weapon');
        output[`${targetRow}_target_name`] = tokenName;
        output[`${targetRow}_target_id`] = charId;
        output[`${targetRow}_target_distance`] = wpnTargetDistance;
        output[`${targetRow}_target_tohit`] = wpnTargetToHit;
        output[`${targetRow}_btn-fire_status`] = wpnTargetToHit ? 1 : 0;
    }   

    // Roll result
    if (!wpnTargetToHit) {
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Target Out of Range}} {{Weapon=${wpnName}}} {{Max Range=${wpnMaxRange} hexes}} {{Target=${tokenName}}} {{Distance=${wpnTargetDistance} hexes}}`, roll => finishRoll(roll.rollId));
    } else {
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Weapons Targeted}} {{color=green}} {{Weapons=${weaponNames.join('\\n')}}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{Distance=${wpnTargetDistance} hexes}} {{Firing Chart=${wpnChart}}} {{Chance To-Hit=${wpnTargetToHitStr}}}`, roll => finishRoll(roll.rollId));
    }

    output[`crewbonustohitapplied`] = Math.max(wpnCrewBonus, crewBonusApplied);

    await setAttrsAsync(output);
}); 

function getToHit (chart, distance) {
    // ST:STCS firing chart data
    const ranges = [
        'A', 8, 6, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'B', 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'C', 10, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'D', 10, 9, 7, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'E', 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'F', 10, 9, 7, 6, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'G', 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'H', 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'I', 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'J', 10, 10, 9, 9, 8, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'K', 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'L', 10, 10, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'M', 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'N', 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'O', 10, 10, 9, 9, 8, 8, 7, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'P', 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0,
        'Q', 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'R', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        'S', 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        'T', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0,
        'U', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0,
        'V', 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0,
        'W', 10, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0,
        'X', 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0,
        'Y', 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1
    ];

    const index = ranges.indexOf(chart);
    const MAX_WPN_DISTANCE = 24;
    const toHit = ranges[index + Math.min(distance, MAX_WPN_DISTANCE)];

    return isNaN(toHit) ? 0 : toHit;
}

// WEAPON FIRING
on('clicked:repeating_beams:btn-fire clicked:repeating_missiles:btn-fire', async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_armed`, `${row}_power`, `${row}_power_max`,
        `${row}_bonus_3`, `${row}_bonus_2`, `${row}_bonus_1`,
        `${row}_target_name`, `${row}_target_id`, 
        `${row}_target_distance`, `${row}_target_tohit`, 'faction'
    ]);

    const faction = attributes['faction'];
    const wpnName = attributes[`${row}_name`];
    const wpnBankName = wpnName.match(/#\d+\w+/);
    const targetName = attributes[`${row}_target_name`];
    const targetId = attributes[`${row}_target_id`];
    const targetDistance = parseInt(attributes[`${row}_target_distance`]) || 0;
    const targetToHit = parseInt(attributes[`${row}_target_tohit`]) || 0;

    // Get all matching banked weapons or default to single weapon
    const bankedRows = [];
    if (wpnBankName) {
        const nameRoot = wpnName.match(/#\d+/);
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        // Not in a bank — fire just this weapon
        bankedRows.push(rowID);
    }

    const damageList = [];
    const weaponNames = [];

    for (const id of bankedRows) {
        const rowAttrs = await getAttrsAsync([
            `repeating_${section}_${id}_name`,
            `repeating_${section}_${id}_power`, `repeating_${section}_${id}_power_max`,
            `repeating_${section}_${id}_bonus_3`, `repeating_${section}_${id}_bonus_2`, `repeating_${section}_${id}_bonus_1`,
            `repeating_${section}_${id}_armed`,
            `repeating_${section}_${id}_target_name`, `repeating_${section}_${id}_target_tohit`
        ]);

        const wpnName = rowAttrs[`repeating_${section}_${id}_name`];
        const power = parseInt(rowAttrs[`repeating_${section}_${id}_power`]) || 0;
        const powerMax = parseInt(rowAttrs[`repeating_${section}_${id}_power_max`]) || 0;
        const bonus3 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_3`]) || 0;
        const bonus2 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_2`]) || 0;
        const bonus1 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_1`]) || 0;
        const armed = parseInt(rowAttrs[`repeating_${section}_${id}_armed`]) || 0;
        const targetName = rowAttrs[`repeating_${section}_${id}_target_name`];
        const targetToHit = parseInt(rowAttrs[`repeating_${section}_${id}_target_tohit`]) || 0;

        // Skip if not targeted
        if (!targetName || !targetToHit) continue;

        const isOCLaser = armed ? 0 : (power > powerMax ? 1 : 0);
        const powerDischarge = isOCLaser ? Math.floor(power / 2) : power;
        const totalDamage = powerDischarge + (
            targetDistance <= bonus3 ? 3 :
            targetDistance <= bonus2 ? 2 :
            targetDistance <= bonus1 ? 1 : 0
        );

        weaponNames.push(wpnName);
        damageList.push(totalDamage);

        // Reset weapon state
        const output = {};
        if (!armed) output[`repeating_${section}_${id}_power`] = isOCLaser ? powerDischarge : 0;
        output[`repeating_${section}_${id}_armed`] = 0;
        output[`repeating_${section}_${id}_btn-target_status`] = isOCLaser ? 1 : 0;
        output[`repeating_${section}_${id}_btn-fire_status`] = 0;
        output[`repeating_${section}_${id}_target_name`] = '';
        output[`repeating_${section}_${id}_target_distance`] = 0;
        output[`repeating_${section}_${id}_target_tohit`] = 0;
        await setAttrsAsync(output);
    }   

        // Single roll with all weapons and damages
        startRoll(
            `&{template:custom} {{title=@{banner_${faction}fire${section}} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Weapons Fired}} {{color=red}} {{Weapons=${weaponNames.join('\\n')}}} {{Target=[${targetName}](${ROLL20_CHAR_URL}${targetId})}} {{To-Hit=[[${targetToHit}]] or less}} {{Roll=[[1d10cs>11cf<0]]}} {{Damage=${damageList.join(', ')}}}`,
            roll => finishRoll(roll.rollId)
        );
    });

// WEAPON POWER (BEAM) ALLOCATION calculations
on('change:repeating_beams:name change:repeating_beams:damaged change:repeating_beams:power change:repeating_beams:power_max remove:repeating_beams', function(eventInfo) {
    getSectionIDs('repeating_beams', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
            Fieldnames.push(`repeating_beams_${id}_damaged`);
            Fieldnames.push(`repeating_beams_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_beams_${id}_power`);
            Fieldnames.push(`repeating_beams_${id}_power_max`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToBeams = 0;
            const output = {};
            ids.forEach(id => {
                const BEAM_TYPE_LASER_FED = 'FL-';
                const theBeamIsLaser = values[`repeating_beams_${id}_name`].includes(BEAM_TYPE_LASER_FED);
                const theBeamIsDamaged = parseInt(values[`repeating_beams_${id}_damaged`]) || 0;
                const theBeamIsReady = parseInt(values[`repeating_beams_${id}_btn-fire_status`]) || 0;
                const theBeamPower = parseInt(values[`repeating_beams_${id}_power`]) || 0;
                const theBeamPowerMax = parseInt(values[`repeating_beams_${id}_power_max`]) || 0;
                totalPowerToBeams += theBeamIsDamaged && !theBeamIsReady ? 0 : theBeamPower;

                output[`repeating_beams_${id}_power_status`] = theBeamIsDamaged && !theBeamIsReady == 1 ? 1 : (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) < 0 ? 1 : (theBeamPower > 0 ? 2 : 0);
                output[`repeating_beams_${id}_btn-target_status`] = theBeamPower && !theBeamIsDamaged && (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) > -1 ? 1 : 0;
                output[`repeating_beams_${id}_btn-fire_status`] = theBeamIsReady;
            });
            output['wp_beam'] = totalPowerToBeams;
            setAttrs(output);
        });
    });
});

// WEAPON POWER (MISSILE) ALLOCATION calculations
on('change:repeating_missiles:damaged change:repeating_missiles:armed change:repeating_missiles:cost remove:repeating_missiles', function(eventInfo) {
    getSectionIDs('repeating_missiles', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_damaged`);
            Fieldnames.push(`repeating_missiles_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_missiles_${id}_armed`);
            Fieldnames.push(`repeating_missiles_${id}_cost`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToMissiles = 0;
            const output = {};
            ids.forEach(id => {
                const theMissileIsDamaged = parseInt(values[`repeating_missiles_${id}_damaged`]) || 0;
                const theMissileIsReady = parseInt(values[`repeating_missiles_${id}_btn-fire_status`]) || 0;
                const theMissilePower = (parseInt(values[`repeating_missiles_${id}_armed`]) || 0) * (parseInt(values[`repeating_missiles_${id}_cost`]) || 0);
                totalPowerToMissiles += theMissileIsDamaged && !theMissileIsReady ? 0 : theMissilePower;

                output[`repeating_missiles_${id}_armed_status`] = theMissileIsDamaged == 1 ? 1 : 0;
                output[`repeating_missiles_${id}_btn-target_status`] = theMissilePower && !theMissileIsDamaged ? 1 : 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = theMissileIsReady;
            });
            output['wp_missile'] = totalPowerToMissiles;
            setAttrs(output);
        });
    });
});

/****************************/
function isRunningOnServer() { return self.dispatchEvent == undefined; }
function setActiveCharacterId(charId){
    var oldAcid=getActiveCharacterId();
    var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
    
    if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
        var ev = new CustomEvent("message");
        ev.data=msg; 
        self.dispatchEvent(ev);
    }else{ //otherwise, use the API (server) message processor, "onmessage"
        self.onmessage({data:msg});
    }
    return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
} 
var _sIn=setInterval;
setInterval=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sIn(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
var _sto=setTimeout
setTimeout=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sto(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
function getAttrsAsync(props){
    var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
    var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
            try{
                getAttrs(props,(values)=>{  resolve(values); }); 
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
    });
}
//use the same pattern for each of the following...
function setAttrsAsync(propObj, options){
    var acid=getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  
            try{
                setAttrs(propObj,options,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

function getSectionIDsAsync(sectionName){
    var acid = getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid = setActiveCharacterId(acid);  
            try{
                getSectionIDs(sectionName,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

</script>

<rolltemplate class="sheet-rolltemplate-custom">
    <div class="sheet-container sheet-color-{{color}}">
      <div class="sheet-header">
        {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
        {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
      </div>

      <div class="sheet-content">
        {{#allprops() title subtitle color Damage}}
        <div class="sheet-key">{{key}}</div>
        <div class="sheet-value">{{value}}</div>
        {{/allprops() title subtitle color Damage}}

        {{#^rollGreater() Roll Efficiency}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll Efficiency}}

        {{#rollGreater() Roll Efficiency}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll Efficiency}}

        {{#^rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Hit!</span></div>
        {{#Damage}}
            <div class="sheet-key">Damage</div>
            <div class="sheet-value">{{Damage}}</div>
        {{/Damage}}
        {{/^rollGreater() Roll To-Hit}}

        {{#rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Miss!</span></div>
        {{/rollGreater() Roll To-Hit}}

        {{#^rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll To-Repair}}

        {{#rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Repair}}

        {{#^rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Scanned!</span></div>
        {{/^rollGreater() Roll To-Scan}}

        {{#rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Scan}}

        {{#rollTotal() Remaining 0}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">No Damage!</span></div>
        {{/rollTotal() Remaining 0}}

        {{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
      </div>
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-menu">
    <div class="sheet-container sheet-color-{{color}}">
         <div class="sheet-header">
            {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
            {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
        </div>
         <div class="sheet-content">
            {{#allprops() title subtitle desc color}}
                <div class="sheet-key">{{key}}</div>
                <div class="sheet-value">{{value}}</div>
            {{/allprops() title subtitle desc color}}
            {{#desc}}
                <div class="sheet-desc">{{desc}}</div>
            {{/desc}}
        </div>
    </div>
</rolltemplate>