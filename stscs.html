<div>
    <h1><span name='attr_character_name'></span></h1> 
    <!-------------------------------------------------------->
    <div class='grid-3col'>
        <span>
            <span name='attr_class'></span>
            <span name='attr_type'></span>
        </span>
        <span>
            <label>Size:</label>
            <span name='attr_size'></span>
        </span>
        <span>
            <label>D / WDF / CE:</label>
            <input type='number' class='w5' name='attr_defense' min='0' step='.1' value='0'/>
            /
            <input type='number' class='w5' name='attr_wdf' min='0' step='.1' value='0'/>
            /
            <span name='attr_ce'>0</span>
        </span>

        <span>
            <label>Captain:</label>
            <input type='text' name='attr_capname' placeholder='name...'/>
        </span>
        <span>
            <label>Crew:</label>
            <span >
                <input type='number' class='w5' name='attr_crew' value='0' min='0'/>
                /
                <span name='attr_crew_max'></span>
            </span>
        </span>
        <span>
            <label>Ratings (Cap | Crew):</label>
            <input type='number' name='attr_caprating' min='48' value='60'/>
            |            
            <input type='number' name='attr_crewrating' min='27' value='40'/>
        </span>
        <span></span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Damage Control</h2>

    <div class='grid-6col'>
        <label>Hull Points:</label>
        <span>
            <input type='hidden' class='hp-status' name='attr_hp_status' value='0'/>
            <input type='number' class='hp' name='attr_hp' value='0'/>
            /
            <span name='attr_hp_max'></span>
        </span>
        <label>Damage Chart:</label>
        <span name='attr_dmg_chart'></span>
        <span></span>
        <span></span>

        <h4 class='span-grid'>Engines</h4>
        <div class='span-grid'>
            <label style='padding-left: 32px;'>Model</label>
            <label style='padding-left: 42px;'>Type</label>
            <label style='padding-left: 70px;'>Location</label>
            <label style='padding-left: 46px;'>Power</label>
            <label style='padding-left: 22px;'>Max</label>
        </div>
        <fieldset class='repeating_engines'>
            <input type='text' class='w10' name='attr_engine_model' placeholder='model...'/>
            <select class='w10' name='attr_engine_type'>
                <option value='0' selected>select...</option>
                <option value='1'>Impulse</option>
                <option value='2'>Warp</option>
                <option value='3'>Generator</option>
            </select>
            <select class='w10' name='attr_engine_location'>
                <option value='0' selected>select...</option>
                <option value='1'>Centerline</option>
                <option value='2'>Port</option>
                <option value='3'>Starboard</option>
            </select>
            <input type='hidden' class='engine-power-status' name='attr_engine_power_status' value='0'/>
            <input type='number' class='engine-power' name='attr_engine_power' min='0' value='0'/> / <input type='number' name='attr_engine_power_full' min='0' value='0'/>
        </fieldset>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Total Power Available</h2>
    <div class='grid-6col'>
        <label>TPA:</label> 
        <span><span name='attr_tpa'></span> / <span name='attr_tpa_max'></span></span>
        <button type='action' class='btn' name='act_tpa_reset'>Reset TPA</button>
        <span></span>
        <label>TPA Unallocated:</label>
        <input type='hidden' class='tpa-remaining-status' name='attr_tpa_remaining_status'/>
        <input type='number' class='tpa-remaining' name='attr_tpa_remaining'  value='0' readonly/>

        <label>TPA to Movement:</label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA to Shields:</label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA to Weapons:</label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
                
        <label>TPA to Warp:</label>
        <input type='number' name='attr_tpa_warp' min='0' value='0' readonly/>
        <span></span>
        <span></span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Helm Control</h2>
    <div class='grid-6col'>

        <label>TPA to Movement:</label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <span></span>
        <span></span>
        <label>TPA Remaining:</label> 
        <input type='hidden' class='mp-remaining-status' name='attr_mp_remaining_status'/>
        <input type='number' class='mp-remaining' name='attr_mp_remaining' value='0' readonly/>

        <label>Movement Point Ratio: </label>
        <span>
            <input type='number' class='w3' name='attr_mpr_1' min='1' max='9' value='1'/>
            /
            <input type='number' class='w3' name='attr_mpr_2' min='1' max='2' value='1'/>
        </span>
        <label>Movement Points:</label>
        <span>
            <input type='number' name='attr_mp'/>
            <input type='hidden' class='impulse-power-status' name='attr_impulse_power_status' value='0'/>
            <span class='no-impulse-power' title='no impulse power = max 1'>&#x1F534;</span>
        </span>
        <label>MP by Phase:</label> 
        <input type='hidden' name='attr_ta'/>
        <span>
            <span name='attr_mp1'></span> | <span name='attr_mp2'></span> | <span name='attr_mp3'></span>
        </span>

        <h4>Warp Speed</h4>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        <span></span>

        <label>TPA to Warp:</label>
        <input type='number' name='attr_tpa_warp' min='0' value='0' readonly/>
        <label>Warp Factor Ratio:</label>
        <input type='hidden' name='attr_wfr_jump'/>
        <input type='hidden' name='attr_wfr_cruise'/>
        <span>
            <input type='number' class='w3' name='attr_wfr_1' value='0' readonly/>
            /
            <input type='number' class='w3' name='attr_wfr_2' value='1' readonly/>
        </span>
        <span></span>
        <span></span>

        <label>Current Warp Factor</label>
        <input type='hidden' class='wf-current-status' name='attr_wf_current_status'/>
        <input type='number' class='wf-current' min='0' value='0' name='attr_wf_current' readonly/>
        <label>Desired Warp Factor</label>
        <input type='hidden' class='wf-desired-status' name='attr_wf_desired_status'/>
        <input type='number' class='em' min='0' value='0' name='attr_wf_desired'/>
        <button type='action' class='btn' name='act_jump'>Update: Phase 3 ONLY</button>
        <span></span>

        <label>Safe Cruise WF:</label>
        <input type='number' class='w5' name='attr_wf_cruise' min='0' value='0'/>
        <label>Emergency WF:</label>
        <input type='number' class='w5' name='attr_wf_emergency' min='0' value='0'/>
        <label>Stress Charts:</label>
        <span>
            <input type='text' class='w5' name='attr_stress_cruise' maxlength='1'/>
            /
            <input type='text' class='w5' name='attr_stress_emergency' maxlength='1'/> 
        </span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Shield Control</h2>
    <div class='grid-6col'>
        <label>TPA to Shields:</label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>Shield Points:</label>
        <span name='attr_sp'></span>
        <label>TPA Remaining:</label>
        <input type='hidden' class='sp-remaining-status' name='attr_sp_remaining_status'/>
        <input type='number' class='sp-remaining' name='attr_sp_remaining' value='0' readonly/>

        <label>SPR: </label>
        <span>
            <input type='number' class='w3' name='attr_spr_1' min='1' max='2' value='1'/>
            /        
            <input type='number' class='w3' name='attr_spr_2' min='1' max='6' value='1'/>
        </span>
        <label>Shield Type:</label>
        <input type='text' class='w10' name='attr_shield_type'/>
        <label>Max Shield Power:</label>
        <input type='number' name='attr_shield_max' min='0' max='16' value='0'/>

        <span class='shields-damaged'>
            <input type='checkbox' class='damaged' name='attr_shield_1_damaged' value='1' title='generator damaged'/>
            <input type='checkbox' class='damaged' name='attr_shield_2_damaged' value='1' title='generator damaged'/>
            <input type='checkbox' class='damaged' name='attr_shield_3_damaged' value='1' title='generator damaged'/>
            <input type='checkbox' class='damaged' name='attr_shield_4_damaged' value='1' title='generator damaged'/>
            <input type='checkbox' class='damaged' name='attr_shield_5_damaged' value='1' title='generator damaged'/>
            <input type='checkbox' class='damaged' name='attr_shield_6_damaged' value='1' title='generator damaged'/>
        </span>
        <span></span>
        
        <input type='hidden' class='shields-allocated-status' name='attr_shields_allocated_status' value='1'/>
        <span class='shields-allocated'>
            <label>f/p:</label>
            <input type='hidden' class='shield-1-status' name='attr_shield_1_status'/>
            <input type='number' class='shield-1' name='attr_shield_1' min='0' max='16' value='0' title='Shield #1 (f/p)'/>
            <label>fwd:</label>
            <input type='hidden' class='shield-2-status' name='attr_shield_2_status'/>
            <input type='number' class='shield-2' name='attr_shield_2' min='0' max='16' value='0' title='Shield #2 (fwd)'/>
            <label>f/s:</label>
            <input type='hidden' class='shield-3-status' name='attr_shield_3_status'/>
            <input type='number' class='shield-3' name='attr_shield_3' min='0' max='16' value='0' title='Shield #3 (f/s)'/>
            <label>a/s:</label>
            <input type='hidden' class='shield-4-status' name='attr_shield_4_status'/>
            <input type='number' class='shield-4' name='attr_shield_4' min='0' max='16' value='0' title='Shield #4 (a/s)'/>
            <label>aft</label>
            <input type='hidden' class='shield-5-status' name='attr_shield_5_status'/>
            <input type='number' class='shield-5' name='attr_shield_5' min='0' max='16' value='0' title='Shield #5 (aft)'/>
            <label>a/p:</label>
            <input type='hidden' class='shield-6-status' name='attr_shield_6_status'/>
            <input type='number' class='shield-6' name='attr_shield_6' min='0' max='16' value='0' title='Shield #6 (a/p)'/>
        </span>
        <input type='hidden' class='shields-allocated-status' name='attr_shields_allocated_status' value='1'/>
        <span class='shields-allocated-buttons'>
            <button type='action' class='btn' name='act_shield_commit'>Commit Allocation</button>
        </span>

        <input type='hidden' class='shields-current-status' name='attr_shields_current_status' value='0'/>
        <span class='shields-current'>
            <label>f/p:</label>
            <input type='hidden' class='shield-1c-status' name='attr_shield_1c_status'/>
            <input type='number' class='shield-1c' name='attr_shield_1c' min='0' max='16' value='0' title='Shield #1 (f/p)'/>
            <label>fwd:</label>
            <input type='hidden' class='shield-2c-status' name='attr_shield_2c_status'/>
            <input type='number' class='shield-2c' name='attr_shield_2c' min='0' max='16' value='0' title='Shield #2 (fwd)'/>
            <label>f/s:</label>
            <input type='hidden' class='shield-3c-status' name='attr_shield_3c_status'/>
            <input type='number' class='shield-3c' name='attr_shield_3c' min='0' max='16' value='0' title='Shield #3 (f/s)'/>
            <label>a/s:</label>
            <input type='hidden' class='shield-4c-status' name='attr_shield_4c_status'/>
            <input type='number' class='shield-4c' name='attr_shield_4c' min='0' max='16' value='0' title='Shield #4 (a/s)'/>
            <label>aft</label>
            <input type='hidden' class='shield-5c-status' name='attr_shield_5c_status'/>
            <input type='number' class='shield-5c' name='attr_shield_5c' min='0' max='16' value='0' title='Shield #5 (aft)'/>
            <label>a/p:</label>
            <input type='hidden' class='shield-6c-status' name='attr_shield_6c_status'/>
            <input type='number' class='shield-6c' name='attr_shield_6c' min='0' max='16' value='0' title='Shield #6 (a/p)'/>
        </span>
        <input type='hidden' class='shields-current-status' name='attr_shields_current_status' value='0'/>
        <span class='shields-current-buttons'>
            <button type='action' class='btn' name='act_shield_reenergize'>Re-Energize</button>
        </span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Fire Control</h2>
    <div class='grid-6col'>
        <label>TPA to Weapons:</label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
        <span></span>
        <span></span>
        <label>TPA Remaining:</label>
        <input type='hidden' class='wp-remaining-status' name='attr_wp_remaining_status'/>
        <input type='number' class='wp-remaining' name='attr_wp_remaining' value='0' readonly/>

    <h4 class='span-grid'>Beam Weapons</h4>
    <input type='hidden' name='attr_wp_beam'/>
    <div class='span-grid'>
        <label style='padding-left: 4px;'>X</label>
        <label style='padding-left: 15px;'>Desig. (Arcs)</label>
        <label style='padding-left: 18px;'>Range</label>
        <label style='padding-left: 15px;'>Chart</label>
        <label style='padding-left: 14px;'>Power</label>
        <label style='padding-left: 23px;'>Max</label>
        <label style='padding-left: 20px;'>+3</label>
        <label style='padding-left: 20px;'>+2</label>
        <label style='padding-left: 20px;'>+1</label>
        <label style='padding-left: 115px;'>Target</label>
        <label style='padding-left: 36px;'>Distance</label>
        <label style='padding-left: 5px;'>To-Hit</label>
    </div>
    <fieldset class='repeating_beams'>
        <input type='checkbox' class='damaged' name='attr_damaged' value='1'/>
        <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
        <input type='number' class='w5' name='attr_maxrange'/>
        <select class='w5' name='attr_chart'>
            <option value='0' selected>select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
            <option>D</option>
            <option>E</option>
            <option>F</option>
            <option>G</option>
            <option>H</option>
            <option>I</option>
            <option>J</option>
            <option>K</option>
            <option>L</option>
            <option>M</option>
            <option>N</option>
            <option>O</option>
            <option>P</option>
            <option>Q</option>
            <option>R</option>
            <option>S</option>
            <option>T</option>
            <option>U</option>
            <option>V</option>
            <option>W</option>
            <option>X</option>
            <option>Y</option>
        </select>
        <input type='hidden' class='power-status' name='attr_power_status'/>
        <input type='number' class='power' name='attr_power' min='0' max='10' value='0'/>
        /
        <input type='number' name='attr_power_max' min='0' max='10' value='0'/>
        <input type='text' class='w3' name='attr_bonus_3' value='-'/>
        <input type='text' class='w3' name='attr_bonus_2' value='-'/>
        <input type='text' class='w3' name='attr_bonus_1' value='-'/>
        <span>
            <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
            <button type='action' class='btn' name='act_btn-target'>Target</button>
        </span>
        →
        <input type='text' class='w10' name='attr_target_name' readonly/>
        <input type='number' class='w5' name='attr_target_distance' value='0' readonly/>
        <input type='text' class='w5' name='attr_target_tohit' value='0' readonly/>
        <span>
            <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/>
            <button type='action' class='btn' name='act_btn-fire'>Fire</button>
        </span>
    </fieldset>
    
    <h4 class='span-grid'>Missile Weapons</h4>
    <input type='hidden' name='attr_wp_missile'/>
    <div class='span-grid'>
        <label style='padding-left: 4px;'>X</label>
        <label style='padding-left: 15px;'>Desig. (Arcs)</label>
        <label style='padding-left: 18px;'>Range</label>
        <label style='padding-left: 15px;'>Chart</label>
        <label style='padding-left: 14px;'>Power</label>
        <label style='padding-left: 2px;'>Damage</label>
        <label style='padding-left: 7px;'>Arm</label>
        <label style='padding-left: 192px;'>Target</label>
        <label style='padding-left: 36px;'>Distance</label>
        <label style='padding-left: 5px;'>To-Hit</label>
    </div>
    <fieldset class='repeating_missiles'>
        <input type='checkbox' class='damaged' name='attr_damaged' value='1'/>
        <input type='text' class='w10' name='attr_name' placeholder='# Name (arcs)...'/>
        <input type='number' class='w5' name='attr_maxrange'/>
        <select class='w5' name='attr_chart'>
            <option value='0' selected>select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
            <option>D</option>
            <option>E</option>
            <option>F</option>
            <option>G</option>
            <option>H</option>
            <option>I</option>
            <option>J</option>
            <option>K</option>
            <option>L</option>
            <option>M</option>
            <option>N</option>
            <option>O</option>
            <option>P</option>
            <option>Q</option>
            <option>R</option>
            <option>S</option>
            <option>T</option>
            <option>U</option>
            <option>V</option>
            <option>W</option>
            <option>X</option>
            <option>Y</option>
        </select>
        <input type='number' name='attr_cost' min='1' max='4' value='1'/>
        <input type='number' name='attr_power' min='1' max='20' value='1'/>
        <input type='hidden' class='missile-armed-status' name='attr_armed_status'/>
        <input type='checkbox' class='missile-armed' style='margin-left: 13px;' value='1' name='attr_armed'/>
        <span>
            <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
            <button type='action' class='btn' style='margin-left: 95px;' name='act_btn-target'>Target</button>
        </span>
        →
        <input type='text' class='w10' name='attr_target_name' readonly/>
        <input type='number' class='w5' name='attr_target_distance' value='0' readonly/>
        <input type='text' class='w5' name='attr_target_tohit' value='0' readonly/>
        <span>
            <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/>
            <button type='action' class='btn' name='act_btn-fire'>Fire</button>
        </span>
    </fieldset>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Construction Data</h2> 

    <div class='grid-3col'>
        <span>
            <label>Fleet:</label>
            <select name='attr_faction'>
                <option selected>Select...</option>
                <option value='federation'>United Federation of Planets</option>
                <option value='klingon'>Klingon Empire</option>
            </select>
        </span>

        <span>
            <label>Class:</label>
            <input type='text' name='attr_class' placeholder='Class...'/>
        </span>

        <span>
            <label>Type:</label>
            <input type='text' name='attr_type' placeholder='Type...'/>
        </span>

        <span>
            <label>Date Entering Service:</label>
            <input type='text' class='w10' name='attr_date' placeholder='Date...'/>
        </span>

        <span>
            <label>Number Constructed:</label>
            <input type='number' class='w7' name='attr_num' min='0'/>
        </span>

        <span>
            <label>Control Computer Type:</label>
            <input type='text' class='w7' name='attr_computer'/>
        </span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Hull Data</h2>
    <div class='grid-6col'>
        <label>Hull Points:</label>
        <input type='number' class='w7' name='attr_hp_max' min='0' value='0'/>
        
        <label>Damage Chart:</label>
        <select class='w7' name='attr_dmg_chart'>
            <option value='0' selected>Select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
            <option>S</option>
        </select>

        <label>Mass (mt):</label>
        <input type='number' class='w7' name='attr_mass' min='0' max='999999' value='0'/>

        <label>Length (m):</label>
        <input type='number' class='w7' name='attr_length' min='0'/>

        <label>Width (m):</label>
        <input type='number' class='w7' name='attr_width' min='0'/>
        
        <label>Height (m):</label>
        <input type='number' class='w7' name='attr_height' min='0'/>
        
        <label>Cargo Units (SCU):</label>
        <input type='number' class='w7' name='attr_scu' min='0' value='0'/>

        <label>Cargo Capacity:</label>
        <span name='attr_scu_cap'></span>

        <label>Cargo Transporters:</label>
        <input type='number' class='w7' name='attr_scu_trans' min='0' value='0'></span>
    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Crew Data</h2>
    <div class='grid-6col'>
        <label>Crew:</label>
        <input type='number' class='w7' name='attr_crew_max' min='0' value='0'/>
        
        <label>Passengers/Troops:</label>
        <input type='number' class='w7' name='attr_troops_max' min='0' value='0'/>

        <label>Shuttlecraft:</label>
        <input type='number' class='w7' name='attr_shuttlecraft_max' min='0' value='0'/>

        <label>Transporters:</label>
        <input type='number' class='w7' name='attr_trans_standard' min='0' value='0'/>

        <label>Combat:</label>
        <input type='number' class='w7' name='attr_trans_combat' min='0' value='0'/>

        <label>Emergency:</label>
        <input type='number' class='w7' name='attr_trans_emergency' min='0' value='0'/>

    </div>
    <hr/>

    <!-------------------------------------------------------->
    <h2>Maintenance</h2>
    <div class='grid-3col'>
        <p class='span-grid'><strong>Do not use these controls during battle!</strong></p>
        <button type='action' class='btn' name='act_repair'>Repair/Reset Vessel</button>
    </div>

<!-- Banner placeholders (see readme) -->
<input type='hidden' name='attr_banner_federationfirebeams' value='[x](https://files.d20.io/images/459374797/BrLK7l69a5n4Mfomy8M4GA/original.png)'/>
<input type='hidden' name='attr_banner_federationfiremissiles' value='[x](https://files.d20.io/images/461676845/PIWNmdJhQ8DotQAYJS7Eew/original.png)'/>
<input type='hidden' name='attr_banner_federationwarp' value='[x](https://files.d20.io/images/461519720/yapt5OaNN9fy0m-b2HhVaQ/original.png)'/>
<input type='hidden' name='attr_banner_klingonfirebeams' value='[x](https://files.d20.io/images/461674377/cX_DbSv-iBzHRa8XCK36uw/original.png)'/>
<input type='hidden' name='attr_banner_klingonfiremissiles' value='[x](https://files.d20.io/images/459155112/hNZ9AQX33_kJr7InoxYVbA/original.png)'/>
<input type='hidden' name='attr_banner_klingonwarp' value='[x](https://files.d20.io/images/461677914/LFn_ncPFcBHm_yHjz6xr9A/original.png)'/>

<script type='text/worker'>
const ENGINE_TYPE_IMPULSE = 1;
const ENGINE_TYPE_WARP = 2;
const BEAM_TYPE_LASER_FED = 'FL-';

// HELPER: Format large numbers with commas
function formatNumber(value) {
    value = value.replace(/\D/g, '');
    return value.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// CARGO CAPACITY calculation
on('change:scu', function(eventInfo) {
    getAttrs(['scu'], function(values) {
        const scu = parseInt(values['scu']) || 0;

        const scuCapacity = formatNumber(String(scu * 50));

        const output = {};
        output['scu_cap'] = `${scuCapacity} mt`;
        setAttrs(output);
    });
});

// COMBAT EFFICIENCY calculation
on('change:defense change:wdf', function(eventInfo) {
    getAttrs(['defense', 'wdf'], function(values) {
        const defense = parseInt(values['defense']) || 0;
        const wpnDmgFactor = parseInt(values['wdf']) || 0;

        const combatEfficiency = defense * wpnDmgFactor / 100;

        const output = {};
        output['ce'] = combatEfficiency;
        setAttrs(output);
    });
});

// IMPULSE POWER status indicator
on('change:repeating_engines:engine_power', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
                    const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                    totalPower += enginePower;
                }
            });
            output['impulse_power_status'] = totalPower == 0 ? 1 : 0;
            setAttrs(output);
        });
    });
});

// MOVEMENT POINTS AVAILABLE calculation
on('change:tpa_movement change:mpr_1 change:mpr_2', function(eventInfo) {
    getAttrs(['tpa_movement', 'mpr_1', 'mpr_2'], function(values) {
        const power = parseInt(values['tpa_movement']) || 0;
        const mpr = (parseInt(values['mpr_1']) || 1) / (parseInt(values['mpr_2']) || 1);

        const mp = Math.floor(power / mpr);
        const mpPhase1 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 1
        const mpPhase2 = Math.floor(mp / 3) + (mp % 3 == 1 ? 1 : 0); // phase 2
        const mpPhase3 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 3
        const powerUnused = power % mpr;

        const output = {};
        output['mp'] = mp;
        output['ta'] = mp * 100;
        output['mp1'] = mpPhase1;
        output['mp2'] = mpPhase2;
        output['mp3'] = mpPhase3;
        output['mp_remaining'] = powerUnused;
        output['mp_remaining_status'] = power != 0 && (powerUnused < 0 ? 1 : (powerUnused > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// REPAIR and RESET after combat
on('clicked:repair', function(eventInfo) {
    // Repair engines
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_engines_${id}_engine_power`] = values[`repeating_engines_${id}_engine_power_full`];
            });
            setAttrs(output);
        });
    });

    // Repair beam weapons
    getSectionIDs('repeating_beams', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_damaged`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_beams_${id}_damaged`] = 0;
            });
            setAttrs(output);
        });
    });

    // Repair missile weapons
    getSectionIDs('repeating_missiles', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_damaged`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_missiles_${id}_damaged`] = 0;
            });
            setAttrs(output);
        });
    });

    // Repair hull and shields, and replace crew
    getAttrs(['hp_max', 'crew_max'], function(values) {
        const hpMax = parseInt(values['hp_max']) || 0;
        const crewMax = parseInt(values['crew_max']) || 0;

        const output = {};
        output['hp'] = hpMax;
        output['crew'] = crewMax;
        output['shield_1_damaged'] = 0;
        output['shield_2_damaged'] = 0;
        output['shield_3_damaged'] = 0;
        output['shield_4_damaged'] = 0;
        output['shield_5_damaged'] = 0;
        output['shield_6_damaged'] = 0;
        output['wf_current'] = 0;
        output['wf_desired'] = 0;
        setAttrs(output);
    });

    resetTPA();
});

// SHIELD POINTS calculation
on('change:tpa_shields change:spr_1 change:spr_2 change:shield_1 change:shield_2 change:shield_3 change:shield_4 change:shield_5 change:shield_6', function(eventInfo) {
    getAttrs(['tpa_shields', 'spr_1', 'spr_2', 'shield_1', 'shield_2', 'shield_3', 'shield_4', 'shield_5', 'shield_6'], function(values) {
        const power = parseInt(values['tpa_shields']) || 0;
        const spr = (parseInt(values['spr_1']) || 1) / (parseInt(values['spr_2']) || 1);
        const shield1 = parseInt(values['shield_1']) || 0;
        const shield2 = parseInt(values['shield_2']) || 0;
        const shield3 = parseInt(values['shield_3']) || 0;
        const shield4 = parseInt(values['shield_4']) || 0;
        const shield5 = parseInt(values['shield_5']) || 0;
        const shield6 = parseInt(values['shield_6']) || 0;

        const sp = Math.floor(power / spr);
        const powerRemaining = Math.round(power - shield1 * spr - shield2 * spr - shield3 * spr - shield4 * spr - shield5 * spr - shield6 * spr);

        const output = {};
        output['sp'] = sp;
        output['sp_remaining'] = powerRemaining;
        output['sp_remaining_status'] = (power != 0 || powerRemaining != 0) && (powerRemaining < 0 ? 1 : (powerRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// SHIELD POINTS ALLOCATED status indicators
on('change:shield_1 change:shield_1_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_1', 'shield_1_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_1']) || 0;
        const shieldIsDamaged = parseInt(values['shield_1_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_1_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_1c'] = shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});
on('change:shield_2 change:shield_2_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_2', 'shield_2_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_2']) || 0;
        const shieldIsDamaged = parseInt(values['shield_2_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_2_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_2c'] = shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});
on('change:shield_3 change:shield_3_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_3', 'shield_3_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_3']) || 0;
        const shieldIsDamaged = parseInt(values['shield_3_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_3_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_3c'] = shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});
on('change:shield_4 change:shield_4_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_4', 'shield_4_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_4']) || 0;
        const shieldIsDamaged = parseInt(values['shield_4_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_4_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_4c'] = shieldIsDamaged ? 0 : shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});
on('change:shield_5 change:shield_5_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_5', 'shield_5_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_5']) || 0;
        const shieldIsDamaged = parseInt(values['shield_5_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_5_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_5c'] = shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});
on('change:shield_6 change:shield_6_damaged change:shield_max', function(eventInfo) {
    getAttrs(['shield_6', 'shield_6_damaged', 'shield_max'], function(values) {
        const shieldSP = parseInt(values['shield_6']) || 0;
        const shieldIsDamaged = parseInt(values['shield_6_damaged']) || 0;
        const shieldSPMax = parseInt(values['shield_max']) || 0;

        const output = {};
        output['shield_6_status'] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
        output['shield_6c'] = shieldIsDamaged ? 0 : shieldSP; // When allocation changes, reset & update current
        setAttrs(output);
    });
});

// SHIELD POINTS CURRENT status indicators
on('change:shield_1c', function(eventInfo) {
    getAttrs(['shield_1', 'shield_1c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_1']) || 0;
        const shieldSPCurrent = parseInt(values['shield_1c']) || 0;

        const output = {};
        output['shield_1c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});
on('change:shield_2c', function(eventInfo) {
    getAttrs(['shield_2', 'shield_2c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_2']) || 0;
        const shieldSPCurrent = parseInt(values['shield_2c']) || 0;

        const output = {};
        output['shield_2c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});
on('change:shield_3c', function(eventInfo) {
    getAttrs(['shield_3', 'shield_3c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_3']) || 0;
        const shieldSPCurrent = parseInt(values['shield_3c']) || 0;

        const output = {};
        output['shield_3c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});
on('change:shield_4c', function(eventInfo) {
    getAttrs(['shield_4', 'shield_4c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_4']) || 0;
        const shieldSPCurrent = parseInt(values['shield_4c']) || 0;

        const output = {};
        output['shield_4c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});
on('change:shield_5c', function(eventInfo) {
    getAttrs(['shield_5', 'shield_5c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_5']) || 0;
        const shieldSPCurrent = parseInt(values['shield_5c']) || 0;

        const output = {};
        output['shield_5c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});
on('change:shield_6c', function(eventInfo) {
    getAttrs(['shield_6', 'shield_6c'], function(values) {
        const shieldSPAllocated = parseInt(values['shield_6']) || 0;
        const shieldSPCurrent = parseInt(values['shield_6c']) || 0;

        const output = {};
        output['shield_6c_status'] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
        setAttrs(output);
    });
});

// SHIELD POWER COMMITTED
on('clicked:shield_commit', function(eventInfo) {
    const output = {};
    output['shields_allocated_status'] = 0;
    output['shields_current_status'] = 1;
    setAttrs(output);
});


// SHIELDS RE-ENERGIZED
on('clicked:shield_reenergize', function(eventInfo) {
    getAttrs(['shield_1', 'shield_2', 'shield_3', 'shield_4', 'shield_5', 'shield_6', 'shield_1_damaged', 'shield_2_damaged', 'shield_3_damaged', 'shield_4_damaged', 'shield_5_damaged', 'shield_6_damaged'], function(values) {
        const shield1Allocation = parseInt(values['shield_1']) || 0;
        const shield2Allocation = parseInt(values['shield_2']) || 0;
        const shield3Allocation = parseInt(values['shield_3']) || 0;
        const shield4Allocation = parseInt(values['shield_4']) || 0;
        const shield5Allocation = parseInt(values['shield_5']) || 0;
        const shield6Allocation = parseInt(values['shield_6']) || 0;
        const shield1IsDamaged = parseInt(values['shield_1_damaged']) || 0;
        const shield2IsDamaged = parseInt(values['shield_2_damaged']) || 0;
        const shield3IsDamaged = parseInt(values['shield_3_damaged']) || 0;
        const shield4IsDamaged = parseInt(values['shield_4_damaged']) || 0;
        const shield5IsDamaged = parseInt(values['shield_5_damaged']) || 0;
        const shield6IsDamaged = parseInt(values['shield_6_damaged']) || 0;

        const output = {};
        output['shield_1c'] = shield1IsDamaged ? 0 : shield1Allocation;
        output['shield_2c'] = shield2IsDamaged ? 0 : shield2Allocation;
        output['shield_3c'] = shield3IsDamaged ? 0 : shield3Allocation;
        output['shield_4c'] = shield4IsDamaged ? 0 : shield4Allocation;
        output['shield_5c'] = shield5IsDamaged ? 0 : shield5Allocation;
        output['shield_6c'] = shield6IsDamaged ? 0 : shield6Allocation;
        setAttrs(output);
    });
});

// SUPERSTRUCTURE MASS and SIZE calculations
on('change:mass', function(eventInfo) {
    getAttrs(['mass'], function(values) {
        const shipsMass = parseInt(values['mass']) || 0;
        const shipsFormattedMass = formatNumber(String(shipsMass));

        const theSizes = [0,'I',5000,'II',15000,'III',25000,'IV',40000,'V',60000,'VI',80000,'VII',100000,'VIII',120000,'IX',140000,'X',160000,'XI',180000,'XII',210000,'XIII',240000,'XIV',300000,'XV',350000,'XVI',400000,'XVII',450000,'XVIII',500000,'XIX',600000,'XX',700000];
        let i = 0;
        do {
            i += 2;
        } while (shipsMass > theSizes[i]);      

        const output = {};
        output['size'] = `${shipsFormattedMass} mt (${theSizes[i-1]})`;
        setAttrs(output);
    });
});

// SUPERSTRUCTURE status indicator
on('change:hp', function(eventInfo) {
    getAttrs(['hp', 'hp_max'], function(values) {
        const hp = parseInt(values['hp']) || 0;  
        const hpMax = parseInt(values['hp_max']) || 0;  

        const output = {};
        output['hp_status'] = hp < (hpMax / 2) || hp > hpMax ? 1 : hp < hpMax ? 2 : 0;
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE calculation
on('change:repeating_engines:engine_power change:repeating_engines:engine_power_full remove:repeating_engines', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let tpa = 0;
            let tpaMax = 0;
            const output = {};
            ids.forEach(id => {
                const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                const enginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                
                tpa += enginePower;
                tpaMax += enginePowerMax

                output[`repeating_engines_${id}_engine_power_status`] = ((enginePower > enginePowerMax) || (enginePower == 0)) ? 1 : enginePower < enginePowerMax ? 2 : 0;
            });
            output['tpa'] = tpa;
            output['tpa_max'] = tpaMax;
            setAttrs(output);
        });
    });
});

// TOTAL POWER AVAILABLE remaining calculation
on('change:tpa change:tpa_movement change:tpa_warp change:tpa_weapons change:tpa_shields', function(eventInfo) {
    getAttrs(['tpa', 'tpa_movement', 'tpa_warp', 'tpa_weapons', 'tpa_shields'], function(values) {
        const tpa = parseInt(values['tpa']) || 0;
        const tpaToMovement = parseInt(values['tpa_movement']) || 0;
        const tpaToWarp = parseInt(values['tpa_warp']) || 0;
        const tpaToWeapons = parseInt(values['tpa_weapons']) || 0;
        const tpaToShields = parseInt(values['tpa_shields']) || 0;

        const tpaRemaining = tpa - tpaToMovement - tpaToWarp - tpaToWeapons - tpaToShields;

        const output = {};
        output['tpa_remaining'] = tpaRemaining;
        output['tpa_remaining_status'] = (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE reset
on('clicked:tpa_reset', function(eventInfo) {
    resetTPA();
});
function resetTPA() {
    getSectionIDs('repeating_beams', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_beams_${id}_power`] = 0;
                output[`repeating_beams_${id}_target_name`] = '';
                output[`repeating_beams_${id}_target_distance`] = 0;
                output[`repeating_beams_${id}_target_tohit`] = 0;
                output[`repeating_beams_${id}_btn-target_status`] = 0;
                output[`repeating_beams_${id}_btn-fire_status`] = 0;
            });
            output['wp_beam'] = 0;
            setAttrs(output);
        });
    });

    getSectionIDs('repeating_missiles', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_missiles_${id}_armed`] = 0;
                output[`repeating_missiles_${id}_target_name`] = '';
                output[`repeating_missiles_${id}_target_distance`] = 0;
                output[`repeating_missiles_${id}_target_tohit`] = 0;
                output[`repeating_missiles_${id}_btn-target_status`] = 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = 0;
            });
            output['wp_missile'] = 0;
            setAttrs(output);
        });
    });

    const output = {};
    output['shield_1'] = output['shield_2'] = output['shield_3'] = output['shield_4'] = output['shield_5'] = output['shield_6'] = 0
    output['shields_allocated_status'] = 1;
    output['shields_current_status'] = 0;
    output['tpa_movement'] = 0;
    output['tpa_weapons'] = 0;
    output['tpa_shields'] = 0;
    setAttrs(output);
}

// WARP FACTOR changed by player
on('change:wf_current change:wf_desired', function(eventInfo) {
    getAttrs(['wf_current', 'wf_desired', 'wf_cruise', 'wf_emergency', 'wfr_cruise', 'wfr_jump'], function(values) {
        const wfCurrent = parseInt(values['wf_current']) || 0;
        const wfDesired = parseInt(values['wf_desired']) || 0;
        const wfCruise = parseInt(values['wf_cruise']) || 0;
        const wfEmergency = parseInt(values['wf_emergency']) || 0;
        const wfrCruise = parseInt(values['wfr_cruise']) || 0;
        const wfrJump = parseInt(values['wfr_jump']) || 0;

        const wfrCurrent = wfDesired > wfCurrent ? wfrJump : wfrCruise;
        const tpaRequired = wfDesired > wfCurrent ? wfDesired * wfrCurrent : wfrCruise * Math.min(wfCurrent, wfDesired);

        const output = {};
        output['wfr_1'] = wfrCurrent;
        output['tpa_warp'] = tpaRequired;
        output['wf_current_status'] = wfCurrent > wfEmergency ? 1 : wfCurrent > wfCruise ? 2 : 0;
        output['wf_desired_status'] = wfDesired > wfEmergency ? 1 : wfDesired != wfCurrent || wfDesired > wfCruise ? 2 : 0;
        setAttrs(output);
    });
});

// WARP FACTOR RATIO calculations
// Note: This should not occur after initial ship setup
//  but event is triggered whenever engine power changes
on('change:repeating_engines:engine_power_full remove:repeating_engines change:wf_emergency', function(eventInfo) {
    getSectionIDs('repeating_engines', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames, 'wf_emergency'], function (values) {
            const wfEmergency = parseInt(values['wf_emergency']) || 0;

            let totalWarpEngines = 0;
            let totalWarpPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP) {
                    const theEnginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                    totalWarpEngines += 1;
                    totalWarpPower += theEnginePowerMax;
                }
            });

            output['wf_current'] = output['wf_desired'] = 0; // Clear settings
            output['wfr_jump'] = output['wfr_1'] = Math.floor(totalWarpPower / wfEmergency);
            output['wfr_cruise'] = totalWarpEngines;
            setAttrs(output);
        });
    });
});

// WARP JUMP
on('clicked:jump', function(eventInfo) {
    getAttrs(['wf_current', 'wf_desired', 'faction'], function(values) {
        const wfCurrent = parseInt(values['wf_current']) || 0;
        const wfDesired = parseInt(values['wf_desired']) || 0;
        const faction = values['faction'];

        if (wfCurrent != wfDesired) {
            startRoll(`&{template:custom} {{title=@{banner_${faction}warp} **@{character_name}**}} {{subtitle=Warp Factor Change}} {{color=blue}} {{From=Warp Factor **@{wf_current}**}} {{To=Warp Factor **@{wf_desired}**}}`, roll => {
                finishRoll(roll.rollId);
            });

            const output = {};
            output['wf_current'] = wfDesired;
            setAttrs(output);
        }
    });   
});

// WEAPON POINTS calculation
on('change:tpa_weapons change:wp_beam change:wp_missile', function(eventInfo) {
    getAttrs(['tpa_weapons', 'wp_beam', 'wp_missile'], function(values) {
        const tpa = parseInt(values['tpa_weapons']) || 0;
        const tpaToBeams = parseInt(values['wp_beam']) || 0;
        const tpaToMissiles = parseInt(values['wp_missile']) || 0;

        const tpaRemaining = tpa - tpaToBeams - tpaToMissiles;

        const output = {};
        output['wp_remaining'] = tpaRemaining;
        output['wp_remaining_status'] = (tpa != 0 || tpaRemaining != 0) && (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// WEAPON TARGETING
on('clicked:repeating_beams:btn-target clicked:repeating_missiles:btn-target', async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_chart`, `${row}_maxrange`, `${row}_power`, `${row}_damaged`
    ]);

    const wpnName = attributes[`${row}_name`];
    const wpnChart = attributes[`${row}_chart`];
    const wpnMaxRange = parseInt(attributes[`${row}_maxrange`]) || 0;
    const wpnIsPowered = parseInt(attributes[`${row}_power`]) || 0;
    const wpnIsDamaged = parseInt(attributes[`${row}_damaged`]) || 0;

    // Get target input
    const wpnTargetName = await extractChatData('@{target|token_name}');
    const wpnTargetDistance = +(await extractChatData('?{How far|1}')) || 0;
    const wpnTargetToHit = getToHit(wpnChart, wpnTargetDistance);
    const wpnTargetToHitStr = `${wpnTargetToHit * 10}%`;

    // Get all matching banked weapons
    const bankedRows = [];
    const nameRoot = wpnName.match(/#\d+/);
    if (nameRoot) {
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        bankedRows.push(rowID); // Not banked — just target self
    }

    const output = {};
    const weaponNames = [];

    for (const id of bankedRows) {
        const targetRow = `repeating_${section}_${id}`;
        const power = parseInt((await getAttrsAsync([`${targetRow}_power`]))[`${targetRow}_power`]) || 0;

        // Skip if not powered
        if (power === 0) continue;

        weaponNames.push(attributes[`${row}_name`] || 'Unknown Weapon');
        output[`${targetRow}_target_name`] = wpnTargetName;
        output[`${targetRow}_target_distance`] = wpnTargetDistance;
        output[`${targetRow}_target_tohit`] = wpnTargetToHit;
        output[`${targetRow}_btn-fire_status`] = wpnTargetToHit ? 1 : 0;
    }   

    // Roll result
    if (!wpnTargetToHit) {
        startRoll(`&{template:custom} {{title=**@{character_name}**}} {{subtitle=Target Out of Range}} {{Weapon=${wpnName}}} {{Max Range=${wpnMaxRange} hexes}} {{Target=${wpnTargetName}}} {{Distance=${wpnTargetDistance} hexes}}`, roll => finishRoll(roll.rollId));
    } else {
        startRoll(`&{template:custom} {{title=**@{character_name}**}} {{subtitle=Weapons Targeted}} {{color=green}} {{Weapons=${weaponNames.join('\\n')}}} {{Target=${wpnTargetName}}} {{Distance=${wpnTargetDistance} hexes}} {{Firing Chart=${wpnChart}}} {{Chance To-Hit=${wpnTargetToHitStr}}}`, roll => finishRoll(roll.rollId));
    }

    await setAttrsAsync(output);
});   
const extractChatData = async (query) => {
    query = await startRoll(`!{{target=[[0[response=${query}]]]}}`);
    finishRoll(query.rollId);
    return query.results.target.expression.replace(/0\[response=(.+?)\]/,'$1');
};
function getToHit (chart, distance) {
    // ST:STCS firing chart data
    const ranges = [
        'A', 8, 6, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'B', 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'C', 10, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'D', 10, 9, 7, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'E', 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'F', 10, 9, 7, 6, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'G', 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'H', 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'I', 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'J', 10, 10, 9, 9, 8, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'K', 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'L', 10, 10, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'M', 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'N', 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'O', 10, 10, 9, 9, 8, 8, 7, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'P', 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0,
        'Q', 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        'R', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        'S', 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        'T', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0,
        'U', 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0,
        'V', 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0,
        'W', 10, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0,
        'X', 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0,
        'Y', 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1
    ];

    const index = ranges.indexOf(chart);
    const toHit = ranges[index + distance];

    return isNaN(toHit) ? 0 : toHit;
}

// WEAPON FIRING
on('clicked:repeating_beams:btn-fire clicked:repeating_missiles:btn-fire', async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_armed`, `${row}_power`, `${row}_power_max`,
        `${row}_bonus_3`, `${row}_bonus_2`, `${row}_bonus_1`,
        `${row}_target_name`, `${row}_target_distance`, `${row}_target_tohit`, 'faction'
    ]);

    const faction = attributes['faction'];
    const wpnName = attributes[`${row}_name`];
    const wpnBankName = wpnName.match(/#\d+\w+/);
    const targetName = attributes[`${row}_target_name`];
    const targetDistance = parseInt(attributes[`${row}_target_distance`]) || 0;
    const targetToHit = parseInt(attributes[`${row}_target_tohit`]) || 0;

    // Get all matching banked weapons or default to single weapon
    const bankedRows = [];
    if (wpnBankName) {
        const nameRoot = wpnName.match(/#\d+/);
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        // Not in a bank — fire just this weapon
        bankedRows.push(rowID);
    }

    const damageList = [];
    const weaponNames = [];

    for (const id of bankedRows) {
        const rowAttrs = await getAttrsAsync([
            `repeating_${section}_${id}_name`,
            `repeating_${section}_${id}_power`, `repeating_${section}_${id}_power_max`,
            `repeating_${section}_${id}_bonus_3`, `repeating_${section}_${id}_bonus_2`, `repeating_${section}_${id}_bonus_1`,
            `repeating_${section}_${id}_armed`,
            `repeating_${section}_${id}_target_name`, `repeating_${section}_${id}_target_tohit`
        ]);

        const wpnName = rowAttrs[`repeating_${section}_${id}_name`];
        const power = parseInt(rowAttrs[`repeating_${section}_${id}_power`]) || 0;
        const powerMax = parseInt(rowAttrs[`repeating_${section}_${id}_power_max`]) || 0;
        const bonus3 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_3`]) || 0;
        const bonus2 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_2`]) || 0;
        const bonus1 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_1`]) || 0;
        const armed = parseInt(rowAttrs[`repeating_${section}_${id}_armed`]) || 0;
        const targetName = rowAttrs[`repeating_${section}_${id}_target_name`];
        const targetToHit = parseInt(rowAttrs[`repeating_${section}_${id}_target_tohit`]) || 0;

        // Skip if not targeted
        if (!targetName || !targetToHit) continue;

        const isOCLaser = armed ? 0 : (power > powerMax ? 1 : 0);
        const powerDischarge = isOCLaser ? Math.floor(power / 2) : power;
        const totalDamage = powerDischarge + (
            targetDistance <= bonus3 ? 3 :
            targetDistance <= bonus2 ? 2 :
            targetDistance <= bonus1 ? 1 : 0
        );

        weaponNames.push(wpnName);
        damageList.push(totalDamage);

        // Reset weapon state
        const output = {};
        if (!armed) output[`repeating_${section}_${id}_power`] = isOCLaser ? powerDischarge : 0;
        output[`repeating_${section}_${id}_armed`] = 0;
        output[`repeating_${section}_${id}_btn-target_status`] = isOCLaser ? 1 : 0;
        output[`repeating_${section}_${id}_btn-fire_status`] = 0;
        output[`repeating_${section}_${id}_target_name`] = '';
        output[`repeating_${section}_${id}_target_distance`] = 0;
        output[`repeating_${section}_${id}_target_tohit`] = 0;
        await setAttrsAsync(output);
    }   

        // Single roll with all weapons and damages
        startRoll(
            `&{template:custom} {{title=@{banner_${faction}fire${section}} **@{character_name}**}} {{subtitle=Weapons Fired}} {{color=red}} {{Weapons=${weaponNames.join('\\n')}}} {{Target=${targetName}}} {{To-Hit=[[${targetToHit}]] or less}} {{Roll=[[1d10cs>11cf<0]]}} {{Damage=${damageList.join(', ')}}} {{Location=[[1t[DLBasic]]]}}`,
            roll => finishRoll(roll.rollId)
        );
    });

// WEAPON POWER (BEAM) ALLOCATION calculations
on('change:repeating_beams:name change:repeating_beams:damaged change:repeating_beams:power change:repeating_beams:power_max remove:repeating_beams', function(eventInfo) {
    getSectionIDs('repeating_beams', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
            Fieldnames.push(`repeating_beams_${id}_damaged`);
            Fieldnames.push(`repeating_beams_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_beams_${id}_power`);
            Fieldnames.push(`repeating_beams_${id}_power_max`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToBeams = 0;
            const output = {};
            ids.forEach(id => {
                const theBeamIsLaser = values[`repeating_beams_${id}_name`].includes(BEAM_TYPE_LASER_FED);
                const theBeamIsDamaged = parseInt(values[`repeating_beams_${id}_damaged`]) || 0;
                const theBeamIsReady = parseInt(values[`repeating_beams_${id}_btn-fire_status`]) || 0;
                const theBeamPower = parseInt(values[`repeating_beams_${id}_power`]) || 0;
                const theBeamPowerMax = parseInt(values[`repeating_beams_${id}_power_max`]) || 0;
                totalPowerToBeams += theBeamIsDamaged && !theBeamIsReady ? 0 : theBeamPower;

                output[`repeating_beams_${id}_power_status`] = theBeamIsDamaged && !theBeamIsReady == 1 ? 1 : (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) < 0 ? 1 : (theBeamPower > 0 ? 2 : 0);
                output[`repeating_beams_${id}_btn-target_status`] = theBeamPower && !theBeamIsDamaged && (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) > -1 ? 1 : 0;
                output[`repeating_beams_${id}_btn-fire_status`] = theBeamIsReady;
            });
            output['wp_beam'] = totalPowerToBeams;
            setAttrs(output);
        });
    });
});

// WEAPON POWER (MISSILE) ALLOCATION calculations
on('change:repeating_missiles:damaged change:repeating_missiles:armed change:repeating_missiles:cost remove:repeating_missiles', function(eventInfo) {
    getSectionIDs('repeating_missiles', function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_damaged`);
            Fieldnames.push(`repeating_missiles_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_missiles_${id}_armed`);
            Fieldnames.push(`repeating_missiles_${id}_cost`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToMissiles = 0;
            const output = {};
            ids.forEach(id => {
                const theMissileIsDamaged = parseInt(values[`repeating_missiles_${id}_damaged`]) || 0;
                const theMissileIsReady = parseInt(values[`repeating_missiles_${id}_btn-fire_status`]) || 0;
                const theMissilePower = (parseInt(values[`repeating_missiles_${id}_armed`]) || 0) * (parseInt(values[`repeating_missiles_${id}_cost`]) || 0);
                totalPowerToMissiles += theMissileIsDamaged && !theMissileIsReady ? 0 : theMissilePower;

                output[`repeating_missiles_${id}_armed_status`] = theMissileIsDamaged == 1 ? 1 : 0;
                output[`repeating_missiles_${id}_btn-target_status`] = theMissilePower && !theMissileIsDamaged ? 1 : 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = theMissileIsReady;
            });
            output['wp_missile'] = totalPowerToMissiles;
            setAttrs(output);
        });
    });
});

/****************************/
function isRunningOnServer() { return self.dispatchEvent == undefined; }
function setActiveCharacterId(charId){
    var oldAcid=getActiveCharacterId();
    var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
    
    if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
        var ev = new CustomEvent("message");
        ev.data=msg; 
        self.dispatchEvent(ev);
    }else{ //otherwise, use the API (server) message processor, "onmessage"
        self.onmessage({data:msg});
    }
    return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
} 
var _sIn=setInterval;
setInterval=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sIn(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
var _sto=setTimeout
setTimeout=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sto(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
function getAttrsAsync(props){
    var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
    var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
            try{
                getAttrs(props,(values)=>{  resolve(values); }); 
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
    });
}
//use the same pattern for each of the following...
function setAttrsAsync(propObj, options){
    var acid=getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  
            try{
                setAttrs(propObj,options,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

function getSectionIDsAsync(sectionName){
    var acid = getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid = setActiveCharacterId(acid);  
            try{
                getSectionIDs(sectionName,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

</script>

<rolltemplate class="sheet-rolltemplate-custom">
    <div class="sheet-container sheet-color-{{color}}">
      <div class="sheet-header">
        {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
        {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
      </div>

      <div class="sheet-content">
        {{#allprops() title subtitle color Location}}
        <div class="sheet-key">{{key}}</div>
        <div class="sheet-value">{{value}}</div>
        {{/allprops() title subtitle color Location}}

        {{#^rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Hit!</span></div>
        {{#Location}}
            <div class="sheet-key">Location</div>
            <div class="sheet-value">{{Location}}</div>
        {{/Location}}
        {{/^rollGreater() Roll To-Hit}}

        {{#rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Miss!</span></div>
        {{/rollGreater() Roll To-Hit}}

        {{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
      </div>
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-menu">
    <div class="sheet-container sheet-color-{{color}}">
         <div class="sheet-header">
            {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
            {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
        </div>
         <div class="sheet-content">
            {{#allprops() title subtitle desc color}}
                <div class="sheet-key">{{key}}</div>
                <div class="sheet-value">{{value}}</div>
            {{/allprops() title subtitle desc color}}
            {{#desc}}
                <div class="sheet-desc">{{desc}}</div>
            {{/desc}}
        </div>
    </div>
</rolltemplate>