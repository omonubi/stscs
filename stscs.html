<div class='sheet-content'>
    <input type='hidden' class='bridge-hit-status' name='attr_bridge_hit_status' value='0'/>
    <input type='hidden' class='cloak-armed' name='attr_cloak_is_armed' value='0'/>
    <input type='hidden' class='has-sensor-lock' name='attr_has_sensor_lock' value='0'/>
    <input type='hidden' class='movement-grid-status' name='attr_movement_grid_status' value='0'/>
    <input type='hidden' class='sensors-status' name='attr_sensors_status' value='0'/>
    <input type='hidden' class='shields-grid-status' name='attr_shields_grid_status' value='0'/>
    <input type='hidden' class='ship-has-scanned' name='attr_ship_has_scanned' value='0'/>
    <input type='hidden' class='ship-is-cloaked' name='attr_ship_is_cloaked' value='0'/>
    <input type='hidden' class='ship-is-disabled' name='attr_ship-is-disabled' value='0'/>
    <input type='hidden' class='ship-is-evading' name='attr_ship_is_evading' value='0'/>
    <input type="hidden" class="show-cloak-toggle" name="attr_show_cloak" value='0'/>
    <input type='hidden' class='tpa-committed-status' name='attr_tpa_committed_status' value='1'/>
    <input type='hidden' class='transporters-grid-status' name='attr_transporters_grid_status' value='0'/>
    <input type='hidden' class='warp-drive-status' name='attr_warp_drive_status' value='0'/>
    <input type='hidden' class='weapons-grid-status' name='attr_weapons_grid_status' value='0'/>
    <h1>
        <span name='attr_character_name'></span>
        <input type='number' name='attr_current_phase'/>
        <span class='cloak-engaged' style='cursor: default;' title='cloak engaged'> &#x1F977;</span>
        <span class='alert1 disable-ship' title='disabled'> &#x1F198;</span>
        <span class='alert1 warning-bridge-hit' style='cursor: default;' title='bridge hit'> &#x1F527;</span>
        <span class='alert1 warning-sensors' style='cursor: default;' title='sensors offline'> &#x1F9ED;</span>
        <span class='alert1 warning-movement' style='cursor: default;' title='helm offline'> &#x1F6DE;</span>
        <span class='alert1 warning-shields' style='cursor: default;' title='shields offline'> &#x1F6E1;&#xFE0F;</span>
        <span class='alert1 warning-weapons' style='cursor: default;' title='weapons offline'> &#x2694;&#xFE0F;</span>
        <span class='alert1 evade' style='cursor: default;' title='evasive maneuvers'> &#x26A0;&#xFE0F;</span>
    </h1> 
    <input type='hidden' name='attr_tpa_reset' value='0'/>
    <input type='hidden' name='attr_roll20charurl'/>
    <!--------------------------------------------------------> 
    <div class='grid-6col overview-panel'>
        <span class='span2'>
            <span name='attr_class'></span>
            (<span name='attr_type'></span>)
        </span>
        <span class='span2'>
            <label>Size:</label>
            <span name='attr_size'></span>
        </span>
        <span class='span2'>
            <label>D / WDF / CE:</label>
            <input type='number' class='w6' name='attr_defense' min='0' step='.1' value='0'/> /
            <input type='number' class='w6' name='attr_wdf' min='0' step='.1' value='0'/> /
            <span name='attr_ce'>0</span>
        </span>

        <!--<label>Captain:</label>-->
        <button type='roll' class='btn' value='&{template:custom} {{title=**[@{character_name}](@{roll20charurl}@{character_id})**}} {{subtitle=Command Rating Check}} {{color=gold}} {{Captain=@{capname}}} {{Rating=[[@{caprating}]]}} {{Roll=[[d100cf<0cs>101]]}}'>Captain</button>
        <input type='text' class='w12' name='attr_capname' placeholder='name...'/>
        <label>Command Rating:</label>
        <input type='hidden' name='attr_caprating_ta'/>
        <input type='number' name='attr_caprating' min='0'/>   
        <label>Crew Rating:</label>
        <input type='number' name='attr_crewrating' min='0'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Damage Control</h2>

    <div class='grid-6col dc-panel'>
        <button type='action' class='btn critical roll-damage' name='act_rolldamage'>Roll Damage</button>
        <span></span>
        <label><strong>Superstructure:</strong></label>
        <span>
            <input type='hidden' class='hp-status' name='attr_hp_status' value='0'/>
            <input type='number' class='w6 hp' name='attr_hp' value='0'/>
            /
            <span name='attr_hp_max'></span>
        </span>
        <label>Damage Charts:</label>
        <span name='attr_dmg_chart'></span>

        <button type='roll' class='btn' name='roll_rollcrew' value='&{template:custom} {{title=**[@{character_name}](@{roll20charurl}@{character_id})**}} {{subtitle=Crew Efficiency Check}} {{color=gold}} {{Rating=[[@{crewefficiency}]]}} {{Roll=[[d100cf<0cs>101]]}}'>Crew Check</button>
        <span></span>
        <label><strong>Crew:</strong></label>
        <input type='hidden' name='attr_crew-percent' value='100'/>
        <span >
            <input type='hidden' class='crew-status' name='attr_crew_status' value='0'/>
            <input type='number' class='w6 crew' name='attr_crew' value='0' min='0'/> /
            <span name='attr_crew_max'></span>
        </span>
        <label>Crew Efficiency:</label>
        <span>
            <input type='number' name='attr_crewefficiency' readonly/> / 
            <input type='number' name='attr_crewrollpenalty' readonly/>
        </span>

        <input type='hidden' name='attr_crewbonus_saved'/>
        <input type='hidden' name='attr_crewbonus_engineid'/>
        <select class='crew-bonus' name='attr_crewbonus'>
            <option value='0' selected>None</option>
            <option value='1'>Bonus To-Hit</option>
            <option value='2'>Bonus TPA</option>
            <option value='3'>Bonus SPA</option>
            <option value='4'>+1 Superstructure</option>
            <option value='5'>+1 Impulse</option>
            <option value='6'>+1 Warp Engine</option>
        </select>
        <span></span>
        <span>
            <label>TPA: </label>
            <span><span name='attr_tpa-percent'>100</span>%</span>
        </span>
        <span>
            <label>Sup: </label>
            <span><span name='attr_sup-percent'>100</span>%</span>
        </span>
        <span>
            <label>Shields: </label>
            <span><span name='attr_shields-percent'>100</span>%</span>
        </span>
        <span>
            <label>Wpns: </label>
            <span><span name='attr_weapons-percent'>100</span>%</span>
        </span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Engineering
        <input type='hidden' class='crewbonus2' name='attr_crewbonus2' value='0'/>
        <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
    </h2>

    <div class='grid-6col tpa-panel'>
        <button type='action' class='btn' name='act_tpa_reset'>Reset TPA</button>
        <span></span>
        <label><strong>Current TPA:</strong></label> 
        <span><strong><span name='attr_tpa'></span> / <span name='attr_tpa_max'></span></strong></span>
        <label>TPA Unallocated:</label>
        <input type='hidden' class='tpa-remaining-status' name='attr_tpa_remaining_status'/>
        <input type='number' class='tpa-remaining' name='attr_tpa_remaining'  value='0' readonly/>

        <button type='action' class='btn warning' name='act_commit_tpa'>Commit TPA</button>
        <span></span>
        <label>TPA to Movement:</label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA to Warp:</label>
        <input type='number' name='attr_tpa_warp' min='0' value='0' readonly/>

        <button type='action' class='btn energize' name='act_shield_reenergize'>No Repairs</button>
        <span></span>
        <label>TPA to Shields:</label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA to Transporters:</label>
        <input type='number' name='attr_tpa_transporters' min='0' value='0' readonly/>

        <span></span>
        <span></span>
        <label>TPA to Weapons:</label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
        <label class='tpa-cloak'>TPA to Cloak:</label>
        <input type='number' class='tpa-cloak tpa-cloak-warning' name='attr_tpa_cloak' min='0' value='0' readonly/>
    </div>
    <br/>
    
    <div class='grid-6col engines-panel'>    
        <h4 class='span-grid'>Engines</h4>
        <div class='span-grid'>
            <label style='padding-left: 32px;'>Model</label>
            <label style='padding-left: 42px;'>Type</label>
            <label style='padding-left: 70px;'>Location</label>
            <label style='padding-left: 46px;'>Power</label>
            <label style='padding-left: 22px;'>Max</label>
        </div>
        <fieldset class='repeating_engines'>
            <input type='text' class='w10' name='attr_engine_model' placeholder='model...'/>
            <select class='w10' name='attr_engine_type'>
                <option value='0' selected>select...</option>
                <option value='1'>Impulse</option>
                <option value='2'>Warp</option>
            </select>
            <select class='w10' name='attr_engine_location'>
                <option value='0' selected>select...</option>
                <option value='1'>Centerline</option>
                <option value='2'>Port</option>
                <option value='3'>Starboard</option>
            </select>
            <input type='hidden' class='engine-power-status' name='attr_engine_power_status' value='0'/>
            <input type='number' class='w5 engine-power' name='attr_engine_power' min='0' value='0'/> / <input type='number' class='w5' name='attr_engine_power_full' min='0' value='0'/>
        </fieldset>
    </div>
    <br/>
    
    <div class='grid-6col cloak-panel'>
        <label>Cloak Device Type:</label>
        <input type='text' class='w10' name='attr_cloak_type'/>
        <label>Power Required:</label>
        <input type='number' name='attr_tpa_cloak_required' min='0' value='0'/>
        <span><label>Arm Cloak:</label> <input type='checkbox' name='attr_cloak_is_armed' value='1'/></span>
        <button type='action' class='btn gm-only' name='act_scan_cloak' title='DO NOT CLICK'>Scan Me</button>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='sensors-header header-container'>
        <h2>Sensors</h2>
        <span>
            <input type='hidden' name='attr_sensors_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_sensors_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-sensors-repair repair' name='act_sensors_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' class='sensors-destroyed' name='attr_sensors_destroyed' value='0'/>
    <div class='grid-6col sensors-panel'>
        <button type='action' class='btn btn-scan' name='act_scan'>Scan Target</button>
        <button type='roll' class='btn btn-nosensors critical' name='roll_nosensors' value='/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=SENSORS OFFLINE}} {{color=green}}'>Sensors Offline</button>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        
        <span class='span2'>
            <input type='text' class='scan-lock' name='attr_sensorlock' placeholder='No target lock...' readonly/>
        </span>
        <input type='hidden' class='w12' name='attr_sensorlockid'/>
        <span class='span2'>
            <select class='scan-question' name='attr_scanquestion'>
                <option value='0'>Submit a query...</option>
                <!--<option value='1'>How much power is available?</option>-->
                <option value='2'>How is power allocated?</option>
                <option value='3'>How are the shields powered?</option>
                <!--<option value='4'>Is a specific shield up?</option>-->
                <option value='5'>How are the beam weapons powered?</option>
                <option value='6'>How are the missile weapons powered?</option>
                <!--<option value='7'>Is a specific weapon powered?</option>-->
                <option value='8'>How much damage has been taken?</option>
                <option value='9'>What is the status of the crew?</option>
                <!--<option value='10'>Are any transporters powered?</option>-->
                <option value='11'>Is the #1 (f/p) shield powered?</option>
                <option value='12'>Is the #2 (fwd) shield powered?</option>
                <option value='13'>Is the #3 (f/s) shield powered?</option>
                <option value='14'>Is the #4 (a/s) shield powered?</option>
                <option value='15'>Is the #5 (aft) shield powered?</option>
                <option value='16'>Is the #6 (a/p) shield powered?</option>
            </select>
        </span>
        <span class='span2'><input type='text' class='scan-answer' name='attr_scananswer' placeholder='Paste the result here...'/></span>
        
        <button type='action' class='btn gm-only btn-send' name='act_send_alloc' title='DO NOT CLICK'>Alloc</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_beams' title='DO NOT CLICK'>Beams</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_crew' title='DO NOT CLICK'>Crew</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_damage' title='DO NOT CLICK'>Damage</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_missiles' title='DO NOT CLICK'>Missiles</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shields' title='DO NOT CLICK'>Shields</button>

        <button type='action' class='btn gm-only btn-send' name='act_send_shield_1' title='DO NOT CLICK'>Shield 1</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shield_2' title='DO NOT CLICK'>Shield 2</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shield_3' title='DO NOT CLICK'>Shield 3</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shield_4' title='DO NOT CLICK'>Shield 4</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shield_5' title='DO NOT CLICK'>Shield 5</button>
        <button type='action' class='btn gm-only btn-send' name='act_send_shield_6' title='DO NOT CLICK'>Shield 6</button>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='helm-header header-container'>
        <h2>Helm Control</h2>
        <span>
            <input type='hidden' name='attr_movement_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_movement_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-movement-grid-repair repair' name='act_movement_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col helm-panel'>
        <button type='action' class='btn warning btn-stress-turn' name='act_stress_turn'>Stress Turn</button>
        <span></span>
        <label><strong>TPA to Movement:</strong></label>
        <input type='number' class='em' name='attr_tpa_movement' min='0' value='0'/>
        <label>TPA Remaining:</label> 
        <input type='hidden' class='mp-remaining-status' name='attr_mp_remaining_status'/>
        <input type='number' class='mp-remaining' name='attr_mp_remaining' value='0' readonly/>

        <label>Movement Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_mpr_1' min='1' value='1'/>
            /
            <input type='number' class='w5' name='attr_mpr_2' min='1' value='1'/>
        </span>
        <label>Movement Points:</label>
        <span>
            <input type='number' name='attr_mp' readonly/>
            <input type='hidden' class='impulse-power-status' name='attr_impulse_power_status' value='0'/>
            <span class='no-impulse-power' title='no impulse power = max 1'>&#x1F534;</span>
        </span>
        <label>MP by Phase:</label> 
        <input type='hidden' name='attr_ta'/>
        <span>
            <span name='attr_mp1'></span> | <span name='attr_mp2'></span> | <span name='attr_mp3'></span>
        </span>
    </div>
    <br/>

    <div class='grid-6col warp-panel'>
        <input type='hidden' class='warp-show-content' name='attr_warp_show_content' value='1'/>
        <div class='warp-content'>
            <h4>Warp Drive</h4>
            <span></span>
            <span></span>
            <span></span>
            <span></span>
            <span></span>

            <input type='hidden' class='warp-factor-status' name='attr_warp_factor_status' value='0'/>
            <button type='action' class='btn btn-jump' name='act_jump'>Engage Warp Drive</button>
            <span></span>
            <label>TPA to Warp:</label>
            <input type='number' name='attr_tpa_warp' readonly/>
            <span></span>
            <span></span>

            <label>Warp Factor Ratio:</label>
            <input type='hidden' name='attr_wfr_jump'/>
            <input type='hidden' name='attr_wfr_cruise'/>
            <span>
                <input type='number' class='w5' name='attr_wfr_1' value='1' readonly/>
                /
                <input type='number' class='w5' name='attr_wfr_2' value='1' readonly/>
            </span>
            <label>Current Warp Factor:</label>
            <input type='hidden' class='wf-current-status' name='attr_wf_current_status'/>
            <input type='number' class='wf-current' min='0' value='0' name='attr_wf_current' readonly/>
            <label>Desired Warp Factor:</label>
            <input type='hidden' class='wf-desired-status' name='attr_wf_desired_status'/>
            <input type='number' class='em' min='0' value='0' name='attr_wf_desired'/>

            <label>Safe Cruise WF:</label>
            <input type='number' class='w5' name='attr_wf_cruise' min='0' value='0'/>
            <label>Emergency WF:</label>
            <input type='number' class='w5' name='attr_wf_emergency' min='0' value='0'/>
            <label>Stress Charts:</label>
            <span>
                <input type='text' class='w5' name='attr_stress_eng' maxlength='1'/>
                /
                <input type='text' class='w5' name='attr_stress_sup' maxlength='1'/> 
            </span>
        </div>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='shields-header header-container'>
        <h2>Shield Control
            <input type='hidden' class='crewbonus3' name='attr_crewbonus3' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_shields_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shields_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shields-grid-repair repair' name='act_shields_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col shields-panel'>
        <label>Shield Type:</label>
        <input type='text' class='w10' name='attr_shield_type'/>
        <label><strong>TPA to Shields:</strong></label>
        <input type='number' class='em' name='attr_tpa_shields' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='sp-remaining-status' name='attr_sp_remaining_status'/>
        <input type='number' class='sp-remaining' name='attr_sp_remaining' value='0' readonly/>

        <label>Shield Point Ratio: </label>
        <span>
            <input type='number' class='w5' name='attr_spr_1' min='1' max='2' value='1'/>
            /        
            <input type='number' class='w5' name='attr_spr_2' min='1' max='6' value='1'/>
        </span>
        <label>Max Shield Power:</label>
        <input type='number' name='attr_shield_max' min='0' value='0'/>
        <label>SPA Remaining:</label>
        <input type='number' name='attr_sp' readonly/>
    </div>
    <br/>
    <div class='grid-6col spa-panel'>
        <h4 class='span-grid'>Shield Configuration</h4>

        <div class='shields-allocated'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1a-status' name='attr_shield_1a_status'/>
                <input type='number' class='shield-1' name='attr_shield_1' min='0' value='0' title='Shield #1 (f/p)'/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2a-status' name='attr_shield_2a_status'/>
                <input type='number' class='shield-2' name='attr_shield_2' min='0' value='0' title='Shield #2 (fwd)'/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3a-status' name='attr_shield_3a_status'/>
                <input type='number' class='shield-3' name='attr_shield_3' min='0' value='0' title='Shield #3 (f/s)'/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6a-status' name='attr_shield_6a_status'/>
                <input type='number' class='shield-6' name='attr_shield_6' min='0' value='0' title='Shield #6 (a/p)'/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                
                <input type='hidden' class='shield-5a-status' name='attr_shield_5a_status'/>
                <input type='number' class='shield-5' name='attr_shield_5' min='0' value='0' title='Shield #5 (aft)'/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4a-status' name='attr_shield_4a_status'/>
                <input type='number' class='shield-4' name='attr_shield_4' min='0' value='0' title='Shield #4 (a/s)'/>
            </span>
        </div>

        <div class='shields-current'>
            <label>Shield #1 (<strong>f/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-1c-status' name='attr_shield_1c_status'/>
                <input type='number' class='shield-1c' name='attr_shield_1c'/>
            </span>
            <label>Shield #2 (<strong>fwd</strong>):</label>
            <span>
                <input type='hidden' class='shield-2c-status' name='attr_shield_2c_status'/>
                <input type='number' class='shield-2c' name='attr_shield_2c'/>
            </span>
            <label>Shield #3 (<strong>f/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-3c-status' name='attr_shield_3c_status'/>
                <input type='number' class='shield-3c' name='attr_shield_3c'/>
            </span>

            <label>Shield #6 (<strong>a/p</strong>):</label>
            <span>
                <input type='hidden' class='shield-6c-status' name='attr_shield_6c_status'/>
                <input type='number' class='shield-6c' name='attr_shield_6c'/>
            </span>
            <label>Shield #5 (<strong>aft</strong>):</label>
            <span>
                <input type='hidden' class='shield-5c-status' name='attr_shield_5c_status'/>
                <input type='number' class='shield-5c' name='attr_shield_5c'/>
            </span>
            <label>Shield #4 (<strong>a/s</strong>):</label>
            <span>
                <input type='hidden' class='shield-4c-status' name='attr_shield_4c_status'/>
                <input type='number' class='shield-4c' name='attr_shield_4c'/>
            </span>
        </div>
    </div>
    <br/>
    <div class='grid-6col shield-status-panel'>
        <h4 class='span-grid'>Shield Generators Status</h4>

        <label>Shield #1 (<strong>f/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-1-status' name='attr_shield_1_status' value='0'/>
            <input type='hidden' name='attr_shield_1_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_1_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_1_repair'>Repair</button>
        </span>
        <label>Shield #2 (<strong>fwd</strong>):</label>
        <span>
            <input type='hidden' class='shield-2-status' name='attr_shield_2_status' value='0'/>
            <input type='hidden' name='attr_shield_2_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_2_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_2_repair'>Repair</button>
        </span>
        <label>Shield #3 (<strong>f/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-3-status' name='attr_shield_3_status' value='0'/>
            <input type='hidden' name='attr_shield_3_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_3_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_3_repair'>Repair</button>
        </span>

        <label>Shield #6 (<strong>a/p</strong>):</label>
        <span>
            <input type='hidden' class='shield-6-status' name='attr_shield_6_status' value='0'/>
            <input type='hidden' name='attr_shield_6_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_6_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_6_repair'>Repair</button>
        </span>
        <label>Shield #5 (<strong>aft</strong>):</label>
        <span>
            <input type='hidden' class='shield-5-status' name='attr_shield_5_status' value='0'/>
            <input type='hidden' name='attr_shield_5_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_5_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_5_repair'>Repair</button>
        </span>
        <label>Shield #4 (<strong>a/s</strong>):</label>
        <span>
            <input type='hidden' class='shield-4-status' name='attr_shield_4_status' value='0'/>
            <input type='hidden' name='attr_shield_4_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_shield_4_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-shield-repair repair' name='act_shield_4_repair'>Repair</button>
        </span>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='fc-header header-container'>
        <h2>Fire Control
            <input type='hidden' class='crewbonus1' name='attr_crewbonus1' value='0'/>
            <span class='crewbonusicon' title='crew efficiency bonus'>&#x26A1;</span>
        </h2>
        <span>
            <input type='hidden' name='attr_weapons_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_weapons_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-weapons-grid-repair repair' name='act_weapons_grid_repair'>Repair</button>
        </span>
    </span>

    <input type='hidden' name='attr_crewbonustohitapplied' value='0'/>
    <div class='grid-6col fc-panel'>
        <span></span>
        <span></span>
        <label><strong>TPA to Weapons:</strong></label>
        <input type='number' class='em' name='attr_tpa_weapons' min='0' value='0'/>
        <label>TPA Remaining:</label>
        <input type='hidden' class='wp-remaining-status' name='attr_wp_remaining_status'/>
        <input type='number' class='wp-remaining' name='attr_wp_remaining' value='0' readonly/>
    </div>
    <br/>

    
    <div class='grid-6col beams-panel'>
        <h4 class='span-grid'>Beam Weapons</h4>
        <input type='hidden' name='attr_wp_beam'/>
        <div class='span-grid'>
            <label style='padding-left: 45px;'>Desig. (Arcs)</label>
            <label style='padding-left: 30px;'>Range</label>
            <label style='padding-left: 11px;'>Chart</label>
            <label style='padding-left: 10px;'>Pwr</label>
            <label style='padding-left: 21px;'>Max</label>
            <label style='padding-left: 20px;'>+3</label>
            <label style='padding-left: 22px;'>+2</label>
            <label style='padding-left: 22px;'>+1</label>
            <label style='padding-left: 95px;'>Target</label>
            <label style='padding-left: 65px;'>Dist.</label>
            <label style='padding-left: 7px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_beams'>
            <input type='hidden' class='weapon-state-status' name='attr_weapon_state_status' value='0'/>
            <select class='damaged state-select weapon-state' name='attr_state' value='0'>
                <option value='0' selected>N</option>
                <option value='1'>D</option>
                <option value='2'>R</option>
                <option value='3'>X</option>
            </select>
            <input type='text' class='w12' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w3 firing-chart' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='hidden' class='power-status' name='attr_power_status'/>
            <input type='text' class='w3 power' name='attr_power' min='0' max='10' value='0'/> /
            <input type='text' class='w3' name='attr_power_max' min='0' max='10' value='0'/>
            <input type='text' class='w3' name='attr_bonus_3' value='-'/>
            <input type='text' class='w3' name='attr_bonus_2' value='-'/>
            <input type='text' class='w3' name='attr_bonus_1' value='-'/> 
            <span>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='hidden' class='target-tohit-status' name='attr_target_tohit_status'/>
            <input type='text' class='w3 target-tohit' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/> 
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
            <button type='action' class='btn weapon-repair repair' name='act_weapon-repair'>Repair</button>
        </fieldset>
    </div>
    <br/>
        
    <div class='grid-6col missiles-panel'>
        <h4 class='span-grid'>Missile Weapons</h4>
        <input type='hidden' name='attr_wp_missile'/>
        <div class='span-grid'>
            <label style='padding-left: 45px;'>Desig. (Arcs)</label>
            <label style='padding-left: 30px;'>Range</label>
            <label style='padding-left: 10px;'>Chart</label>
            <label style='padding-left: 9px;'>Power</label>
            <label style='padding-left: 4px;'>Damage</label>
            <label style='padding-left: 7px;'>Arm</label>
            <label style='padding-left: 169px;'>Target</label>
            <label style='padding-left: 65px;'>Dist.</label>
            <label style='padding-left: 7px;'>To-Hit</label>
        </div>
        <fieldset class='repeating_missiles'>
            <input type='hidden' class='weapon-state-status' name='attr_weapon_state_status' value='0'/>
            <select class='damaged state-select weapon-state' name='attr_state' value='0'>
                <option value='0' selected>N</option>
                <option value='1'>D</option>
                <option value='2'>R</option>
                <option value='3'>X</option>
            </select>
            <input type='text' class='w12' name='attr_name' placeholder='# Name (arcs)...'/>
            <input type='number' class='w5' name='attr_maxrange'/>
            <select class='w3 firing-chart' name='attr_chart'>
                <option value='0' selected>select...</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
                <option>D</option>
                <option>E</option>
                <option>F</option>
                <option>G</option>
                <option>H</option>
                <option>I</option>
                <option>J</option>
                <option>K</option>
                <option>L</option>
                <option>M</option>
                <option>N</option>
                <option>O</option>
                <option>P</option>
                <option>Q</option>
                <option>R</option>
                <option>S</option>
                <option>T</option>
                <option>U</option>
                <option>V</option>
                <option>W</option>
                <option>X</option>
                <option>Y</option>
            </select>
            <input type='number' name='attr_cost' min='1' value='1'/>
            <input type='number' name='attr_power' min='1' value='1'/>
            <input type='hidden' name='attr_damage'/>
            <input type='hidden' class='missile-armed-status' name='attr_armed_status'/>
            <input type='checkbox' class='missile-armed' style='margin-left: 13px;' value='1' name='attr_armed'/>
            <span style='margin-left: 0px;'>
                <input type='hidden' class='btn-target-status' name='attr_btn-target_status' value='0'/>
                <button type='action' class='btn btn-target' style='margin-left: 87px;' name='act_btn-target'>Target</button>
            </span> →
            <input type='text' class='w10' name='attr_target_name' readonly/>
            <input type='hidden' name='attr_target_id'/>
            <input type='text' class='w3' name='attr_target_distance' value='0' readonly/>
            <input type='hidden' class='target-tohit-status' name='attr_target_tohit_status'/>
            <input type='text' class='w3 target-tohit' name='attr_target_tohit' value='0' readonly/>
            <span>
                <input type='hidden' class='btn-fire-status' name='attr_btn-fire_status' value='0'/>
                <button type='action' class='btn btn-fire critical' name='act_btn-fire'>Fire</button>
            </span>
            <button type='action' class='btn weapon-repair repair' name='act_weapon-repair'>Repair</button>
        </fieldset>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Construction Data</h2> 

    <div class='grid-6col construction-panel'>
        <span class='span2'>
            <select name='attr_faction'>
                <option selected>Select faction...</option>
                <option value='federation'>United Federation of Planets</option>
                <option value='klingon'>Klingon Empire</option>
                <option value='romulan'>Romulan Star Empire</option>
                <option value='independent'>Independent</option>
            </select>
        </span>

        <span class='span2'>
            <input type='text' class='w20' name='attr_class' placeholder='Class...'/>
        </span>

        <label>Type:</label>
        <select class='w16' name='attr_type'>
            <option>Select...</option>
            <option value='BB'>Battleship</option>
            <option value='BC'>Battlecruiser</option>
            <option value='CL'>Cruiser, Light</option>
            <option value='CM'>Cruiser, Missile</option>
            <option value='CR'>Cruiser, Research</option>
            <option value='CS'>Cruiser, Medium</option>
            <option value='CA'>Cruiser, Heavy</option>
            <option value='DD'>Destroyer</option>
            <option value='ES'>Escort</option>
            <option value='FL'>Frigate, Light</option>
            <option value='FS'>Frigate, Medium</option>
            <option value='MN'>Monitor</option>
            <option value='RV'>Research Vessel</option>
            <option value='SC'>Scout</option>
            <option value='TC'>Transport, Commercial</option>
            <option value='TF'>Transport, Freighter</option>
            <option value='TL'>Transport, Light</option>
            <option value='TU'>Transport, Robot</option>
            <option value='ZA'>Administrative Station</option>
            <option value='ZD'>Defensive Outpost</option>
            <option value='ZL'>Listening Post</option>
            <option value='ZO'>Observation Post</option>
        </select>
        <input type='hidden' name='attr_type_is_advanced' value='0'/>
        <input type='hidden' name='attr_type_is_battle' value='0'/>
        <input type='hidden' name='attr_type_is_exploration' value='0'/>
        <input type='hidden' name='attr_type_is_repair' value='0'/>
        <input type='hidden' name='attr_type_is_nonmedical' value='0'/>
        <input type='hidden' name='attr_type_is_anticloak' value='0'/>
        <input type='hidden' name='attr_type_is_command' value='0'/>

        <label>Date Entering Service:</label>
        <input type='text' class='w7' name='attr_date' placeholder='Date...'/>

        <label>Number Constructed:</label>
        <input type='number' class='w7' name='attr_num' min='0'/>

        <label>Control Computer:</label>
        <input type='text' class='w7' name='attr_computer'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Hull Data</h2>
    <div class='grid-6col hull-panel'>
        <label>Superstructure:</label>
        <input type='number' class='w7' name='attr_hp_max' min='0' value='0'/>
        
        <label>Damage Chart:</label>
        <select class='w7' name='attr_dmg_chart'>
            <option value='0' selected>Select...</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
            <option>D</option>
        </select>

        <label>Mass (mt):</label>
        <input type='number' class='w7' name='attr_mass' min='0' value='0'/>

        <label>Length (m):</label>
        <input type='number' class='w7' name='attr_length' min='0' step='0.1'/>

        <label>Width (m):</label>
        <input type='number' class='w7' name='attr_width' min='0' step='0.1'/>
        
        <label>Height (m):</label>
        <input type='number' class='w7' name='attr_height' min='0' step='0.1'/>
        
        <label>Cargo Units (SCU):</label>
        <input type='number' class='w7' name='attr_scu' min='0' value='0'/>

        <label>Cargo Capacity:</label>
        <span name='attr_scu_cap'></span>

        <label>Landing Capability:</label>
        <select class='w7' name='attr_landing_capacity'>
            <option selected>None</option>
            <option>Yes</option>
        </select>

        <label>Crew:</label>
        <input type='number' class='w7' name='attr_crew_max' min='0' value='0'/>
        
        <label>Troops:</label>
        <input type='number' class='w7' name='attr_troops_max' min='0' value='0'/>
        
        <label>Passengers:</label>
        <input type='number' class='w7' name='attr_passengers_max' min='0' value='0'/>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <span class='transporters-header header-container'>
        <h2>Transporters</h2>
        <span>
            <input type='hidden' name='attr_transporters_grid_to_repair' value='0'/>
            <select class='w7 state-select' name='attr_transporters_grid_state' readonly>
                <option value='0' selected>Online</option>
                <option value='1'>Dmg 1-8</option>
                <option value='2'>Dmg 1-6</option>
                <option value='3'>Dmg 1-4</option>
                <option value='4'>Dmg 1-2</option>
                <option value='5'>DEST</option>
            </select>
            <button type='action' class='btn btn-transporters-grid-repair repair' name='act_transporters_grid_repair'>Repair</button>
        </span>
    </span>

    <div class='grid-6col transporter-panel'>
        <span></span>
        <label>Capacity</label>
        <label>Count</label>
        <label>Online</label>
        <label>TPA</label>
        <span></span>

        <label>Standard</label>
        <input type='hidden' class='trans-ison-std' name='attr_trans_ison_std' value='0'/>
        <input type='number' name='attr_trans_cap_std' min='0' value='6' title='# persons'/>
        <input type='number' name='attr_trans_num_std' min='0' value='0'/>
        <input type='number' class='trans-on-std' name='attr_trans_on_std' min='0' value='0'/>
        <input type='number' name='attr_trans_tpa_std' value='0' readonly/>
        <button type='action' class='btn trans-btn-std' name='act_trans_btn_std'>Energize</button>
        
        <label>Combat</label>
        <input type='hidden' class='trans-ison-cbt' name='attr_trans_ison_cbt' value='0'/>
        <input type='number' name='attr_trans_cap_cbt' min='0' value='0' title='# persons'/>
        <input type='number' name='attr_trans_num_cbt' min='0' value='0'/>
        <input type='number' class='trans-on-cbt' name='attr_trans_on_cbt' min='0' value='0'/>
        <input type='number' name='attr_trans_tpa_cbt' value='0' readonly/>
        <button type='action' class='btn trans-btn-cbt' name='act_trans_btn_cbt'>Energize</button>
        
        <label>Emergency</label>
        <input type='hidden' class='trans-ison-er' name='attr_trans_ison_er' value='0'/>
        <input type='number' name='attr_trans_cap_er' min='0' value='0' title='# persons'/>
        <input type='number' name='attr_trans_num_er' min='0' value='0'/>
        <input type='number' class='trans-on-er' name='attr_trans_on_er' min='0' value='0'/>
        <input type='number' name='attr_trans_tpa_er' value='0' readonly/>
        <button type='action' class='btn trans-btn-er' name='act_trans_btn_er'>Energize</button>
        
        <label>Cargo</label>
        <input type='hidden' class='trans-ison-scu' name='attr_trans_ison_scu' value='0'/>
        <input type='number' name='attr_trans_cap_scu' value='1' title='# SCUs' readonly/>
        <input type='number' name='attr_trans_num_scu' min='0' value='0'/>
        <input type='number' class='trans-on-scu' name='attr_trans_on_scu' min='0' value='0'/>
        <input type='number' name='attr_trans_tpa_scu' value='0' readonly/>
        <button type='action' class='btn trans-btn-scu' name='act_trans_btn_scu'>Energize</button>
    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Flight Deck</h2>
    <div class='grid-6col crew-panel'>

        <label>Shuttlecraft:</label>
        <input type='number' class='w7' name='attr_shuttlecraft_max' min='0' value='0'/>

    </div>
    <br/>

    <!-------------------------------------------------------->
    <h2>Maintenance</h2>
    <div class='grid-6col maint-panel'>
        <p class='span-grid'><strong>Do not use these controls during battle!</strong></p>
        <button type='action' class='btn' name='act_repair'>Repair/Reset Vessel</button>
        <span></span>
        <span>
            <input type="checkbox" name="attr_show_cloak" value='1'/><label>Has Cloak</label>
        </span>
        <span></span>
        <span>
            <input type="checkbox" name="attr_dark_mode" class="dark-mode-toggle" value='1'/><label>Dark Mode</label>
        </span>
    </div>

<!-- Banner placeholders (see readme) -->
<input type='hidden' name='attr_banner_federationfirebeams' value='[x](https://files.d20.io/images/459374797/BrLK7l69a5n4Mfomy8M4GA/original.png)'/>
<input type='hidden' name='attr_banner_federationfiremissiles' value='[x](https://files.d20.io/images/461676845/PIWNmdJhQ8DotQAYJS7Eew/original.png)'/>
<input type='hidden' name='attr_banner_federationwarp' value='[x](https://files.d20.io/images/461519720/yapt5OaNN9fy0m-b2HhVaQ/original.png)'/>
<input type='hidden' name='attr_banner_klingonfirebeams' value='[x](https://files.d20.io/images/461674377/cX_DbSv-iBzHRa8XCK36uw/original.png)'/>
<input type='hidden' name='attr_banner_klingonfiremissiles' value='[x](https://files.d20.io/images/459155112/hNZ9AQX33_kJr7InoxYVbA/original.png)'/>
<input type='hidden' name='attr_banner_klingonwarp' value='[x](https://files.d20.io/images/461677914/LFn_ncPFcBHm_yHjz6xr9A/original.png)'/>
<input type='hidden' name='attr_banner_romulanfirebeams' value='[x](https://files.d20.io/images/472921906/Ye7aWGEDnt2N6KbVSmm8cQ/original.png)'/>
<input type='hidden' name='attr_banner_romulanfiremissiles' value='[x](https://files.d20.io/images/472921905/8OmveOp3rHpys9iZgQJ6hw/original.png)'/>
<input type='hidden' name='attr_banner_romulanwarp' value='[x](https://files.d20.io/images/472921908/GUYIW3R_IRQUzDG5wuB1FA/original.png)'/>

<script type='text/worker'>
const COMMAND_RATING_BONUS = 5;
const COMMAND_RATING_LIMIT = 99;
const CREW_BONUS_WEAPONS = 1;
const CREW_BONUS_ENGINES = 2;
const CREW_BONUS_SHIELD = 3;
const CREW_BONUS_REPAIR = 4;const DAMAGE_CHART_DEFAULT = `C`;
const CREW_RATING_LIMIT = 99;
const DAMAGE_BLOCK_SIZE = 5;
const DAMAGE_RESULT_BEAM = `Beam Weapon`;
const DAMAGE_RESULT_BRIDGE = `Bridge 2C`;
const DAMAGE_RESULT_ENG = `Engineering 2C`;
const DAMAGE_RESULT_IMP = `Impulse`;
const DAMAGE_RESULT_IMP_HALF = `Impulse (x1/2)`;
const DAMAGE_RESULT_MISSILE = `Missile Weapon`;
const DAMAGE_RESULT_PORT = `PWE`;
const DAMAGE_RESULT_PORT_HALF = `PWE (x1/2)`;
const DAMAGE_RESULT_SENSORS = `Sensors`;
const DAMAGE_RESULT_SHIELD = `Shield Gen`;
const DAMAGE_RESULT_STBD = `SWE`;
const DAMAGE_RESULT_STBD_HALF = `SWE (x1/2)`;
const DAMAGE_RESULT_SUP = `Sup 2C`;
const DAMAGE_RESULT_SUP_HALF = `Sup C (x1/2)`;
const DAMAGE_RESULT_SUP_PORT = `PWE/Sup C (x1/2)`;
const DAMAGE_RESULT_SUP_STBD = `SWE/Sup C (x1/2)`;
const DAMAGE_RESULT_WARP = `Any WE`;
const DAMAGE_STATUSES = [`Online`, `Dmg 1-8`, `Dmg 1-6`, `Dmg 1-4`, `Dmg 1-2`, `DEST`];
const ENGINE_LOCATION_PORT = `2`;
const ENGINE_LOCATION_STBD = `3`;
const ENGINE_TYPE_IMPULSE = 1;
const ENGINE_TYPE_WARP = 2;
const ENGINE_TYPE_GENERATOR = 3;
const ENGINE_WARP_NAME_NONE = `No Warp Drive`;
const WEAPON_IS_UNDAMAGED = 0;
const WEAPON_IS_DAMAGED = 1;
const WEAPON_IS_REPAIRED = 2;
const WEAPON_IS_DESTROYED = 3;
const REPAIR_IS_LOCKED = 9;
const ROLL20_CHAR_URL = `https://journal.roll20.net/character/`;    

// ON SHEET OPENED
on(`sheet:opened`,function(){
    getAttrs([`character_name`, `sup-percent`, `tpa-percent`, `shields-percent`, `weapons-percent`, `crew-percent`], function(values) {
        const charactername = values[`character_name`];
        const supPercent = parseInt(values[`sup-percent`]) || -1;
        const tpaPercent = parseInt(values[`tpa-percent`]) || -1;
        const shieldsPercent = parseInt(values[`shields-percent`]) || -1;
        const weaponsPercent = parseInt(values[`weapons-percent`]) || -1;
        const crewPercent = parseInt(values[`crew-percent`]) || -1;
        
        const output = {};

        const SEARCH_STR = "Copy of";
        if (charactername.includes(SEARCH_STR)) {
            output[`caprating`] = 45 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
            output[`crewrating`] = output[`crewefficiency`] = 25 + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10) + getRandomIntInclusive(1,10);
        }
        output[`roll20charurl`] = ROLL20_CHAR_URL;

        output[`sup-percent`] = supPercent == -1 ? 100 : supPercent;
        output[`tpa-percent`] = tpaPercent == -1 ? 100 : tpaPercent;
        output[`shields-percent`] = shieldsPercent == -1 ? 100 : shieldsPercent;
        output[`weapons-percent`] = weaponsPercent == -1 ? 100 : weaponsPercent;
        output[`crew-percent`] = crewPercent == -1 ? 100 : crewPercent;
        output[`wfr_1`] = 1;

        setAttrs(output);
    });
});

// Async function to return a querystring value
const extractChatData = async (query) => {
    query = await startRoll(`!{{target=[[0[response=${query}]]]}}`);
    finishRoll(query.rollId);
    return query.results.target.expression.replace(/0\[response=(.+?)\]/,`$1`);
};

// Async function to return a token name and its character id 
const extractTargetData = async () => {
    const query = await startRoll(`!{{target=[[0+{"tokenName":"@{target|Target|token_name}","charId":"@{target|Target|character_id}","isCloaked":"@{target|Target|ship_is_cloaked}"}]]}} /direct`);
    finishRoll(query.rollId);
    const expr = query.results.target.expression;
    const jsonStr = expr.replace(/0\+\{(.+)\}/, `{$1}`);
    return JSON.parse(jsonStr);
};

// Roll a random number from MIN to MAX
function getRandomIntInclusive(min, max) {
  const minCeiled = Math.ceil(min);
  const maxFloored = Math.floor(max);
  return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);
}

// Format large numbers with commas
function formatNumber(value) {
    value = value.replace(/\D/g, ``);
    return value.replace(/\B(?=(\d{3})+(?!\d))/g, `,`);
}

// CAPTAIN RATING change
on(`change:caprating`, function(eventInfo) {
    getAttrs([`caprating`, `type_is_command`], function(values) {
        const caprating = parseInt(values[`caprating`]);
        const typeIsCommand = parseInt(values[`type_is_command`]);

        const output = {};
        const capratingTA = Math.min(COMMAND_RATING_LIMIT, (caprating + (typeIsCommand * COMMAND_RATING_BONUS))) * 100;
        output[`caprating_ta`] = capratingTA;
        setAttrs(output);
    });
});

// CLOAK ARMED/DISARMED
on(`change:tpa_cloak_required change:cloak_is_armed`, function(eventInfo) {
    getAttrs([`tpa_cloak_required`], function(values) {
        const cloakIsOn = parseInt(eventInfo.newValue) || 0;
        const tpaRequired = parseInt(values[`tpa_cloak_required`]) || 0;

        const output = {};
        output[`tpa_cloak`] = cloakIsOn ? tpaRequired : 0;
        setAttrs(output);
    });
});

// CARGO CAPACITY calculation
on(`change:scu`, function(eventInfo) {
    getAttrs([`scu`], function(values) {
        const scu = parseInt(values[`scu`]) || 0;

        const scuCapacity = formatNumber(String(scu * 50));

        const output = {};
        output[`scu_cap`] = `${scuCapacity} mt`;
        setAttrs(output);
    });
});

// COMBAT EFFICIENCY calculation
on(`change:defense change:wdf`, function(eventInfo) {
    getAttrs([`defense`, `wdf`], function(values) {
        const defense = parseFloat(values[`defense`]) || 0;
        const wpnDmgFactor = parseFloat(values[`wdf`]) || 0;

        const combatEfficiency = parseFloat((defense * wpnDmgFactor / 100).toFixed(2));

        const output = {};
        output[`ce`] = combatEfficiency;
        setAttrs(output);
    });
});

// CREW BONUS selection
on(`change:crewbonus`, async function(eventInfo) {
    try {
        const values = await getAttrsAsync([`crewbonus`, `hp`, `hp_max`, `crewbonus_saved`, `crewbonus_engineid`]);
        const crewBonus = parseInt(values[`crewbonus`]) || 0;
        const output = {};

        // Save crewBonus value to crewbonus_saved
        output[`crewbonus_saved`] = crewBonus;

        // Reset crewbonus1, crewbonus2, crewbonus3 to 0 (skip crewbonus4)
        output[`crewbonus1`] = output[`crewbonus2`] = output[`crewbonus3`] = 0;

        // If crewBonus is less than 4, set the corresponding crewbonus field to 1
        if (crewBonus < 4) {
            output[`crewbonus${crewBonus}`] = 1;
        }

        // If crewBonus = 4, increase hp by 1 (no higher than hp_max)
        if (crewBonus === 4) {
            const currentHp = parseInt(values[`hp`]) || 0;
            const maxHp = parseInt(values[`hp_max`]) || 0;
            if (currentHp == maxHp) output[`crewbonus_saved`] = 0; // Don't save if there's no hp dmg
            output[`hp`] = Math.min(currentHp + 1, maxHp);
        }

        // If crewbonus_saved = 4, decrease hp by 1 (can go below zero)
        if (parseInt(values[`crewbonus_saved`]) === 4) {
            const currentHp = parseInt(values[`hp`]) || 0;
            output[`hp`] = currentHp - 1;
        }

        // If crewBonus = 5, add +1 to the Impulse engine with lowest power
        if (crewBonus === 5) {
            const engineIds = await getSectionIDsAsync(`repeating_engines`);
            let lowestPower = Infinity;
            let lowestEngineId = null;

            // Find Impulse engine with lowest power
            for (const engineId of engineIds) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${engineId}_engine_type`,
                    `repeating_engines_${engineId}_engine_power`,
                    `repeating_engines_${engineId}_engine_power_full`
                ]);

                const engineType = parseInt(engineValues[`repeating_engines_${engineId}_engine_type`]) || 0;
                const enginePower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                const enginePowerFull = parseInt(engineValues[`repeating_engines_${engineId}_engine_power_full`]) || 0;

                if (engineType === 1 && enginePower < lowestPower && enginePower < enginePowerFull) {
                    lowestPower = enginePower;
                    lowestEngineId = engineId;
                }
            }

            // Increase power of lowest Impulse engine
            if (lowestEngineId) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${lowestEngineId}_engine_power`,
                    `repeating_engines_${lowestEngineId}_engine_power_full`
                ]);
                const currentPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power`]) || 0;
                const maxPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power_full`]) || 0;

                output[`repeating_engines_${lowestEngineId}_engine_power`] = Math.min(currentPower + 1, maxPower);
                output[`crewbonus_engineid`] = lowestEngineId;
            }
        }

        // If crewbonus_saved = 5, subtract 1 from previously modified Impulse engine
        if (parseInt(values[`crewbonus_saved`]) === 5) {
            const engineId = values[`crewbonus_engineid`];
            if (engineId) {
                const engineValues = await getAttrsAsync([`repeating_engines_${engineId}_engine_power`]);
                const currentPower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                output[`repeating_engines_${engineId}_engine_power`] = Math.max(currentPower - 1, 0);
            }
        }

        // If crewBonus = 6, add +1 to the Warp engine with lowest power
        if (crewBonus === 6) {
            const engineIds = await getSectionIDsAsync(`repeating_engines`);
            let lowestPower = Infinity;
            let lowestEngineId = null;

            // Find Warp engine with lowest power
            for (const engineId of engineIds) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${engineId}_engine_type`,
                    `repeating_engines_${engineId}_engine_power`,
                    `repeating_engines_${engineId}_engine_power_full`
                ]);

                const engineType = parseInt(engineValues[`repeating_engines_${engineId}_engine_type`]) || 0;
                const enginePower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                const enginePowerFull = parseInt(engineValues[`repeating_engines_${engineId}_engine_power_full`]) || 0;

                if (engineType === ENGINE_TYPE_WARP && enginePower < lowestPower && enginePower < enginePowerFull) {
                    lowestPower = enginePower;
                    lowestEngineId = engineId;
                }
            }

            // Increase power of lowest Warp engine
            if (lowestEngineId) {
                const engineValues = await getAttrsAsync([
                    `repeating_engines_${lowestEngineId}_engine_power`,
                    `repeating_engines_${lowestEngineId}_engine_power_full`
                ]);
                const currentPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power`]) || 0;
                const maxPower = parseInt(engineValues[`repeating_engines_${lowestEngineId}_engine_power_full`]) || 0;

                output[`repeating_engines_${lowestEngineId}_engine_power`] = Math.min(currentPower + 1, maxPower);
                output[`crewbonus_engineid`] = lowestEngineId;
            }
        }

        // If crewbonus_saved = 6, subtract 1 from previously modified Warp engine
        if (parseInt(values[`crewbonus_saved`]) === 6) {
            const engineId = values[`crewbonus_engineid`];
            if (engineId) {
                const engineValues = await getAttrsAsync([`repeating_engines_${engineId}_engine_power`]);
                const currentPower = parseInt(engineValues[`repeating_engines_${engineId}_engine_power`]) || 0;
                output[`repeating_engines_${engineId}_engine_power`] = Math.max(currentPower - 1, 0);
            }
        }

        await setAttrsAsync(output);
    } catch (error) {
        console.error(`Error in crewbonus handler:`, error);
    }
});

// CREW calculation
on(`change:crew change:crew_max`, function(eventInfo) {
    getAttrs([`crew`, `crew_max`], function(values) {
        const crew = parseInt(values[`crew`]) || 0;
        const crewMax = parseInt(values[`crew_max`]) || 0;

        const output = {};
        output[`crew-percent`] = Math.max(0, crew / crewMax * 100);
        output[`crew_status`] = crew <= (crewMax * .4) || crew > crewMax ? 1 : crew <= crewMax * .8 ? 2 : 0;
        setAttrs(output);
    });
});

// CREW EFFICIENCY calculation
on(`change:crewrating change:crew-percent`, function(eventInfo) {
    getAttrs([`crewrating`, `crew-percent`], function(values) {
        const crewRating = parseInt(values[`crewrating`]) || 0;
        const crewPercent = values[`crew-percent`] || `0`;
        const crewCasualties = 100 - crewPercent;

        const casualtyBrackets = [20, 40, 60, 70, 100];
        const rollPenalties = [0, -1, -2, -5, -10];
        const efficiencyModifiers = [0, 10, 20, 50, 50];

        let i = 0;
        while (crewCasualties >= casualtyBrackets[i]) i++;

        const output = {};
        output[`crewefficiency`] = Math.max(0, crewRating - efficiencyModifiers[i]);
        output[`crewrollpenalty`] = rollPenalties[i];
        setAttrs(output);
    });
});

// DAMAGE roll
on(`clicked:rolldamage`, async () => {
    const shieldArcStr = await extractChatData(`?{Shield Arc|#1 (f/p)|#2 (fwd)|#3 (f/s)|#4 (a/s)|#5 (aft)|#6 (a/p)}`);
    const baseDamage = +await extractChatData(`?{Damage|0}`);
  
    const shieldArc = shieldArcStr.substring(1,2);
    const shieldVar = `shield_${shieldArc}c`;
    const values = await getAttrsAsync([`dmg_chart`]);
    const damageChart = values[`dmg_chart`] || DAMAGE_CHART_DEFAULT;

    const damageResults = [
        13, 16, 6, 6, 3, 8, 1, 2, 14, 12,
        13, 16, 17, 6, 3, 7, 1, 4, 14, 12,
        13, 16, 7, 7, 4, 9, 1, 2, 14, 12,
        13, 16, 7, 7, 9, 11, 1, 2, 2, 2,
        13, 16, 17, 2, 2, 10, 1, 2, 5, 15,
        13, 16, 6, 6, 8, 11, 1, 2, 2, 2,

        13, 16, 6, 6, 3, 8, 1, 2, 14, 12,
        13, 16, 17, 2, 2, 2, 1, 5, 14, 12,
        13, 16, 7, 7, 4, 9, 1, 2, 14, 12,
        13, 16, 7, 7, 4, 11, 1, 2, 2, 9,
        13, 16, 17, 6, 7, 10, 1, 2, 2, 15,
        13, 16, 6, 6, 3, 11, 1, 2, 2, 8,

        13, 16, 6, 3, 2, 2, 1, 8, 14, 12, 
        13, 16, 17, 2, 2, 2, 1, 5, 14, 12,
        13, 16, 7, 4, 2, 2, 1, 9, 14, 12,
        13, 16, 7, 7, 4, 11, 1, 2, 2, 9,
        13, 16, 17, 6, 3, 10, 1, 7, 4, 15,
        13, 16, 6, 6, 3, 11, 1, 2, 2, 8,

        13, 16, 17, 11, 15, 2, 1, 14, 12,
        13, 16, 17, 11, 15, 2, 1, 14, 12,
        13, 16, 17, 11, 15, 2, 1, 14, 12,
        13, 16, 17, 11, 15, 2, 1, 14, 12,
        13, 16, 17, 11, 15, 2, 1, 14, 12,
        13, 16, 17, 11, 15, 2, 1, 14, 12
    ];

    //13, 16, 6, 3, 2, 2, 1, 8, 14, 12,

    let residualDamage = 0;
    let penetratingDamage = 0;
    let returnStr = ``;
    let rollStr = `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=&#x1F494; Damage Results (Chart ${damageChart}) &#x1F494;}} {{color=red}} {{Incoming Dmg=${baseDamage}}} {{On Shield Arc=${shieldArcStr}}} `;

    const hitRollResult = getRandomIntInclusive(0, 9);
    const hitLocation = ((damageChart.charCodeAt(0) - 65) * 60) + ((shieldArc - 1) * 10) + hitRollResult;
    
    const damageHandlers = {
        1: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(penetratingDamage);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage, 2);
                result += crewReturn;
            }
            return result;
        },
        2: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_HALF}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(penetratingDamage, 0.5);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(Math.floor(penetratingDamage / 2));
                result += crewReturn;
            }
            return result;
        },
        3: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_PORT}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_PORT);
            }
            return result;
            },
        4: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_STBD}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, ENGINE_LOCATION_STBD);
            }
            return result;
        },
        5: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_WARP}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(penetratingDamage, null);
            }
            return result;
        },
        6: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_PORT_HALF}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(Math.floor(penetratingDamage / 2), ENGINE_LOCATION_PORT);
            }
            return result;
        },
        7: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_STBD_HALF}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                result += await handleWarpDamage(Math.floor(penetratingDamage / 2), ENGINE_LOCATION_STBD);
            }
            return result;
        },
        8: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_PORT}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                let { residualDamage, returnStr: warpReturn } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_PORT);
                result += warpReturn;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
                        penetratingDamageSup += residualDamage;
                    } else {
                        let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                        result += residualReturn;
                    }
                }
                result += warpReturn;
                let { residualDamage: supResidual, returnStr: supReturn } = await damageSup(penetratingDamageSup, 0.5);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(Math.floor(penetratingDamageSup / 2));
                result += crewReturn;
            }
            return result;
        },
        9: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SUP_STBD}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let penetratingDamageEng = Math.ceil(penetratingDamage / 2);
                let penetratingDamageSup = Math.floor(penetratingDamage / 2);
                let { residualDamage, returnStr: warpReturn } = await damageWarp(penetratingDamageEng, ENGINE_LOCATION_STBD);
                result += warpReturn;
                if (residualDamage) {
                    if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
                        penetratingDamageSup += residualDamage;
                    } else {
                        let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                        result += residualReturn;
                    }
                }
                result += warpReturn;
                let { residualDamage: supResidual, returnStr: supReturn } = await damageSup(penetratingDamageSup, 0.5);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(Math.floor(penetratingDamageSup / 2));
                result += crewReturn;
            }
            return result;
        },
        10: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_IMP}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: impulseReturn } = await damageImpulse(penetratingDamage);
                result += impulseReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        11: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_IMP_HALF}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: impulseReturn } = await damageImpulse(penetratingDamage, 0.5);
                result += impulseReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        12: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_BRIDGE}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: supReturn } = await damageSup(1);
                result += supReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage, 2, true);
                result += crewReturn;
                result += `{{No Repairs=(This Phase)}}`;
                const output = {};
                output[`bridge_hit_status`] = 1;
                setAttrs(output);
            }
            return result;
        },
        13: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SHIELD}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`shield_${shieldArc}`, penetratingDamage);
                result += systemReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        14: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_SENSORS}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`sensors`, penetratingDamage);
                await undoSensorLock();
                result += systemReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        15: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_ENG}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                const gridNames = [`Shields`, `Weapons`, `Movement`];
                const randomGrid = getRandomIntInclusive(0, 2);
                result += ` {{Grid=${gridNames[randomGrid]}}}`;
                let { residualDamage, returnStr: systemReturn } = await damageSystem(`${gridNames[randomGrid].toLowerCase()}_grid`, penetratingDamage);
                result += systemReturn;
                let { residualDamage: crewResidual, returnStr: crewReturn } = await damageCrew(penetratingDamage, 2, true);
                result += crewReturn;
            }
            return result;
        },
        16: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_BEAM}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: weaponReturn } = await damageWeapon(shieldArc, `repeating_beams`, penetratingDamage);
                result += weaponReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        },
        17: async (shieldVar, baseDamage) => {
            let result = `{{Hit Location=${DAMAGE_RESULT_MISSILE}}} `;
            let { penetratingDamage, returnStr } = await damageShield(shieldVar, baseDamage);
            result += returnStr;
            if (penetratingDamage) {
                let { residualDamage, returnStr: weaponReturn } = await damageWeapon(shieldArc, `repeating_missiles`, penetratingDamage);
                result += weaponReturn;
                if (residualDamage) {
                    let { residualDamage: residualResidual, returnStr: residualReturn } = await damageResidual(residualDamage);
                    result += residualReturn;
                }
            }
            return result;
        }
    };

    const hitResult = damageResults[hitLocation];
    rollStr += await damageHandlers[hitResult]?.(shieldVar, baseDamage) || ``;

    await startRoll(
        rollStr,
        roll => finishRoll(roll.rollId)
    );
});

async function handleWarpDamage(penetratingDamage, engineLocation) {
    let result = ``;
    const { residualDamage, returnStr } = await damageWarp(penetratingDamage, engineLocation);
    result += returnStr;
    if (residualDamage) {
        if (returnStr.includes(ENGINE_WARP_NAME_NONE)) {
            result += (await damageSup(residualDamage)).returnStr;
        } else {
            result += (await damageResidual(residualDamage, 0.5)).returnStr;
        }
    }
    return result;
}

// DAMAGE CREW
async function damageCrew(myDmg, myFactor = 1, isCritArea = false) {
    const values = await getAttrsAsync([`crew`, `crew_max`, `crewefficiency`, `hp_max`, `type_is_nonmedical`]);
    const crew = parseInt(values[`crew`]) || 0;
    const crewEfficiency = parseInt(values[`crewefficiency`]) || 0;
    const maxSup = parseInt(values[`hp_max`]) || 0;
    const NON_MEDICAL_PENALTY = 5;
    const typeIsNonMedical = parseInt(values[`type_is_nonmedical`]) || 0;
    const typeIsNonMedicalStr = typeIsNonMedical ? `{{Type Penalty=-${NON_MEDICAL_PENALTY}%}}` : ``;

    const supIntervals = [0, 1, 2, 3, 4, 5, 6, 8, 11, 14, 19, 34, 50, 999];
    const percentsLost = [0, 100, 50, 30, 25, 20, 18, 14, 10, 8, 6, 4, 2, 1];

    // Determine percentage bracket based on max sup
    let index = -1;
    do {
        index++;
    }
    while (maxSup > supIntervals[index])

    // Determine amount of crew lost
    const crewRoll = getRandomIntInclusive(1, 100);
    const isCrewEffective = crewRoll <= (crewEfficiency - typeIsNonMedical * NON_MEDICAL_PENALTY);
    const CREW_MAX_DMG = 5;
    const BRIDGE_CAP = 20;
    const percentLost = Math.min((isCritArea == true) ? BRIDGE_CAP : 100, percentsLost[index] * Math.min(CREW_MAX_DMG, myDmg) * myFactor / (isCrewEffective ? 2 : 1));
    const crewLost = Math.ceil(crew * percentLost / 100);
    const newCrew = Math.max(0, crew - crewLost);

    const output = {};
    output[`crew`] = newCrew;
    await setAttrsAsync(output);
    
    const CREW_EFFECTIVE_TRUE = `Success!`;
    const CREW_EFFECTIVE_FALSE = `Failed`;
    const residualDamage = 0;
    const returnStr = ` {{Crew Check=${isCrewEffective ? CREW_EFFECTIVE_TRUE : CREW_EFFECTIVE_FALSE}}} ${typeIsNonMedicalStr} {{Crew Lost=[[${crewLost}]]}}`;
    return { residualDamage, returnStr };
}

// DAMAGE IMPULSE ENGINE
async function damageImpulse(myDmg = 0, myFactor = 1) {
    const ids = await getSectionIDsAsync(`repeating_engines`);
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let enginePower = -1;
    let targetId = null;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
            enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            targetId = id;
        }
    });

    let residualDamage = myDmg;

    const damage = Math.floor(myDmg * myFactor);
    const newEnginePower = Math.max(0, enginePower - damage);
    residualDamage = Math.max(0, damage - enginePower);
    
    output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
    await setAttrsAsync(output);
    const returnStr = ` {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;

    return { residualDamage, returnStr };
}

// DAMAGE SHIELD
// Note: This is damage to the shield value, NOT the shield generator (see damageSystem).
async function damageShield(myShieldVar = ``, myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync([myShieldVar]);
    const shieldPower = parseInt(values[myShieldVar]) || 0;

    const shieldPowerRemaining = Math.max(0, shieldPower - Math.floor(myDmg * myFactor));
    const myDmgAbsorbed = shieldPower - shieldPowerRemaining;
    const penetratingDamage = Math.max(0, Math.floor(myDmg * myFactor) - shieldPower);

    const output = {};
    output[myShieldVar] = shieldPowerRemaining;
    await setAttrsAsync(output);

    const returnStr = ` {{Shield Strength=${shieldPower}}} {{Absorbed=${myDmgAbsorbed}}} {{Penetrating Dmg=[[${penetratingDamage}]]}}`;
    return { penetratingDamage, returnStr };
}

// DAMAGE SYSTEM
// Includes shield generators, sensors, and all three power grids.
// Does NOT include weapons (see damageWeapon)
async function damageSystem(mySystemVar = ``, myDmg = 0) {
    const BestToRepair = 10; // The max to-repair target value
    const MaxSystemState = 5; // The max State value for a damaged system (Destroyed)
    const StateIncrement = 1; // The amount to increment the next chance to-repair
    const SystemIsDestroyed = 2; // The system is Destroyed
    const ToRepairImprovement = 2; // The improvement to the next chance to-repair

    const values = await getAttrsAsync([`${mySystemVar}_state`]);
    const systemState = parseInt(values[`${mySystemVar}_state`]) || 0;
    const heavyDamage = Math.floor(Math.max(0, (myDmg - DAMAGE_BLOCK_SIZE)) / DAMAGE_BLOCK_SIZE);

    const systemStateNew = Math.min(MaxSystemState, systemState + StateIncrement + heavyDamage);
    const myDmgResidual = (systemState + StateIncrement + heavyDamage) - systemStateNew; // Excess heavy dmg not applied

    const output = {};
    output[`${mySystemVar}_state`] = systemStateNew;
    output[`${mySystemVar}_status`] = systemStateNew == MaxSystemState ? SystemIsDestroyed : REPAIR_IS_LOCKED;
    output[`${mySystemVar}_to_repair`] = BestToRepair - (systemStateNew * ToRepairImprovement);
    if (mySystemVar == `shields_grid`) output[`shield_1c`] = output[`shield_2c`] = output[`shield_3c`] = output[`shield_4c`] = output[`shield_5c`] = output[`shield_6c`] = 0;
    await setAttrsAsync(output);

    const residualDamage = systemStateNew == systemState ? myDmg : (myDmgResidual * DAMAGE_BLOCK_SIZE) + (Math.max(0, (myDmg - DAMAGE_BLOCK_SIZE)) % DAMAGE_BLOCK_SIZE); // HOUSE RULE: Apply all remainder dmg to resid
    const returnStr = ` {{Damage Status=${DAMAGE_STATUSES[systemStateNew]}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE
async function damageSup(myDmg = 0, myFactor = 1) {
    const values = await getAttrsAsync([`hp`]);
    const oldSup = parseInt(values[`hp`]) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output[`hp`] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure=${oldSup}}} {{Sup Damage=[[${supDamage}]]}} {{Sup Remaining=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE SUPERSTRUCTURE (RESIDUAL)
async function damageResidual(myDmg = 0, myFactor = 0.5) {
    const values = await getAttrsAsync([`hp`]);
    const oldSup = parseInt(values[`hp`]) || 0;
    const newSup = oldSup - Math.floor(myDmg * myFactor);
    const supDamage = oldSup - newSup;

    const output = {};
    output[`hp`] = newSup;
    await setAttrsAsync(output);

    const residualDamage = 0;
    const returnStr = ` {{Superstructure (R)=${oldSup}}} {{Sup Damage (R)=[[${supDamage}]]}} {{Sup Remaining (R)=${newSup}}}`;
    return { residualDamage, returnStr };
}

// DAMAGE WARP ENGINE
async function damageWarp(myDmg = 0, myLocation = 1, myFactor = 1) {
    const ids = await getSectionIDsAsync(`repeating_engines`);

    const ENGINE_WARP_NAME_CNTR = `CWE`;
    const ENGINE_WARP_NAME_PORT = `PWE`;
    const ENGINE_WARP_NAME_STBD = `SWE`;

    const engineLocations = [
        ENGINE_WARP_NAME_NONE, 
        ENGINE_WARP_NAME_CNTR, 
        ENGINE_WARP_NAME_PORT, 
        ENGINE_WARP_NAME_STBD
        ];

    if (myLocation === 1) myLocation = getRandomIntInclusive(2, 3); // pick an engine
    
    const Fieldnames = [];
    ids.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
        Fieldnames.push(`repeating_engines_${id}_engine_location`);
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
    });
    
    const values = await getAttrsAsync(Fieldnames);
    const output = {};
    
    let actualLocation = -1;
    let enginePower = -1;
    let targetId = null;
    let foundAtLocation = false;
    
    ids.forEach(id => {
        if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP && !foundAtLocation) {
            actualLocation = parseInt(values[`repeating_engines_${id}_engine_location`]) || 0;
            if (actualLocation == myLocation) {
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                targetId = id;
                foundAtLocation = true;
            } else {
                targetId = id;
                enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
            }
        }
    });

    let residualDamage = myDmg;
    let returnStr = ` {{Actual Location=${engineLocations[0]}}}`;

    if (enginePower > -1 && targetId) {
        const damage = Math.floor(myDmg * myFactor);
        const newEnginePower = Math.max(0, enginePower - damage);
        residualDamage = Math.max(0, damage - enginePower);
        
        output[`repeating_engines_${targetId}_engine_power`] = newEnginePower;
        await setAttrsAsync(output);
        returnStr = ` {{Actual Location=${engineLocations[actualLocation]}}} {{Power Available=${enginePower}}} {{Engine Damage=[[${enginePower - newEnginePower}]]}} {{Power Remaining=${newEnginePower}}}`;
    }

    return { residualDamage, returnStr };
}

// DAMAGE WEAPON
async function damageWeapon(myShieldNum = 1, myRepeatingSection = ``, myDmg = 0) {
    const WeaponCannotBeRepaired = 0; // The weapon is Destroyed and cannot be repaired.

    // Validate that a repeating section was provided
    if (!myRepeatingSection) {
        return { residualDamage: myDmg, returnStr: `{{Weapon Damaged=Error: No section}} ` };
    }
    
    // Get all IDs for the specified repeating section
    const weaponIds = await getSectionIDsAsync(myRepeatingSection);
    
    // Count the number of weapon items
    const weaponCount = weaponIds.length;
    
    // Build array of attribute names to retrieve
    const attrNames = [];
    weaponIds.forEach(id => {
        attrNames.push(`${myRepeatingSection}_${id}_name`);
        attrNames.push(`${myRepeatingSection}_${id}_state`);
    });
    
    // Get all attributes at once
    const attrs = await getAttrsAsync(attrNames);
    
    // Build array of weapon objects with name and state
    const weapons = weaponIds.map(id => ({
        id: id,
        name: attrs[`${myRepeatingSection}_${id}_name`] || ``,
        state: attrs[`${myRepeatingSection}_${id}_state`] || `0`
    }));
    
    // Map shield number to arc letters
    const shieldArcs = {
        1: `fp`,  // f/p
        2: `f`,   // f
        3: `fs`,  // f/s
        4: `as`,  // a/s
        5: `a`,   // a
        6: `ap`   // a/p
    };
    
    // Map shield number to numeric convention (1-3)
    const shieldNumerics = {
        1: `1`,
        2: `1`,
        3: `2`,
        4: `2`,
        5: `3`,
        6: `3`
    };
    
    // Get the arc letters for this shield
    const arcLetters = shieldArcs[myShieldNum] || ``;
    const numericValue = shieldNumerics[myShieldNum] || ``;
    
    // Build regex to match either arc letters OR numeric value within parentheses
    const arcPattern = new RegExp(`\\([^)]*[${arcLetters}][^)]*\\)|\\([^)]*${numericValue}[^)]*\\)`, `i`);
    
    // Count weapons that match the shield arc
    const matchingWeapons = weapons.filter(weapon => arcPattern.test(weapon.name));
    const matchingCount = matchingWeapons.length;
    
    // Filter matching weapons to only include those with state 0 or 2
    const eligibleWeapons = matchingWeapons.filter(weapon => weapon.state == 0 || weapon.state == 2);
    const eligibleCount = eligibleWeapons.length;
    
    let residualDamage = myDmg;
    let returnStr = ``;
    
    // If no eligible weapons, return residual damage
    if (eligibleCount === 0) {
        return { residualDamage: myDmg, returnStr: `{{Weapon Damaged=None Available}} ` };
    }
    
    // If there are eligible weapons, select one randomly and damage it
    if (eligibleCount > 0) {
        const randomIndex = getRandomIntInclusive(1, eligibleCount) - 1;
        const selectedWeapon = eligibleWeapons[randomIndex];

        // Get all matching banked weapons or default to single weapon
        const wpnBankName = selectedWeapon.name.match(/#\d+\w+/);
        const bankedRows = [];
        if (wpnBankName) {
            const nameRoot = selectedWeapon.name.match(/#\d+/);
            const ids = await getSectionIDsAsync(`${myRepeatingSection}`);
            const fieldnames = ids.flatMap(id => [
                `${myRepeatingSection}_${id}_name`,
                `${myRepeatingSection}_${id}_state`
            ]);
            const values = await getAttrsAsync(fieldnames);

            // Find the selected weapon's ID first
            const selectedWeaponId = eligibleWeapons[randomIndex].id;
            const selectedState = values[`${myRepeatingSection}_${selectedWeaponId}_state`];
            if (selectedState != WEAPON_IS_DAMAGED && selectedState != WEAPON_IS_DESTROYED) {
                bankedRows.push(selectedWeaponId);
            }

            // Then add remaining matches
            ids.forEach(id => {
                const name = values[`${myRepeatingSection}_${id}_name`];
                const state = values[`${myRepeatingSection}_${id}_state`];
                if (name && name.match(nameRoot) && id !== selectedWeaponId && state != WEAPON_IS_DAMAGED && state != WEAPON_IS_DESTROYED) {
                    bankedRows.push(id);
                }
            });
        } else {
            // Not in a bank — damage just this weapon
            bankedRows.push(eligibleWeapons[randomIndex].id);
        }

        let bankedNames = [];
        for (const id of bankedRows) {
            const rowAttrs = await getAttrsAsync([
                `${myRepeatingSection}_${id}_name`,
                `${myRepeatingSection}_${id}_state`
            ]);
        
            // Update state
            let newState = parseInt(rowAttrs[`${myRepeatingSection}_${id}_state`]) || 0;
            if (newState == WEAPON_IS_UNDAMAGED) {
                newState = WEAPON_IS_DAMAGED;
            } else if (newState == WEAPON_IS_REPAIRED) {
                newState = WEAPON_IS_DESTROYED;
            }
            
            // Update the attribute in Roll20
            const updateObj = {};
            updateObj[`${myRepeatingSection}_${id}_state`] = newState;
            updateObj[`${myRepeatingSection}_${id}_weapon_state_status`] = REPAIR_IS_LOCKED;
            await setAttrsAsync(updateObj);
            
            bankedNames.push(rowAttrs[`${myRepeatingSection}_${id}_name`]);

            residualDamage = Math.max(0, residualDamage - DAMAGE_BLOCK_SIZE);
            if (residualDamage < DAMAGE_BLOCK_SIZE) break;
        }
        returnStr = `{{Weapon Damaged=${bankedNames.join(`\\n`)}}} `;
    } else {
        returnStr = `{{Weapon Damaged=None Available}} `;
    }

    await updateWeaponsPercent();
    
    return { residualDamage, returnStr, weaponCount, weapons, matchingCount, matchingWeapons, eligibleCount, eligibleWeapons };
}

// IMPULSE POWER status indicator
on(`change:repeating_engines:engine_power`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_IMPULSE) {
                    const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                    totalPower += enginePower;
                }
            });
            output[`impulse_power_status`] = totalPower == 0 ? 1 : 0;
            setAttrs(output);
        });
    });
});

// MOVEMENT POINTS AVAILABLE calculation
on(`change:tpa_movement change:mpr_1 change:mpr_2 change:impulse_power_status`, function(eventInfo) {
    getAttrs([`tpa_movement`, `mpr_1`, `mpr_2`, `impulse_power_status`], function(values) {
        const power = parseInt(values[`tpa_movement`]) || 0;
        const mpr = (parseInt(values[`mpr_1`]) || 1) / (parseInt(values[`mpr_2`]) || 1);
        const impulsePowerStatus = parseInt(values[`impulse_power_status`]) || 0;

        const mp = !impulsePowerStatus ? Math.floor(power / mpr) : 0;
        const mpPhase1 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 1
        const mpPhase2 = Math.floor(mp / 3) + (mp % 3 == 1 ? 1 : 0); // phase 2
        const mpPhase3 = Math.floor(mp / 3) + Math.floor((mp % 3) / 2); // phase 3
        const powerUnused = power % mpr;

        const output = {};
        output[`mp`] = mp;
        output[`ta`] = mp * 10000;
        output[`mp1`] = mpPhase1;
        output[`mp2`] = mpPhase2;
        output[`mp3`] = mpPhase3;
        output[`mp_remaining`] = powerUnused;
        output[`mp_remaining_status`] = power != 0 && (powerUnused < 0 ? 1 : (powerUnused > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// REPAIR SYSTEM
on(`clicked:movement_grid_repair`, function(eventInfo) { repairSystem(`movement_grid`, `Movement Grid`); });
on(`clicked:sensors_repair`, function(eventInfo) { repairSystem(`sensors`, `Sensors`); });
on(`clicked:shield_1_repair`, function(eventInfo) { repairSystem(`shield_1`, `Shield #1 (f/p)`); });
on(`clicked:shield_2_repair`, function(eventInfo) { repairSystem(`shield_2`, `Shield #2 (fwd)`); });
on(`clicked:shield_3_repair`, function(eventInfo) { repairSystem(`shield_3`, `Shield #3 (f/s)`); });
on(`clicked:shield_4_repair`, function(eventInfo) { repairSystem(`shield_4`, `Shield #4 (a/s)`); });
on(`clicked:shield_5_repair`, function(eventInfo) { repairSystem(`shield_5`, `Shield #5 (aft)`); });
on(`clicked:shield_6_repair`, function(eventInfo) { repairSystem(`shield_6`, `Shield #6 (a/p)`); });
on(`clicked:shields_grid_repair`, function(eventInfo) { repairSystem(`shields_grid`, `Shields Grid`); energizeShields()});
on(`clicked:weapons_grid_repair`, function(eventInfo) { repairSystem(`weapons_grid`, `Weapons Grid`); });
function repairSystem(mySystemVar = ``, mySystemName = ``) {
    getAttrs([`${mySystemVar}_to_repair`, `crewrollpenalty`, `type_is_repair`], function(values) {
        const repairTargetBase = parseInt(values[`${mySystemVar}_to_repair`]) || 0;
        const crewRollPenalty = parseInt(values[`crewrollpenalty`]) || 0;
        const typeIsRepair = parseInt(values[`type_is_repair`]) || 0;
        let repairTargetNew = repairTargetBase;
        const repairTarget = repairTargetBase + typeIsRepair + crewRollPenalty;
        const typeIsRepairStr = typeIsRepair ? `{{Type Bonus=+1}}` : ``;

        const output = {};
        const repairRoll = getRandomIntInclusive(1, 10);
        if (repairRoll <= repairTarget) {
            output[`${mySystemVar}_state`] = 0;
            output[`${mySystemVar}_status`] = 0;
            repairTargetNew = 0;
        } else {
            repairTargetNew = repairTargetBase + 1;
        }

        output[`${mySystemVar}_to_repair`] = repairTargetNew;
        setAttrs(output);

        energizeShields();
        releaseLockedRepairStatuses();

        startRoll(
            `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=&#x1F527; Repair Roll &#x1F527;}} {{color=gold}} {{System=${mySystemName}}} {{Base Target=${repairTargetBase}}} {{Crew Penalty=${crewRollPenalty}}} ${typeIsRepairStr} {{To-Repair=[[${repairTarget}]]}} {{Roll=[[${repairRoll}]]}}`,
            roll => finishRoll(roll.rollId)
        );
    });
};

// REPAIR WEAPON
on(`clicked:repeating_beams:weapon-repair clicked:repeating_missiles:weapon-repair`, async function(event) {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attrs = await getAttrsAsync([
        `${row}_name`,
        `${row}_power`,
        `${row}_power_max`,
        `${row}_state`,
        `${row}_weapon_state_status`,
        `crewrollpenalty`, 
        `type_is_repair`
    ]);

    const wpnName = attrs[`${row}_name`];
    const beamPower = attrs[`${row}_power`];
    const beamPowerMax = attrs[`${row}_power_max`];
    const currentState = attrs[`${row}_state`];
    const repairTargetBase = section === `beams` ? 8 : 6;
    const crewRollPenalty = parseInt(attrs[`crewrollpenalty`]) || 0;
    const typeIsRepair = parseInt(attrs[`type_is_repair`]) || 0;
    const repairTarget = repairTargetBase + typeIsRepair + crewRollPenalty;
    const typeIsRepairStr = typeIsRepair ? `{{Type Bonus=+1}}` : ``;

    const repairRoll = getRandomIntInclusive(1, 10);
    if (repairRoll <= repairTarget) {
        // If state is 1, change it to 2 and set weapon_state_status to 2
        if (currentState == 1) {
            const updateObj = {};
            updateObj[`${row}_state`] = 2;
            updateObj[`${row}_weapon_state_status`] = 2;

            if (section == 'beams') updateObj[`${row}_power`] = Math.min(beamPower, Math.floor(beamPowerMax / 2));

            await setAttrsAsync(updateObj);

            await updateWeaponsPercent();
        }
    }
    
    energizeShields();
    releaseLockedRepairStatuses();

    startRoll(
        `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Repair Roll}} {{color=gold}} {{Weapon=${wpnName}}} {{Base Target=${repairTargetBase} (${section})}} {{Crew Penalty=${crewRollPenalty}}} ${typeIsRepairStr} {{To-Repair=[[${repairTarget}]]}} {{Roll=[[${repairRoll}]]}}`,
        roll => finishRoll(roll.rollId)
    );
});

// REPAIR and RESET after combat
on(`clicked:repair`, async function(eventInfo) {

    const response = await extractChatData(`?{Confirm Repair and TPA Reset|Confirm|Cancel}`);

    if (response === `Confirm`) {
        // Repair engines
        getSectionIDs(`repeating_engines`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_engines_${id}_engine_power`] = values[`repeating_engines_${id}_engine_power_full`];
                });
                setAttrs(output);
            });
        });

        // Repair beam weapons
        getSectionIDs(`repeating_beams`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_beams_${id}_state`);
                Fieldnames.push(`repeating_beams_${id}_weapon_state_status`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_beams_${id}_state`] = 0;
                    output[`repeating_beams_${id}_weapon_state_status`] = 0;
                });
                setAttrs(output);
            });
        });

        // Repair missile weapons
        getSectionIDs(`repeating_missiles`, function (ids) {
            const Fieldnames = [];
            ids.forEach(id => {
                Fieldnames.push(`repeating_missiles_${id}_state`);
                Fieldnames.push(`repeating_missiles_${id}_weapon_state_status`);
            });
            
            getAttrs([...Fieldnames], function (values) {
                const output = {};
                ids.forEach(id => {
                    output[`repeating_missiles_${id}_state`] = 0;
                    output[`repeating_missiles_${id}_weapon_state_status`] = 0;
                });
                setAttrs(output);
            });
        });

        // Other vars
        getAttrs([`hp_max`, `crew_max`], function(values) {
            const hpMax = parseInt(values[`hp_max`]) || 0;
            const crewMax = parseInt(values[`crew_max`]) || 0;

            const output = {};
            output[`hp`] = hpMax;
            output[`crew`] = crewMax;
            output[`wf_current`] = output[`wf_desired`] = output[`warp_drive_status`] = 0;
            output[`ship_is_cloaked`] = 0;
            output[`shield_1_state`] = output[`shield_1_status`] = output[`shield_1_to_repair`] = 0;
            output[`shield_2_state`] = output[`shield_2_status`] = output[`shield_2_to_repair`] = 0;
            output[`shield_3_state`] = output[`shield_3_status`] = output[`shield_3_to_repair`] = 0;
            output[`shield_4_state`] = output[`shield_4_status`] = output[`shield_4_to_repair`] = 0;
            output[`shield_5_state`] = output[`shield_5_status`] = output[`shield_5_to_repair`] = 0;
            output[`shield_6_state`] = output[`shield_6_status`] = output[`shield_6_to_repair`] = 0;
            output[`sensors_state`] = output[`sensors_status`] = output[`sensors_to_repair`] = output[`sensors_destroyed`] = 0;
            output[`shields_grid_state`] = output[`shields_grid_status`] = output[`shields_grid_to_repair`] = output[`shields_grid_destroyed`] = 0;
            output[`weapons_grid_state`] = output[`weapons_grid_status`] = output[`weapons_grid_to_repair`] = output[`weapons_grid_destroyed`] = 0;
            output[`movement_grid_state`] = output[`movement_grid_status`] = output[`movement_grid_to_repair`] = output[`movement_grid_destroyed`] = 0;
            output[`bridge_hit_status`] = 0;
            output[`ship_is_evading`] = 0;
            setAttrs(output);
        });
        await undoSensorLock();
        await updateWeaponsPercent();
        resetTPA();
    }
});

// SENSOR SCAN
on(`clicked:scan`, async (event) => {
    const SensorsAreStandard = `Standard`;
    const SensorsAreExploration = `Exploration`;
    const SensorsAreAdvanced = `Advanced`;
    const attrs = await getAttrsAsync([`sensorlock`]);
    const oldLock = String(attrs.sensorlock) || ``;
    let response = 0;

    if (oldLock != ``) response = await extractChatData(`?{Release Current Lock|Confirm,1|Cancel,0}`);
    
    if (oldLock == `` || response == 1) {
        const output = {};
        await undoSensorLock();
        const { tokenName, charId, isCloaked } = await extractTargetData(); // Destructure JSON

        const attrs = await getAttrsAsync([`type_is_advanced`, `type_is_exploration`]);
        const toScanTarget = attrs[`type_is_advanced`] == 1 ? 8 : attrs[`type_is_exploration`] == 1 ? 7 : 6;
        const scanTypeStr = attrs[`type_is_advanced`] == 1 ? SensorsAreAdvanced : attrs[`type_is_exploration`] == 1 ? SensorsAreExploration : SensorsAreStandard;
        const scanRoll = getRandomIntInclusive(1, 10);

        startRoll(
            `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Scan}} {{color=green}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{Sensor Type=${scanTypeStr}}} {{To-Scan=[[${toScanTarget}]]}} {{Roll=[[${scanRoll}]]}}`,
            roll => finishRoll(roll.rollId)
        );

        if (scanRoll <= toScanTarget) {
            output[`sensorlock`] = tokenName;
            output[`sensorlockid`] = charId;
            output[`has_sensor_lock`] = 1;
        }

        output[`ship_has_scanned`] = 1;
        await setAttrsAsync(output);
    }
}); 
async function undoSensorLock() {
    const output = {};
    output[`sensorlock`] = output[`sensorlockid`] = ``;
    output[`scanquestion`] = output[`scananswer`] = ``;
    output[`has_sensor_lock`] = 0;
    await setAttrsAsync(output);
}

// SENSOR SCAN Q&A
on(`change:scanquestion`, function(eventInfo) {
    if (eventInfo.sourceType == "player") {
        getAttrs([`sensorlock`, `sensorlockid`, `scanquestion`], function(values) {
            const sensorLock = values[`sensorlock`];
            const sensorLockId = values[`sensorlockid`];
            const questionIndex = parseInt(values[`scanquestion`]) || 0;

            const questions = [
                ``,
                `How much power is available?`,
                `How is power allocated?`,
                `How are the shields powered?`,
                `Is a specific shield up?`,
                `How are the beam weapons powered?`,
                `How are the missile weapons powered?`,
                `Is a specific weapon powered?`,
                `How much damage has been taken?`,
                `What is the status of the crew?`,
                `Are any transporters powered?`,
                `Is the #1 (f/p) shield powered?`,
                `Is the #2 (f) shield powered?`,
                `Is the #3 (f/s) shield powered?`,
                `Is the #4 (a/s) shield powered?`,
                `Is the #5 (a) shield powered?`,
                `Is the #6 (a/p) shield powered?`
                ];

            startRoll(`/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Sensor Query}} {{color=green}} {{Target=[${sensorLock}](${ROLL20_CHAR_URL}${sensorLockId})}} {{Query=${questions[questionIndex]}}}`, roll => {
                finishRoll(roll.rollId);
            });

            const output = {};
            output[`ship_has_scanned`] = 1;
            setAttrs(output);
        });
    }
});

// SENSORS SEND ALLOCATION
on(`clicked:send_alloc`, async (event) => {
    const values = await getAttrsAsync([`tpa_movement`, `tpa_warp`, `tpa_shields`, `tpa_weapons`, `tpa_transporters`]);
    
    // Get the TPA variable values
    const tpaVars = {
        'Movement': parseInt(values[`tpa_movement`]) || 0,
        'Warp': parseInt(values[`tpa_warp`]) || 0,
        'Shields': parseInt(values[`tpa_shields`]) || 0,
        'Weapons': parseInt(values[`tpa_weapons`]) || 0,
        'Transporters': parseInt(values[`tpa_transporters`]) || 0
    };
    
    // Filter out zero values and create array of [name, value] pairs
    const filtered = Object.entries(tpaVars).filter(([name, val]) => val > 0);

    // Check if filtered array is empty
    let priorityString = ``;
    if (filtered.length === 0) {
        priorityString += `{{Priority=No Power Allocated}} `;
    } else {
        // Sort by value descending
        filtered.sort((a, b) => {
            return b [1] - a [1]; // Sort by value descending
        });
        
        // Build priority string by grouping equal values
        let currentPriority = 1;
        let i = 0;
        
        while (i < filtered.length) {
            const currentValue = filtered[i][1];
            const group = [filtered[i][0]]; // Only include the name, not the value
            
            // Collect all variables with the same value
            while (i + 1 < filtered.length && filtered[i + 1] [1] === currentValue) {
                i++;
                group.push(filtered[i][0]); // Only include the name, not the value
            }
            
            priorityString += `{{${currentPriority}:=${group.join('/')}}} `;
            currentPriority++;
            i++;
        }
    }
    
    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Allocation**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${priorityString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND BEAMS
on(`clicked:send_beams`, async (event) => {    
    // Get all repeating_beams section IDs
    const beamIds = await getSectionIDsAsync('repeating_beams');
    
    // Get power values for all beams
    const powerAttrs = beamIds.map(id => `repeating_beams_${id}_power`);
    const beamData = await getAttrsAsync(powerAttrs);
    
    // Count beams with power > 0 and total power
    let weaponCount = 0;
    let totalPower = 0;
    
    beamIds.forEach(id => {
        const power = parseInt(beamData[`repeating_beams_${id}_power`]) || 0;
        if (power > 0) {
            weaponCount++;
            totalPower += power;
        }
    });
    
    // Build result string with weapon count and power totals
    const rollString = `{{Beams:=${weaponCount}}} {{TPA:=${totalPower}}}`;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Beams**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${rollString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND CLOAK
on(`clicked:scan_cloak`, async (event) => {  
    const scannedArc = await extractChatData(`?{Shield Arc|#1 (f/p)|#2 (fwd)|#3 (f/s)|#4 (a/s)|#5 (aft)|#6 (a/p)}`);
    const scanTargetExists = parseInt(+await extractChatData(`?{Am I There?|No,0|Yes,1}`) || 0);
    
    if(scanTargetExists) {
        const range = parseInt(+await extractChatData(`?{Range|30}`) || 0);
        const isDestroyer = parseInt(+await extractChatData(`?{Is Destroyer|No,0|Yes,1}`) || 0);

        const values = await getAttrsAsync(['ship_has_scanned']); // Has the cloaked vessel used scanners?
        const shipHasScanned = parseInt(values['ship_has_scanned'] || 0);
        const numWarpEngines = await getNumWarpEngines();

        const roll = getRandomIntInclusive(1,10);
        const result = Math.max(roll - isDestroyer, 0); // DDs get +1 on roll
    console.log('Scanning for cloaked vessels at range: ' + range);
    console.log('Roll target: ' + (Math.ceil((31-range)/10) + shipHasScanned + (numWarpEngines - 2)));
    console.log('Roll result: ' + result);
        if (result <= (Math.ceil((31-range)/10) + shipHasScanned + (numWarpEngines - 2))) {
            const isDestroyerStr = isDestroyer ? `{{DD Bonus=Yes}}` : ``;
            startRoll(
                `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Cloak**}} {{color=green}} {{Arc Scanned=${scannedArc}}} {{Results=Vessel Detected!}} {{At Range=${range}}} ${isDestroyerStr}`,
                roll => finishRoll(roll.rollId)
            );             
        } else {
            cloakedShipNotFound(scannedArc);
        }
    } else {
        cloakedShipNotFound(scannedArc);
    }
});
async function cloakedShipNotFound(scannedArc) {
    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Cloak**}} {{color=green}} {{Arc Scanned=${scannedArc}}} {{Results=Nothing Detected}}`,
        roll => finishRoll(roll.rollId)
    );
}

// SENSORS SEND CREW
on(`clicked:send_crew`, async (event) => {    
    // Get the status variables
    const statusData = await getAttrsAsync([
        'crew-percent'
    ]);
    
    // Extract values with defaults to 0
    const crew = statusData['crew-percent'] || 0;
    
    // Build roll string with status values
    const statusString = `{{Crew:=${crew}%}}`;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Crew**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${statusString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND DAMAGE
on(`clicked:send_damage`, async (event) => {    
    // Get the status variables
    const statusData = await getAttrsAsync([
        'sup-percent',
        'tpa-percent',
        'shields-percent',
        'weapons-percent'
    ]);
    
    // Extract values with defaults to 0
    const superstructure = statusData['sup-percent'] || 0;
    const tpa = statusData['tpa-percent'] || 0;
    const shields = statusData['shields-percent'] || 0;
    const weapons = statusData['weapons-percent'] || 0;
    
    // Build roll string with status values
    const statusString = `{{Sup:=${superstructure}%}} {{TPA:=${tpa}%}} {{Shlds:=${shields}%}} {{Wpns:=${weapons}%}}`;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Damage**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${statusString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND MISSILES
on(`clicked:send_missiles`, async (event) => {    
    // Get all repeating_missiles section IDs
    const missileIds = await getSectionIDsAsync('repeating_missiles');
    
    // Get power and armed status for all missiles
    const powerAttrs = missileIds.map(id => `repeating_missiles_${id}_cost`);
    const armedAttrs = missileIds.map(id => `repeating_missiles_${id}_armed`);
    
    const missileData = await getAttrsAsync([...powerAttrs, ...armedAttrs]);
    
    // Count missiles with power > 0 and armed = 1, and total power
    let weaponCount = 0;
    let totalPower = 0;
    
    missileIds.forEach(id => {
        const power = parseInt(missileData[`repeating_missiles_${id}_cost`]) || 0;
        const armed = parseInt(missileData[`repeating_missiles_${id}_armed`]) || 0;
        
        if (power > 0 && armed === 1) {
            weaponCount++;
            totalPower += power;
        }
    });
    
    // Build result string with weapon count and power totals
    const rollString = `{{Missiles:=${weaponCount}}} {{Power:=${totalPower}}}`;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Missiles**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${rollString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND SHIELD X
on(`clicked:send_shield_1 clicked:send_shield_2 clicked:send_shield_3 clicked:send_shield_4 clicked:send_shield_5 clicked:send_shield_6`, async (event) => {

    // Extract the shield number from the event's triggerName (e.g., "clicked:send_shield_3" -> "3")
    const shieldNum = event.triggerName.match(/\d+/);
    
    // Get the shield status attribute for this shield number
    const attrs = await getAttrsAsync([`shield_${shieldNum}c`]);
    const shieldIsUp = attrs[`shield_${shieldNum}c`] > 0 || 0;
    
    const shieldIsUpStr = shieldIsUp ? `Yes` : `No`;
    const shieldStr = `{{Answer=${shieldIsUpStr}}} `;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Shield ${shieldNum}**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${shieldStr} `,
        roll => finishRoll(roll.rollId)
    );
});

// SENSORS SEND SHIELDS
on(`clicked:send_shields`, async (event) => {
    // Fetch shield and SPR values
    const shieldVars = await getAttrsAsync(['shield_1c', 'shield_2c', 'shield_3c', 'shield_4c', 'shield_5c', 'shield_6c', 'spr_1', 'spr_2']);
    
    // Count shields with value > 0
    const shieldsPowered = ['shield_1c', 'shield_2c', 'shield_3c', 'shield_4c', 'shield_5c', 'shield_6c']
        .filter(shield => parseInt(shieldVars[shield]) > 0)
        .length;
    
    // Sum total power allocated
    const powerAllocated = ['shield_1c', 'shield_2c', 'shield_3c', 'shield_4c', 'shield_5c', 'shield_6c']
        .reduce((sum, shield) => sum + parseInt(shieldVars[shield] || 0), 0);
    
    // Format SPR as "spr_1/spr_2"
    const sprValue = `${shieldVars.spr_1}/${shieldVars.spr_2}`;
    
    // Build the shields string
    const shieldsString = `{{Shields:=${shieldsPowered}}} {{Points:=${powerAllocated}}} {{SPR:=${sprValue}}}`;

    startRoll(
        `/w "@{target|character_name}" &{template:custom} {{title=**Scan Results: Shields**}} {{subtitle=[@{character_name}](${ROLL20_CHAR_URL}@{character_id})}} {{color=green}} ${shieldsString}`,
        roll => finishRoll(roll.rollId)
    );
});

// SHIELD POINTS calculation
on(`change:tpa_shields change:spr_1 change:spr_2 change:shield_1 change:shield_2 change:shield_3 change:shield_4 change:shield_5 change:shield_6 change:crewbonus3`, function(eventInfo) {
    getAttrs([`tpa_shields`, `spr_1`, `spr_2`, `shield_1`, `shield_2`, `shield_3`, `shield_4`, `shield_5`, `shield_6`, `crewbonus`], function(values) {
        const power = parseInt(values[`tpa_shields`]) || 0;
        const spr = (parseInt(values[`spr_1`]) || 1) / (parseInt(values[`spr_2`]) || 1);
        const shield1 = parseInt(values[`shield_1`]) || 0;
        const shield2 = parseInt(values[`shield_2`]) || 0;
        const shield3 = parseInt(values[`shield_3`]) || 0;
        const shield4 = parseInt(values[`shield_4`]) || 0;
        const shield5 = parseInt(values[`shield_5`]) || 0;
        const shield6 = parseInt(values[`shield_6`]) || 0;
        const crewBonus = parseInt(values[`crewbonus`]) || 0;

        const totalPower = power + (crewBonus == CREW_BONUS_SHIELD ? 1 : 0);
        const sp = Math.floor(totalPower / spr - shield1 - shield2 - shield3 - shield4 - shield5 - shield6);
        const powerRemaining = Math.round(totalPower - shield1 * spr - shield2 * spr - shield3 * spr - shield4 * spr - shield5 * spr - shield6 * spr);

        const output = {};
        output[`sp`] = sp;
        output[`sp_remaining`] = powerRemaining;
        output[`sp_remaining_status`] = (power != 0 || powerRemaining != 0) && (powerRemaining < 0 ? 1 : (powerRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// SHIELD POINTS ALLOCATED status indicators
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num} change:shield_${num}_state change:shield_max`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}_state`, `shield_max`], function(values) {
            const shieldSP = parseInt(values[`shield_${num}`]) || 0;
            const shieldIsDamaged = parseInt(values[`shield_${num}_state`]) || 0;
            const shieldSPMax = parseInt(values[`shield_max`]) || 0;

            const output = {};
            output[`shield_${num}a_status`] = shieldSP > shieldSPMax || shieldIsDamaged ? 1 : shieldSP == 0 ? 2 : 0;
            output[`shield_${num}c`] = shieldIsDamaged ? 0 : shieldSP;
            setAttrs(output);
        });
    });
});

// SHIELD POINTS CURRENT status indicators
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num}c`, function(eventInfo) {
        getAttrs([`shield_${num}`, `shield_${num}c`], function(values) {
            const shieldSPAllocated = parseInt(values[`shield_${num}`]) || 0;
            const shieldSPCurrent = parseInt(values[`shield_${num}c`]) || 0;

            const output = {};
            output[`shield_${num}c_status`] = shieldSPCurrent > shieldSPAllocated || shieldSPCurrent == 0 ? 1 : shieldSPCurrent == shieldSPAllocated ? 0 : 2;
            setAttrs(output);
        });
    });
});

// SHIELDS RE-ENERGIZED
on(`clicked:shield_reenergize`, function(eventInfo) {
    energizeShields();
    releaseLockedRepairStatuses();

    startRoll(
        `/w gm &{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=No Repairs}} {{color=gold}}`,
        roll => finishRoll(roll.rollId)
    );
});
function energizeShields() {
    getAttrs([`shield_1`, `shield_2`, `shield_3`, `shield_4`, `shield_5`, `shield_6`, `shield_1_state`, `shield_2_state`, `shield_3_state`, `shield_4_state`, `shield_5_state`, `shield_6_state`], function(values) {
        const shield1Allocation = parseInt(values[`shield_1`]) || 0;
        const shield2Allocation = parseInt(values[`shield_2`]) || 0;
        const shield3Allocation = parseInt(values[`shield_3`]) || 0;
        const shield4Allocation = parseInt(values[`shield_4`]) || 0;
        const shield5Allocation = parseInt(values[`shield_5`]) || 0;
        const shield6Allocation = parseInt(values[`shield_6`]) || 0;
        const shield1IsDamaged = parseInt(values[`shield_1_state`]) || 0;
        const shield2IsDamaged = parseInt(values[`shield_2_state`]) || 0;
        const shield3IsDamaged = parseInt(values[`shield_3_state`]) || 0;
        const shield4IsDamaged = parseInt(values[`shield_4_state`]) || 0;
        const shield5IsDamaged = parseInt(values[`shield_5_state`]) || 0;
        const shield6IsDamaged = parseInt(values[`shield_6_state`]) || 0;

        const output = {};
        output[`shield_1c`] = shield1IsDamaged ? 0 : shield1Allocation;
        output[`shield_2c`] = shield2IsDamaged ? 0 : shield2Allocation;
        output[`shield_3c`] = shield3IsDamaged ? 0 : shield3Allocation;
        output[`shield_4c`] = shield4IsDamaged ? 0 : shield4Allocation;
        output[`shield_5c`] = shield5IsDamaged ? 0 : shield5Allocation;
        output[`shield_6c`] = shield6IsDamaged ? 0 : shield6Allocation;

        output[`bridge_hit_status`] = 0;
        output[`ship_is_evading`] = 0;
        setAttrs(output);
    });
};
async function releaseLockedRepairStatuses() {
    // Iterates through all repair status looking for locked ones to unlock 
    const CanBeRepairedNow = 1; // The system repair button is no longer locked.

    const values = await getAttrsAsync([
        `movement_grid_status`,
        `sensors_status`, 
        `shield_1_status`, 
        `shield_2_status`, 
        `shield_3_status`, 
        `shield_4_status`, 
        `shield_5_status`, 
        `shield_6_status`,
        `shields_grid_status`,
        `weapons_grid_status`
    ]);

    const output = {};
    Object.entries(values).forEach(([attrName, value]) => {
        if (value == REPAIR_IS_LOCKED) output[attrName] = CanBeRepairedNow;
    });

    // Process repeating_beams section
    const beamIds = await getSectionIDsAsync('repeating_beams');
    const beamAttrs = beamIds.flatMap(id => [
        `repeating_beams_${id}_weapon_state_status`,
        `repeating_beams_${id}_state`
    ]);
    
    if (beamAttrs.length > 0) {
        const beamValues = await getAttrsAsync(beamAttrs);
        beamIds.forEach(id => {
            const statusAttr = `repeating_beams_${id}_weapon_state_status`;
            const stateAttr = `repeating_beams_${id}_state`;
            const statusValue = beamValues[statusAttr];
            const stateValue = beamValues[stateAttr];
            
            if (statusValue == REPAIR_IS_LOCKED) {
                if (stateValue == WEAPON_IS_DESTROYED) {
                    output[statusAttr] = stateValue;
                } else {
                    output[statusAttr] = CanBeRepairedNow;
                }
            }
        });
    }

    // Process repeating_missiles section
    const missileIds = await getSectionIDsAsync('repeating_missiles');
    const missileAttrs = missileIds.flatMap(id => [
        `repeating_missiles_${id}_weapon_state_status`,
        `repeating_missiles_${id}_state`
    ]);
    
    if (missileAttrs.length > 0) {
        const missileValues = await getAttrsAsync(missileAttrs);
        missileIds.forEach(id => {
            const statusAttr = `repeating_missiles_${id}_weapon_state_status`;
            const stateAttr = `repeating_missiles_${id}_state`;
            const statusValue = missileValues[statusAttr];
            const stateValue = missileValues[stateAttr];
            
            if (statusValue == REPAIR_IS_LOCKED) {
                if (stateValue == WEAPON_IS_DESTROYED) {
                    output[statusAttr] = stateValue;
                } else {
                    output[statusAttr] = CanBeRepairedNow;
                }
            }
        });
    }

    await setAttrsAsync(output);
}

// SHIELD STATE changed
[`1`, `2`, `3`, `4`, `5`, `6`].forEach(num => {
    on(`change:shield_${num}_state`, function(eventInfo) {
        getAttrs([`shield_1_state`, `shield_2_state`, `shield_3_state`, `shield_4_state`, `shield_5_state`, `shield_6_state`], function(values) {

            const activeShields = Object.values(values).filter(state => state == 0).length;
            
            const output = {};
            output[`shields-percent`] = Math.max(0, Math.round(activeShields / 6 * 100));
            setAttrs(output);
        });
    });
});

// STRESS TURNS
on(`clicked:stress_turn`, async (event) => {
    const response = await extractChatData(`?{Select Type of Turn|Select..., -1|Emergency, 0|Tactical, 1|Evasive, 2}`);

    if (response == -1) return;

    const turnTypes = [`Energency Heading Change`, `Tactical Heading Change`, `Evasive Maneuver`];
    const engines = await getSectionIDsAsync(`repeating_engines`);
    let strOutput = `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=${turnTypes[parseInt(response) || 0]}}} {{color=orange}} `;
    let dmgWarp = 0;
    let dmgSup = 0;

    const Fieldnames = [];
    engines.forEach(id => {
        Fieldnames.push(`repeating_engines_${id}_engine_power`);
        Fieldnames.push(`repeating_engines_${id}_engine_type`);
    });

    const output = {};
    const values = await getAttrsAsync([...Fieldnames, `hp`, `wf_current`, `stress_eng`, `stress_sup`]);
    const currentSup = parseInt(values['hp']) || 0;
    const currentWF = parseInt(values['wf_current']) || 0;
    const stressChartEng = String(values['stress_eng']) || `R`;
    const stressChartSup = String(values['stress_sup']) || `R`;

    const stressDmgEng = 1 + await getStress(stressChartEng, currentWF);
    const stressDmgSup = await getStress(stressChartSup, currentWF);

    if (response < 2) {
        // Emergency or tactical heading change results
        engines.forEach(id => {
            const engineType = parseInt(values[`repeating_engines_${id}_engine_type`]) || 0;
            if (engineType == ENGINE_TYPE_WARP) {
                const currentPower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                const myNewPower = Math.max(0, currentPower - stressDmgEng);
                output[`repeating_engines_${id}_engine_power`] = myNewPower;
                if (currentPower - 1 >= 0) dmgWarp++;
            }
        });
        const myNewSup = currentSup - stressDmgSup;
        output[`hp`] = myNewSup;

        strOutput += `{{Warp Factor=${currentWF}}} {{Stress Charts=${stressChartEng}/${stressChartSup}}} {{Engine Dmg=${stressDmgEng} (ea.)}} {{Sup Dmg=${stressDmgSup}}}`;
    } else {
        // Evasive maneuver results
        const TO_EVADE_TARGET = 5;
        const myNewSup = currentSup - 1
        output[`hp`] = myNewSup;
        output[`ship_is_evading`] = 1;
        strOutput += `{{Sup Dmg=1}} `;

        const evadeResult = getRandomIntInclusive(1, 10) <= TO_EVADE_TARGET ? `Success` : `Failure`;
        strOutput += `{{All To-Hits=-2}} {{To-Evade=[[${TO_EVADE_TARGET}]]}} {{Roll=[[1d10cs>11cf<0]]}} `;
        await updateWeaponTargetToHit();
    }

    await setAttrsAsync(output);

    startRoll(strOutput, roll => {
        finishRoll(roll.rollId);
    });  
});

async function getStress (chart, speed) {
    // ST:STCS stress chart data
    const stresses = [
        `A`, 0,0,0,0,0,0,0,0,0,1,2,
        `B`, 0,0,0,0,0,0,0,0,1,1,2,
        `C`, 0,0,0,0,0,0,0,0,1,2,2,
        `D`, 0,0,0,0,0,0,0,1,1,2,3,
        `E`, 0,0,0,0,0,0,0,1,2,3,4,
        `F`, 0,0,0,0,0,0,1,1,1,2,2,
        `G`, 0,0,0,0,0,0,1,1,2,2,3,
        `H`, 0,0,0,0,0,0,1,2,2,3,3,
        `I`, 0,0,0,0,0,0,1,2,3,4,5,
        `J`, 0,0,0,0,0,1,1,1,2,2,3,
        `K`, 0,0,0,0,0,1,1,2,2,3,3,
        `L`, 0,0,0,0,0,1,1,2,3,4,5,
        `M`, 0,0,0,0,1,1,2,2,3,3,4,
        `N`, 0,0,0,0,1,1,2,3,4,5,6,
        `O`, 0,0,0,1,1,1,2,2,2,3,3,
        `P`, 0,0,1,1,1,2,2,3,3,4,4,
        `Q`, 0,1,1,1,1,2,2,2,3,3,4,
        `R`, 0,1,1,1,2,2,3,3,4,4,5
    ];

    const index = stresses.indexOf(chart);
    const damage = stresses[index + Math.min(speed, 11)];

    return isNaN(damage) ? 0 : damage;
}

async function updateWeaponTargetToHit() {
    try {
        // Define the repeating sections to process
        const sections = ['repeating_beams', 'repeating_missiles'];
        
        // Get section IDs for both weapon types
        const [beamIds, missileIds] = await Promise.all([
            getSectionIDsAsync('repeating_beams'),
            getSectionIDsAsync('repeating_missiles')
        ]);
        
        // Combine section IDs with their section names
        const allWeapons = [
            ...(beamIds || []).map(id => ({ section: 'repeating_beams', id })),
            ...(missileIds || []).map(id => ({ section: 'repeating_missiles', id }))
        ];
        
        if (allWeapons.length === 0) {
            console.log('No weapons found');
            return;
        }
        
        // Build array of attribute names to fetch
        const attrNames = [];
        allWeapons.forEach(weapon => {
            attrNames.push(`${weapon.section}_${weapon.id}_target_name`);
            attrNames.push(`${weapon.section}_${weapon.id}_target_tohit`);
        });
        
        // Get all the attributes
        const values = await getAttrsAsync(attrNames);
        
        // Build update object for weapons with valid target_name
        const updates = {};
        allWeapons.forEach(weapon => {
            const targetName = values[`${weapon.section}_${weapon.id}_target_name`];
            const targetToHit = parseInt(values[`${weapon.section}_${weapon.id}_target_tohit`]) || 0;
            
            // Check if target_name has a valid value (not empty/null/undefined)
            if (targetName && targetName.trim() !== '') {
                updates[`${weapon.section}_${weapon.id}_target_tohit`] = targetToHit - 2;
            }
        });
        
        // Apply the updates if any were found
        if (Object.keys(updates).length > 0) {
            await setAttrsAsync(updates);
            console.log(`Updated ${Object.keys(updates).length} weapon(s) (beams and missiles)`);
        } else {
            console.log('No weapons with valid targets found');
        }
        
    } catch (error) {
        console.error('Error updating weapon target to-hit values:', error);
    }
}

// SUPERSTRUCTURE MASS and SIZE calculations
on(`change:mass`, function(eventInfo) {
    getAttrs([`mass`], function(values) {
        const shipsMass = parseInt(values[`mass`]) || 0;
        const shipsFormattedMass = formatNumber(String(shipsMass));

        const theSizes = [0,`I`,5000,`II`,15000,`III`,25000,`IV`,40000,`V`,60000,`VI`,80000,`VII`,100000,`VIII`,120000,`IX`,140000,`X`,160000,`XI`,180000,`XII`,210000,`XIII`,240000,`XIV`,300000,`XV`,350000,`XVI`,400000,`XVII`,450000,`XVIII`,500000,`XIX`,600000,`XX`,700000];
        let i = 0;
        do {
            i += 2;
        } while (shipsMass > theSizes[i]);      

        const output = {};
        output[`size`] = `${shipsFormattedMass} mt (${theSizes[i-1]})`;
        setAttrs(output);
    });
});

// SUPERSTRUCTURE status
on(`change:hp change:hp_max`, function(eventInfo) {
    getAttrs([`hp`, `hp_max`], function(values) {
        const hp = parseInt(values[`hp`]) || 0;  
        const hpMax = parseInt(values[`hp_max`]) || 0;  

        const output = {};
        output[`sup-percent`] = Math.max(0, Math.round(hp / hpMax * 100));
        if (hp < 1) output[`tpa_movement`] = 0; // disable movement
        output[`hp_status`] = hp < (hpMax / 2) || hp > hpMax ? 1 : hp < hpMax ? 2 : 0;
        output[`ship-is-disabled`] = hp < 1 ? 1 : 0;
        setAttrs(output);
    });
});

// TOTAL POWER AVAILABLE calculation
on(`change:repeating_engines:engine_power change:repeating_engines:engine_power_full remove:repeating_engines change:crewbonus2`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_power`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
        });

        getAttrs([...Fieldnames, `crewbonus`], function (values) {
            const ENGINE_NO_POWER = 0;
            const crewBonus = parseInt(values[`crewbonus`] || 0);

            let tpa = 0;
            let tpaMax = 0;
            let isWarpOffline = 0;
            const output = {};
            ids.forEach(id => {
                const enginePower = parseInt(values[`repeating_engines_${id}_engine_power`]) || 0;
                const enginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                const engineType = parseInt(values[`repeating_engines_${id}_engine_type`]) || 0;
                
                tpa += enginePower + (enginePower > ENGINE_NO_POWER && crewBonus == CREW_BONUS_ENGINES ? 1 : 0);
                tpaMax += enginePowerMax
                if (enginePower == 0 && engineType == ENGINE_TYPE_WARP) isWarpOffline = 1;

                output[`repeating_engines_${id}_engine_power_status`] = ((enginePower > enginePowerMax) || (enginePower == 0)) ? 1 : enginePower < enginePowerMax ? 2 : 0;
            });
            output[`tpa`] = tpa;
            output[`tpa_max`] = tpaMax;
            output[`tpa-percent`] = Math.max(0, Math.round(tpa / tpaMax * 100));
            output[`warp_drive_status`] = isWarpOffline ? 1 : 0;
            setAttrs(output);
        });
    });
});

// TOTAL POWER AVAILABLE remaining calculation
on(`change:tpa change:tpa_movement change:tpa_warp change:tpa_weapons change:tpa_shields change:tpa_transporters change:tpa_cloak`, function(eventInfo) {
    getAttrs([`tpa`, `tpa_movement`, `tpa_warp`, `tpa_weapons`, `tpa_shields`, `tpa_transporters`, `tpa_cloak`], function(values) {
        const tpa = parseInt(values[`tpa`]) || 0;
        const tpaToMovement = parseInt(values[`tpa_movement`]) || 0;
        const tpaToWarp = parseInt(values[`tpa_warp`]) || 0;
        const tpaToWeapons = parseInt(values[`tpa_weapons`]) || 0;
        const tpaToShields = parseInt(values[`tpa_shields`]) || 0;
        const tpaToTransporters = parseInt(values[`tpa_transporters`]) || 0;
        const tpaToCloak = parseInt(values[`tpa_cloak`]) || 0;

        const tpaRemaining = tpa - tpaToMovement - tpaToWarp - tpaToWeapons - tpaToShields - tpaToTransporters - tpaToCloak;

        const output = {};
        output[`tpa_remaining`] = tpaRemaining;
        output[`tpa_remaining_status`] = (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// TPA COMMIT
on(`clicked:commit_tpa`, async (event) => {

    const response = await extractChatData(`?{Confirm TPA Commit|Confirm|Cancel}`);

    if (response === `Confirm`) {
        startRoll(
            `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=READY!}} {{color=purple}}`,
            roll => finishRoll(roll.rollId)
        );
    
        const output = {};
        output[`tpa_committed_status`] = 0;
        setAttrs(output);
    }
});

// TPA RESET
on(`clicked:tpa_reset`, async (event) => {

    const response = await extractChatData(`?{Confirm TPA Reset|Confirm|Cancel}`);

    if (response === `Confirm`) {
        startRoll(
            `&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=**NOT** READY}} {{color=purple}}`,
            roll => finishRoll(roll.rollId)
        );
        resetTPA();
    }
});
on(`change:tpa_reset`, async (event) => {
    resetTPA();
});
function resetTPA() {
    getSectionIDs(`repeating_beams`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_beams_${id}_power`] = 0;
                output[`repeating_beams_${id}_target_name`] = output[`repeating_beams_${id}_target_id`] = ``;
                output[`repeating_beams_${id}_target_distance`] = 0;
                output[`repeating_beams_${id}_target_tohit`] = 0;
                output[`repeating_beams_${id}_btn-target_status`] = 0;
                output[`repeating_beams_${id}_btn-fire_status`] = 0;
            });
            output[`wp_beam`] = 0;
            setAttrs(output);
        });
    });

    getSectionIDs(`repeating_missiles`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_name`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            const output = {};
            ids.forEach(id => {
                output[`repeating_missiles_${id}_armed`] = 0;
                output[`repeating_missiles_${id}_target_name`] = output[`repeating_missiles_${id}_target_id`] = ``;
                output[`repeating_missiles_${id}_target_distance`] = 0;
                output[`repeating_missiles_${id}_target_tohit`] = 0;
                output[`repeating_missiles_${id}_btn-target_status`] = 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = 0;
            });
            output[`wp_missile`] = 0;
            setAttrs(output);
        });
    });

    const output = {};

    output[`shield_1`] = output[`shield_2`] = output[`shield_3`] = output[`shield_4`] = output[`shield_5`] = output[`shield_6`] = 0
    output[`tpa_committed_status`] = 1;
    output[`tpa_movement`] = 0;
    output[`tpa_weapons`] = 0;
    output[`tpa_shields`] = 0;

    output[`cloak_is_armed`] = 0;

    output[`crewbonus`] = 0;
    output[`crewbonus_saved`] = 0;
    output[`crewbonus_engineid`] = ``;
    output[`crewbonustohitapplied`] = 0;
    output[`crewbonus1`] = output[`crewbonus2`] = output[`crewbonus3`] = 0;

    const SCAN_NONE = 0;
    output[`scanquestion`] = SCAN_NONE;
    output[`scananswer`] = ``;
    output[`ship_has_scanned`] = 0;

    output[`trans_on_std`] = output[`trans_on_cbt`] = output[`trans_on_er`] = output[`trans_on_scu`] = 0;

    setAttrs(output);
}

// TRANSPORTER on/off
on(`change:trans_num_std change:trans_on_std change:trans_num_cbt change:trans_on_cbt change:trans_num_er change:trans_on_er change:trans_num_scu change:trans_on_scu`, function(eventInfo) {
    // Determine which type triggered the event
    const triggerAttr = eventInfo.sourceAttribute;
    const type = triggerAttr.split('_').pop(); // Extracts 'std', 'cbt', 'er', or 'scu'
    
    getAttrs([`trans_num_${type}`, `trans_on_${type}`], function(values) {
        const transNum = parseInt(values[`trans_num_${type}`]) || 0;
        const transOn = parseInt(values[`trans_on_${type}`]) || 0;
        
        const StatusIsOff = 0;
        const StatusIsOn = 1;
        const StatusIsOver = 2;
        const TPAPerCbtTrans = 3; // TPA needed to power each combat transporter
        const output = {};
        output[`trans_ison_${type}`] = transOn > transNum ? StatusIsOver : transOn ? StatusIsOn : StatusIsOff;
        output[`trans_tpa_${type}`] = type === 'cbt' ? transOn * TPAPerCbtTrans : transOn;
        setAttrs(output);
    });
});

// TRANSPORTER TPA calculation
on(`change:trans_on_std change:trans_on_cbt change:trans_on_er change:trans_on_scu`, function(eventInfo) {
    getAttrs([`trans_on_std`, `trans_on_cbt`, `trans_on_er`, `trans_on_scu`], function(values) {
        const transOnStd = parseInt(values[`trans_on_std`]) || 0;
        const transOnCbt = parseInt(values[`trans_on_cbt`]) || 0;
        const transOnER = parseInt(values[`trans_on_er`]) || 0;
        const transOnSCU = parseInt(values[`trans_on_scu`]) || 0;

        const TPAPerCbtTrans = 3; // TPA needed to power each combat transporter
        const transTPA = transOnStd + (transOnCbt * TPAPerCbtTrans) + transOnER + transOnSCU;

        const output = {};
        output[`tpa_transporters`] = transTPA;
        setAttrs(output);
    });
});

// TYPE CAPABILITIES
on(`change:type`, function(eventInfo) {
    getAttrs([`type`], function(values) {
        const type = values[`type`];

        const types = [
            `BB`, 0,1,0,1,0,0,1, `BC`, 0,1,0,1,0,0,0,
            `CA`, 0,0,1,1,0,0,1, `CL`, 0,0,1,0,0,0,0, `CM`, 0,1,1,0,0,0,0, `CR`, 0,0,1,0,0,0,0, `CS`, 0,0,1,1,0,0,0,
            `DD`, 0,0,0,0,0,1,0,
            `ES`, 1,0,0,0,0,0,0,
            `FL`, 0,0,0,0,0,0,0, `FS`, 0,0,0,1,0,0,0,
            `MN`, 1,0,0,0,0,0,0,
            `RV`, 0,0,0,0,0,0,0,
            `SC`, 0,0,1,1,1,0,0,
            `TC`, 0,0,0,0,0,0,0, `TF`, 0,0,0,0,0,0,0, `TL`, 0,0,0,0,0,0,0, `TU`, 0,0,0,0,0,0,0,
            `ZA`, 0,0,0,0,0,0,0, `ZD`, 0,1,0,1,0,0,0, `ZL`, 1,0,0,0,0,0,0, `ZO`, 0,0,1,0,0,0,0
        ];

        const index = types.indexOf(type);

        const output = {};
        output[`type_is_advanced`] = types[index + 1];
        output[`type_is_battle`] = types[index + 2];
        output[`type_is_exploration`] = types[index + 3];
        output[`type_is_repair`] = types[index + 4];
        output[`type_is_nonmedical`] = types[index + 5];
        output[`type_is_anticloak`] = types[index + 6];
        output[`type_is_command`] = types[index + 7];
        setAttrs(output);
    });
});


// TYPE = STATION or MONITOR = no warp speed
on(`change:type`, function(eventInfo) {
    getAttrs([`type`], function(values) {
        const type = values[`type`];
        const isStation = 
            type == `MN` ||
            type == `ZA` ||
            type == `ZD` || 
            type == `ZO` || 
            type == `ZL`? 
            1 : 0;

        const output = {};
        output[`warp_show_content`] = isStation ? 0 : 1;
        setAttrs(output);
    });
});

// WARP FACTOR changed by player
on(`change:wf_current change:wf_desired`, function(eventInfo) {
    getAttrs([`wf_current`, `wf_desired`, `wf_cruise`, `wf_emergency`, `wfr_cruise`, `wfr_jump`], function(values) {
        const wfCurrent = parseInt(values[`wf_current`]) || 0;
        const wfDesired = parseInt(values[`wf_desired`]) || 0;
        const wfCruise = parseInt(values[`wf_cruise`]) || 0;
        const wfEmergency = parseInt(values[`wf_emergency`]) || 0;
        const wfrCruise = parseInt(values[`wfr_cruise`]) || 0;
        const wfrJump = parseInt(values[`wfr_jump`]) || 0;

        const wfrCurrent = wfDesired > wfCurrent ? wfrJump : wfrCruise;
        const tpaRequired = wfDesired > wfCurrent ? (wfDesired - wfCurrent) * wfrCurrent : wfrCruise * Math.min(wfCurrent, wfDesired);

        const output = {};
        output[`wfr_1`] = wfrCurrent;
        output[`tpa_warp`] = tpaRequired;
        output[`wf_current_status`] = wfCurrent > wfEmergency ? 1 : wfCurrent > wfCruise ? 2 : 0;
        output[`wf_desired_status`] = wfDesired > wfEmergency ? 1 : wfDesired != wfCurrent || wfDesired > wfCruise ? 2 : 0;
        output[`warp_factor_status`] = wfDesired != wfCurrent ? 1 : 0;
        setAttrs(output);
    });
});

// WARP FACTOR RATIO calculations
// Note: This should not occur after initial ship setup
//  but event is triggered whenever engine power changes
on(`change:repeating_engines:engine_power_full remove:repeating_engines change:wf_emergency`, function(eventInfo) {
    getSectionIDs(`repeating_engines`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_engines_${id}_engine_type`);
            Fieldnames.push(`repeating_engines_${id}_engine_power_full`);
        });
        
        getAttrs([...Fieldnames, `wf_emergency`], function (values) {
            const wfEmergency = parseInt(values[`wf_emergency`]) || 0;

            let totalWarpEngines = 0;
            let totalWarpPower = 0;
            const output = {};
            ids.forEach(id => {
                if (values[`repeating_engines_${id}_engine_type`] == ENGINE_TYPE_WARP) {
                    const theEnginePowerMax = parseInt(values[`repeating_engines_${id}_engine_power_full`]) || 0;
                    totalWarpEngines += 1;
                    totalWarpPower += theEnginePowerMax;
                }
            });

            output[`wf_current`] = output[`wf_desired`] = 0; // Clear settings
            output[`wfr_jump`] = output[`wfr_1`] = Math.floor(totalWarpPower / wfEmergency);
            //output[`wfr_cruise`] = totalWarpEngines;
            output[`wfr_cruise`] = 1;
            setAttrs(output);
        });
    });
});

// WARP JUMP
on(`clicked:jump`, async (event) => {
    const response = await extractChatData(`?{Confirm Speed Change|Confirm|Cancel}`);

    if (response === `Confirm`) {
        const values = await getAttrsAsync([`wf_current`, `wf_desired`, `faction`]);
        
        const wfCurrent = parseInt(values[`wf_current`]) || 0;
        const wfDesired = parseInt(values[`wf_desired`]) || 0;
        const faction = values[`faction`];

        if (wfCurrent != wfDesired) {
            startRoll(`&{template:custom} {{title=@{banner_${faction}warp} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Warp Factor Change}} {{color=blue}} {{From=Warp Factor **@{wf_current}**}} {{To=Warp Factor **@{wf_desired}**}}`, roll => {
                finishRoll(roll.rollId);
            });

            await setAttrsAsync({'wf_current': wfDesired});
        }
    }   
});

// WEAPON POINTS calculation
on(`change:tpa_weapons change:wp_beam change:wp_missile`, function(eventInfo) {
    getAttrs([`tpa_weapons`, `wp_beam`, `wp_missile`], function(values) {
        const tpa = parseInt(values[`tpa_weapons`]) || 0;
        const tpaToBeams = parseInt(values[`wp_beam`]) || 0;
        const tpaToMissiles = parseInt(values[`wp_missile`]) || 0;

        const tpaRemaining = tpa - tpaToBeams - tpaToMissiles;

        const output = {};
        output[`wp_remaining`] = tpaRemaining;
        output[`wp_remaining_status`] = (tpa != 0 || tpaRemaining != 0) && (tpaRemaining < 0 ? 1 : (tpaRemaining > 0 ? 2 : 0));
        setAttrs(output);
    });
});

// WEAPON TARGETING
on(`clicked:repeating_beams:btn-target clicked:repeating_missiles:btn-target`, async (event) => {
    const CloakedTargetPenalty = -3;
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, `${row}_chart`, `${row}_maxrange`, `${row}_power`, 
        `type_is_battle`, `sensorlock`, `sensorlockid`, 
        `crewbonus`, `crewbonustohitapplied`, `crewrollpenalty`
    ]);

    const wpnName = attributes[`${row}_name`];
    const wpnChart = attributes[`${row}_chart`];
    const wpnMaxRange = parseInt(attributes[`${row}_maxrange`]) || 0;
    const wpnIsPowered = parseInt(attributes[`${row}_power`]) || 0;
    const typeIsMulti = parseInt(attributes[`type_is_battle`]) || 0;
    const sensorLockName = String(attributes[`sensorlock`]) || ``;
    const sensorLockId = String(attributes[`sensorlockid`]) || ``;
    const crewBonus = parseInt(attributes[`crewbonus`]) || 0;
    const crewBonusApplied = parseInt(attributes[`crewbonustohitapplied`]) || 0;
    const crewCasualtyPenalty = parseInt(attributes[`crewrollpenalty`]) || 0;

    const output = {};

    // Clear only the triggered row
    output[`${row}_target_name`] = ``;
    output[`${row}_target_id`] = ``;
    output[`${row}_target_distance`] = 0;
    output[`${row}_target_tohit`] = 0;
    output[`${row}_btn-fire_status`] = 0;

    await setAttrsAsync(output);

    // Get target input
    const { tokenName, charId, isCloaked } = await extractTargetData(); // Destructure JSON
    const wpnTargetDistance = +(await extractChatData(`?{How far|1}`)) || 0;
    const wpnCrewBonus = crewBonus == CREW_BONUS_WEAPONS && !crewBonusApplied ? +(await extractChatData(`?{Apply crew bonus|Yes,1|No,0}`)) || 0 : 0;
    const wpnTargetToHit = getToHit(wpnChart, wpnTargetDistance);

    if (wpnTargetToHit) {
        let multiTargetPenalty = await calculateMultiTargetPenalty(typeIsMulti, charId);
        let bankedRows = await getBankedWeaponRows(wpnName, section, rowID);
        let weaponStatePenalty = await calculateWeaponStatePenalty(bankedRows, section);
        let wpnTargetToHitModified = await processAllTargetedWeapons(output, wpnCrewBonus, crewCasualtyPenalty, weaponStatePenalty, multiTargetPenalty, charId);
        
        const weaponNames = [];
        // Process banked weapons (if any)
        for (const id of bankedRows) {
            const targetRow = `repeating_${section}_${id}`;
            const rowAttrs = await getAttrsAsync([
                `${targetRow}_name`,
                `${targetRow}_chart`,
                `${targetRow}_power`,
                `${targetRow}_state`
            ]);
            
            const name = rowAttrs[`${targetRow}_name`] || `Unknown Weapon`;
            const chart = rowAttrs[`${targetRow}_chart`];
            const power = parseInt(rowAttrs[`${targetRow}_power`]) || 0;
            const state = parseInt(rowAttrs[`${targetRow}_state`]) || 0;

            // Skip if not powered or currently damaged
            if (power == 0 || state == 1 || state == 3) continue;

            // If plasma bolt, get damage based on range; else set equal to power
            const nameSuffix = name.match(/#\d+([a-z]+)/i);
            const letterGroup = nameSuffix ? nameSuffix[1] : null; // is at half-power
            const isPlasmaBolt = await getPlasmaBoltDamage(wpnName, wpnTargetDistance);
            const damage = isPlasmaBolt ? letterGroup != 'h' ? isPlasmaBolt : Math.floor(isPlasmaBolt / 2) : power;

            // Calculate base to-hit for this weapon
            const baseToHit = getToHit(chart, wpnTargetDistance);
            wpnTargetToHitModified = baseToHit + wpnCrewBonus + crewCasualtyPenalty;

            // Apply multi-target penalty to all weapons
            wpnTargetToHitModified += multiTargetPenalty;

            // Apply cloaked target penalty to all weapons
            if (isCloaked == 1) wpnTargetToHitModified += CloakedTargetPenalty;

            // Apply cumulative weapon state penalty to all weapons in bank
            wpnTargetToHitModified += weaponStatePenalty;

            weaponNames.push(name);
            output[`${targetRow}_damage`] = damage;
            output[`${targetRow}_target_name`] = tokenName;
            output[`${targetRow}_target_id`] = charId;
            output[`${targetRow}_target_distance`] = wpnTargetDistance;
            output[`${targetRow}_target_tohit`] = wpnTargetToHitModified;
            output[`${targetRow}_btn-fire_status`] = wpnTargetToHitModified > -4 ? 1 : 0;
        }   

        const wpnTargetToHitStr = wpnTargetToHitModified < -3 ? `Not Possible` : wpnTargetToHitModified < 1 ? `Slim to None` : `${wpnTargetToHitModified * 10}%`;
        const wpnHasCrewBonusStr = wpnCrewBonus ? `{{Crew Bonus=+1}}` : ``;
        const multiTargetPenaltyStr = typeIsMulti !== 1 && multiTargetPenalty !== 0 ? `{{Multi-Target Penalty=${multiTargetPenalty}}}` : ``;
        const cloakedTargetPenaltyStr = isCloaked == 1 ? `{{Cloaked Target Penalty=-3}}` : ``;
        
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=&#x1F3AF; Weapons Targeted &#x1F3AF;}} {{color=green}} {{Weapons=${weaponNames.join(`\\n`)}}} {{Target=[${tokenName}](${ROLL20_CHAR_URL}${charId})}} {{Distance=${wpnTargetDistance} hexes}} {{Firing Chart=${wpnChart}}}  `, roll => finishRoll(roll.rollId));
        startRoll(`/w gm &{template:custom} {{color=green}} {{Crew Penalty=${crewCasualtyPenalty}}} ${wpnHasCrewBonusStr} {{Repair Penalty=${weaponStatePenalty}}} ${multiTargetPenaltyStr} ${cloakedTargetPenaltyStr} {{Chance To-Hit=${wpnTargetToHitStr}}}`, roll => finishRoll(roll.rollId));
    } else {
        startRoll(`&{template:custom} {{title=**[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Target Out of Range}} {{Weapon=${wpnName}}} {{Max Range=${wpnMaxRange} hexes}} {{Target=${tokenName}}} {{Distance=${wpnTargetDistance} hexes}}`, roll => finishRoll(roll.rollId));
    }

    output[`crewbonustohitapplied`] = Math.max(wpnCrewBonus, crewBonusApplied);
    await setAttrsAsync(output);
});

async function calculateMultiTargetPenalty(typeIsMulti, charId) {
    let multiTargetPenalty = 0;
    
    if (typeIsMulti !== 1) {
        const uniqueTargets = new Set();
        
        // Check all repeating_beams items
        const beamIds = await getSectionIDsAsync(`repeating_beams`);
        const beamFieldnames = beamIds.map(id => `repeating_beams_${id}_target_id`);
        const beamValues = await getAttrsAsync(beamFieldnames);
        
        beamIds.forEach(id => {
            const targetId = beamValues[`repeating_beams_${id}_target_id`];
            if (targetId && targetId !== `` && targetId != charId) {
                uniqueTargets.add(targetId);
            }
        });
        
        // Check all repeating_missiles items
        const missileIds = await getSectionIDsAsync(`repeating_missiles`);
        const missileFieldnames = missileIds.map(id => `repeating_missiles_${id}_target_id`);
        const missileValues = await getAttrsAsync(missileFieldnames);
        
        missileIds.forEach(id => {
            const targetId = missileValues[`repeating_missiles_${id}_target_id`];
            if (targetId && targetId !== `` && targetId != charId) {
                uniqueTargets.add(targetId);
            }
        });
        
        // Apply penalty to all weapons in both lists
        multiTargetPenalty = -uniqueTargets.size;
    }
    
    return multiTargetPenalty;
}

async function calculateWeaponStatePenalty(bankedRows, section) {
    let weaponStatePenalty = 0;
    
    for (const id of bankedRows) {
        const targetRow = `repeating_${section}_${id}`;
        const statusAttrs = await getAttrsAsync([`${targetRow}_weapon_state_status`]);
        const weaponStateStatus = parseInt(statusAttrs[`${targetRow}_weapon_state_status`]) || 0;
        
        if (weaponStateStatus === 2) {
            weaponStatePenalty -= 1;
        }
    }
    
    return weaponStatePenalty;
}

async function getBankedWeaponRows(wpnName, section, rowID, isRecursive = false) {
    let bankedRows = [];
    const nameRoot = wpnName.match(/#\d+/);
    
    if (nameRoot) {
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                if (section == 'beams' || (section == 'missiles' && name == wpnName))
                bankedRows.push(id);
            }
        });

        // Check how many powered weapons are in the bank
        const poweredWeapons = [];
        for (const id of bankedRows) {
            const targetRow = `repeating_${section}_${id}`;
            const rowAttrs = await getAttrsAsync([
                `${targetRow}_power`,
                `${targetRow}_state`
            ]);
            
            const power = parseInt(rowAttrs[`${targetRow}_power`]) || 0;
            const state = parseInt(rowAttrs[`${targetRow}_state`]) || 0;

            // Include if powered and not currently damaged
            if (power > 0 && state !== 1 && state !== 3) {
                poweredWeapons.push(id);
            }
        }

        // If multiple powered weapons, ask user
        if (poweredWeapons.length > 1 && !isRecursive) {
            const targetAll = +(await extractChatData(`?{Target all ${poweredWeapons.length} powered weapons in bank?|All,1|Just this one,0}`)) || 0;
            if (!targetAll) {
                bankedRows = [rowID]; // Only target the clicked weapon
            }
        }
    } else {
        bankedRows.push(rowID); // Not banked — just target self
    }
    
    return bankedRows;
}

async function processAllTargetedWeapons(output, wpnCrewBonus, crewCasualtyPenalty, weaponStatePenalty, multiTargetPenalty, charId) {
    const allTargetedWeapons = [];
    
    // Check all repeating_beams items
    const beamIds = await getSectionIDsAsync(`repeating_beams`);
    const beamFieldnames = beamIds.map(id => `repeating_beams_${id}_target_id`);
    const beamValues = await getAttrsAsync(beamFieldnames);
    
    beamIds.forEach(id => {
        const targetId = beamValues[`repeating_beams_${id}_target_id`];
        if (targetId && targetId !== ``) {
            allTargetedWeapons.push({
                row: `repeating_beams_${id}`,
                name: `repeating_beams_${id}_name`,
                power: `repeating_beams_${id}_power`,
                state: `repeating_beams_${id}_state`,
                distance: `repeating_beams_${id}_target_distance`,
                targetId: targetId
            });
        }
    });
    
    // Check all repeating_missiles items
    const missileIds = await getSectionIDsAsync(`repeating_missiles`);
    const missileFieldnames = missileIds.map(id => `repeating_missiles_${id}_target_id`);
    const missileValues = await getAttrsAsync(missileFieldnames);
    
    missileIds.forEach(id => {
        const targetId = missileValues[`repeating_missiles_${id}_target_id`];
        if (targetId && targetId !== ``) {
            allTargetedWeapons.push({
                row: `repeating_missiles_${id}`,
                name: `repeating_missiles_${id}_name`,
                power: `repeating_missiles_${id}_power`,
                state: `repeating_missiles_${id}_state`,
                distance: `repeating_missiles_${id}_target_distance`,
                targetId: targetId
            });
        }
    });

    // Process all targeted weapons
    let wpnTargetToHitModified = 0;
    for (const weapon of allTargetedWeapons) {
        const rowAttrs = await getAttrsAsync([
            `${weapon.row}_name`,
            `${weapon.row}_chart`,
            `${weapon.row}_power`,
            `${weapon.row}_state`,                
            `${weapon.row}_target_distance`
        ]);
        const name = rowAttrs[weapon.name] || `Unknown Weapon`;
        const chart = rowAttrs[`${weapon.row}_chart`];
        const power = parseInt(rowAttrs[weapon.power]) || 0;
        const state = parseInt(rowAttrs[weapon.state]) || 0;
        const distance = parseInt(rowAttrs[weapon.distance]) || 0;

        const rowArray = weapon.row.split(`_`);
        let myBankedRows = await getBankedWeaponRows(name, rowArray[1], rowArray[2], true);
        let myWpnStatePenalty = await calculateWeaponStatePenalty(myBankedRows, rowArray[1]);
        
        // Skip if not powered or currently damaged
        if (power == 0 || state == 1 || state == 3) continue;

        // Recalculate base to-hit for this weapon
        const baseToHit = getToHit(chart, distance);
        wpnTargetToHitModified = baseToHit + wpnCrewBonus + crewCasualtyPenalty + myWpnStatePenalty;

        // Apply multi-target penalty to all weapons
        wpnTargetToHitModified += multiTargetPenalty;
        output[`${weapon.row}_target_tohit`] = wpnTargetToHitModified;
        output[`${weapon.row}_btn-fire_status`] = wpnTargetToHitModified > -4 ? 1 : 0;
    }
    
    return wpnTargetToHitModified;
}

function getToHit (chart, distance) {
    // ST:STCS firing chart data
    const ranges = [
        `A`, 8, 6, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `B`, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `C`, 10, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `D`, 10, 9, 7, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `E`, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `F`, 10, 9, 7, 6, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `G`, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `H`, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `I`, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `J`, 10, 10, 9, 9, 8, 8, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `K`, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `L`, 10, 10, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `M`, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `N`, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `O`, 10, 10, 9, 9, 8, 8, 7, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `P`, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0, 0, 0, 0,
        `Q`, 10, 10, 10, 9, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        `R`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        `S`, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        `T`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0,
        `U`, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0,
        `V`, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 3, 3, 2, 2, 1, 0, 0, 0,
        `W`, 10, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 1, 0, 0, 0, 0,
        `X`, 10, 10, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0,
        `Y`, 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1
    ];

    const index = ranges.indexOf(chart);
    const MAX_WPN_DISTANCE = 24;
    const toHit = ranges[index + Math.min(distance, MAX_WPN_DISTANCE)];

    return isNaN(toHit) ? 0 : toHit;
}

// Determine damage from plasma bolts based on given name
async function getPlasmaBoltDamage(name, range) {
    const boltTypes = [
        `RPL-1`, 24,20,20,16,16,12,4,2,0,0,0,0,0,0,0,
        `RPL-2`, 32,32,32,24,24,24,20,20,16,16,12,12,8,8,0,
        `RPL-3`, 28,28,28,28,24,24,24,24,24,20,20,20,16,16,12,12
    ];
    
    // Extract the weapon name (RPL-X) from the formatted string
    const match = name.match(/RPL-\d+/);
    const weaponName = match ? match : name;  // Extract the string from the match array
    
    // Find the index of the weapon name
    let nameIndex = -1;
    for (let i = 0; i < boltTypes.length; i++) {
        if (boltTypes[i] == weaponName) {
            nameIndex = i;
            break;
        }
    }
    
    // If weapon not found, return null or 0
    if (nameIndex === -1) {
        return null;
    }
    
    // Calculate the damage value index (range is 1-based, so range-1 gives 0-based index)
    const damageIndex = nameIndex + range;
    
    // Check if range is valid and return damage
    if (damageIndex < boltTypes.length && typeof boltTypes[damageIndex] === 'number') {
        return boltTypes[damageIndex];
    }
    
    // Return 0 if range is out of bounds
    return 0;
}

// WEAPON FIRING
on(`clicked:repeating_beams:btn-fire clicked:repeating_missiles:btn-fire`, async (event) => {
    const match = event.sourceAttribute.match(/repeating_(?<section>.+?)_(?<rowID>.+?)_(?<buttonName>.+)/);
    const { section, rowID, buttonName } = match?.groups || {};
    const row = `repeating_${section}_${rowID}`;

    const attributes = await getAttrsAsync([
        `${row}_name`, 
        `${row}_target_name`, `${row}_target_id`, 
        `${row}_target_distance`, `${row}_target_tohit`, `faction`, 
        `ship_is_evading`
    ]);

    const faction = attributes[`faction`];
    const wpnName = attributes[`${row}_name`];
    const wpnBankName = wpnName.match(/#\d+\w+/);
    const targetName = attributes[`${row}_target_name`];
    const targetId = attributes[`${row}_target_id`];
    const targetDistance = parseInt(attributes[`${row}_target_distance`]) || 0;
    const shipIsEvading = (parseInt(attributes[`ship_is_evading`]) || 0);
    const targetToHit = parseInt(attributes[`${row}_target_tohit`]) || 0 - shipIsEvading * 2;

    // Calc slim to none to-hit
    const targetSlimToHit = targetToHit < 1 ? 8 - Math.abs(targetToHit) * 2 : 0;

    // Get all matching banked weapons or default to single weapon
    const bankedRows = [];
    if (wpnBankName) {
        const nameRoot = wpnName.match(/#\d+/);
        const ids = await getSectionIDsAsync(`repeating_${section}`);
        const fieldnames = ids.map(id => `repeating_${section}_${id}_name`);
        const values = await getAttrsAsync(fieldnames);

        ids.forEach(id => {
            const name = values[`repeating_${section}_${id}_name`];
            if (name && name.match(nameRoot)) {
                bankedRows.push(id);
            }
        });
    } else {
        // Not in a bank — fire just this weapon
        bankedRows.push(rowID);
    }

    const damageList = [];
    const weaponNames = [];

    for (const id of bankedRows) {
        const rowAttrs = await getAttrsAsync([
            `repeating_${section}_${id}_name`,
            `repeating_${section}_${id}_power`, `repeating_${section}_${id}_power_max`, `repeating_${section}_${id}_damage`, 
            `repeating_${section}_${id}_bonus_3`, `repeating_${section}_${id}_bonus_2`, `repeating_${section}_${id}_bonus_1`,
            `repeating_${section}_${id}_armed`,
            `repeating_${section}_${id}_target_name`, `repeating_${section}_${id}_target_tohit`
        ]);

        const wpnName = rowAttrs[`repeating_${section}_${id}_name`];
        const power = parseInt(rowAttrs[`repeating_${section}_${id}_power`]) || 0;
        const powerMax = parseInt(rowAttrs[`repeating_${section}_${id}_power_max`]) || 0;
        const damage = parseInt(rowAttrs[`repeating_${section}_${id}_damage`]) || 0;
        const bonus3 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_3`]) || 0;
        const bonus2 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_2`]) || 0;
        const bonus1 = parseInt(rowAttrs[`repeating_${section}_${id}_bonus_1`]) || 0;
        const armed = parseInt(rowAttrs[`repeating_${section}_${id}_armed`]) || 0;
        const targetName = rowAttrs[`repeating_${section}_${id}_target_name`];
        const targetToHit = parseInt(rowAttrs[`repeating_${section}_${id}_target_tohit`]) || 0 - shipIsEvading * 2;;

        // Skip if not targeted
        if (!targetName) continue;

        const isOCLaser = armed ? 0 : (power > powerMax ? 1 : 0);
        const powerDischarge = isOCLaser ? Math.floor(damage / 2) : damage;
        const totalDamage = powerDischarge + (
            targetDistance <= bonus3 ? 3 :
            targetDistance <= bonus2 ? 2 :
            targetDistance <= bonus1 ? 1 : 0
        );

        weaponNames.push(wpnName);
        damageList.push(totalDamage);

        // Reset weapon state
        const output = {};
        if (!armed) output[`repeating_${section}_${id}_power`] = isOCLaser ? powerDischarge : 0;
        output[`repeating_${section}_${id}_armed`] = 0;
        output[`repeating_${section}_${id}_btn-target_status`] = isOCLaser ? 1 : 0;
        output[`repeating_${section}_${id}_btn-fire_status`] = 0;
        output[`repeating_${section}_${id}_target_name`] = ``;
        output[`repeating_${section}_${id}_target_id`] = ``;
        output[`repeating_${section}_${id}_target_distance`] = 0;
        output[`repeating_${section}_${id}_target_tohit`] = 0;
        await setAttrsAsync(output);
    }   
        // Single roll with all weapons and damages
        const evasionStr = shipIsEvading ? `{{Ship is Evading=-2 to-hit}}` : ``;

        startRoll(
            `&{template:custom} {{title=@{banner_${faction}fire${section}} **[@{character_name}](${ROLL20_CHAR_URL}@{character_id})**}} {{subtitle=Weapons Fired}} {{color=red}} {{Weapons=${weaponNames.join(`\\n`)}}} {{Target=[${targetName}](${ROLL20_CHAR_URL}${targetId})}} ${evasionStr} {{To-Hit=[[${targetToHit}]] or less}} {{Roll=[[1d10cs>11cf<0]]}} {{Slim-To-Hit=[[${targetSlimToHit}]]}} {{Slim-Roll=[[1d10cs>11cf<0]]}} {{Damage=${damageList.join(`, `)}}}`,
            roll => finishRoll(roll.rollId)
        );
    });

// WEAPON POWER (BEAM) ALLOCATION calculations
on(`change:repeating_beams:name change:repeating_beams:power change:repeating_beams:weapon_state_status remove:repeating_beams`, function(eventInfo) {
    getSectionIDs(`repeating_beams`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_beams_${id}_name`);
            Fieldnames.push(`repeating_beams_${id}_weapon_state_status`);
            Fieldnames.push(`repeating_beams_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_beams_${id}_power`);
            Fieldnames.push(`repeating_beams_${id}_power_max`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToBeams = 0;
            const output = {};
            ids.forEach(id => {
                const theBeamIsLaser = values[`repeating_beams_${id}_name`].includes(`FL-`);
                const theBeamStateStatus = parseInt(values[`repeating_beams_${id}_weapon_state_status`]) || 0;
                const theBeamIsDamaged = theBeamStateStatus == WEAPON_IS_DAMAGED || theBeamStateStatus == WEAPON_IS_DESTROYED ? 1 : 0;
                const theBeamIsRepaired = theBeamStateStatus == WEAPON_IS_REPAIRED ? 1 : 0;
                const theBeamIsReady = parseInt(values[`repeating_beams_${id}_btn-fire_status`]) || 0;
                const theBeamPower = parseInt(values[`repeating_beams_${id}_power`]) || 0;
                const theBeamPowerMax = Math.floor((parseInt(values[`repeating_beams_${id}_power_max`]) || 0) / (theBeamIsRepaired + 1));
                totalPowerToBeams += theBeamPower;

                output[`repeating_beams_${id}_power_status`] = theBeamIsDamaged && !theBeamIsReady == 1 ? 1 : (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) < 0 ? 1 : (theBeamPower > 0 ? 2 : 0);
                output[`repeating_beams_${id}_btn-target_status`] = theBeamPower && !theBeamIsDamaged && (theBeamPowerMax + theBeamPowerMax * theBeamIsLaser - theBeamPower) > -1 ? 1 : 0;
                output[`repeating_beams_${id}_btn-fire_status`] = theBeamIsReady;
            });
            output[`wp_beam`] = totalPowerToBeams;
            setAttrs(output);
        });
    });
});

// WEAPON POWER (MISSILE) ALLOCATION calculations
on(`change:repeating_missiles:damaged change:repeating_missiles:armed change:repeating_missiles:cost remove:repeating_missiles`, function(eventInfo) {
    getSectionIDs(`repeating_missiles`, function (ids) {
        const Fieldnames = [];
        ids.forEach(id => {
            Fieldnames.push(`repeating_missiles_${id}_damaged`);
            Fieldnames.push(`repeating_missiles_${id}_btn-fire_status`);
            Fieldnames.push(`repeating_missiles_${id}_armed`);
            Fieldnames.push(`repeating_missiles_${id}_cost`);
        });
        
        getAttrs([...Fieldnames], function (values) {
            let totalPowerToMissiles = 0;
            const output = {};
            ids.forEach(id => {
                const theMissileIsDamaged = parseInt(values[`repeating_missiles_${id}_damaged`]) || 0;
                const theMissileIsReady = parseInt(values[`repeating_missiles_${id}_btn-fire_status`]) || 0;
                const theMissilePower = (parseInt(values[`repeating_missiles_${id}_armed`]) || 0) * (parseInt(values[`repeating_missiles_${id}_cost`]) || 0);
                totalPowerToMissiles += theMissileIsDamaged && !theMissileIsReady ? 0 : theMissilePower;

                output[`repeating_missiles_${id}_armed_status`] = theMissileIsDamaged == 1 ? 1 : 0;
                output[`repeating_missiles_${id}_btn-target_status`] = theMissilePower && !theMissileIsDamaged ? 1 : 0;
                output[`repeating_missiles_${id}_btn-fire_status`] = theMissileIsReady;
            });
            output[`wp_missile`] = totalPowerToMissiles;
            setAttrs(output);
        });
    });
});

// WEAPONS DAMAGED PERCENT calculation
async function updateWeaponsPercent() {
    let countWeapons = 0;
    let countWeaponsDamaged = 0;

    const fieldNames = [];
    let ids = await getSectionIDsAsync(`repeating_beams`);
    ids.forEach(id => {
        fieldNames.push(`repeating_beams_${id}_weapon_state_status`);
    });
    ids = await getSectionIDsAsync(`repeating_missiles`);
    ids.forEach(id => {
        fieldNames.push(`repeating_missiles_${id}_weapon_state_status`);
    });

    const values = await getAttrsAsync(fieldNames);
    Object.values(values).forEach(value => {
        countWeapons++;
        if (value != 0) countWeaponsDamaged++;
    });

    const output = {};
    output[`weapons-percent`] = Math.max(0, Math.round((countWeapons - countWeaponsDamaged) / countWeapons * 100));
    setAttrs(output);
}

// WEAPON TO-HIT status
on(`change:repeating_beams:target_tohit change:repeating_missiles:target_tohit`, function(eventInfo) {
    const newValue = parseInt(eventInfo.newValue) || 0;
    const rowId = eventInfo.sourceAttribute.split('_');

    getAttrs([`repeating_${rowId[1]}_${rowId[2]}_target_name`], function(values) {
        const targetName = values[`repeating_${rowId[1]}_${rowId[2]}_target_name`] || '';
        const statusValue = targetName == `` ? 0 : (newValue < 1 ? 1 : 0);
        
        setAttrs({
            [`repeating_${rowId[1]}_${rowId[2]}_target_tohit_status`]: statusValue
        });
    });
});

/****************************/
async function getNumWarpEngines() {            
    const engineIds = await getSectionIDsAsync(`repeating_engines`);
    let numWarpEngines = 0;

    for (const engineId of engineIds) {
        const engineValues = await getAttrsAsync([
            `repeating_engines_${engineId}_engine_type`
        ]);

        const engineType = parseInt(engineValues[`repeating_engines_${engineId}_engine_type`]) || 0;

        if (engineType === ENGINE_TYPE_WARP) ++numWarpEngines;
    }
    return numWarpEngines;
}

/****************************/
function isRunningOnServer() { return self.dispatchEvent == undefined; }
function setActiveCharacterId(charId){
    var oldAcid=getActiveCharacterId();
    var msg={"id":"0", "type":"setActiveCharacter", "data":charId};
    
    if(isRunningOnServer()==false){ //if in a browser, use "dispatchEvent" to process the message
        var ev = new CustomEvent("message");
        ev.data=msg; 
        self.dispatchEvent(ev);
    }else{ //otherwise, use the API (server) message processor, "onmessage"
        self.onmessage({data:msg});
    }
    return oldAcid; //return what the value used to be, so calling code can be a little cleaner 
} 
var _sIn=setInterval;
setInterval=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sIn(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
var _sto=setTimeout
setTimeout=function(callback, timeout){
    var acid=getActiveCharacterId();
    _sto(
        function(){
            var prevAcid=setActiveCharacterId(acid);
            callback();
            setActiveCharacterId(prevAcid);
        }
    ,timeout);
}
function getAttrsAsync(props){
    var acid=getActiveCharacterId(); //save the current activeCharacterID in case it has changed when the promise runs 
    var prevAcid=null;               //local variable defined here, because it needs to be shared across the promise callbacks defined below
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  //in case the activeCharacterId has changed, restore it to what we were expecting and save the current value to restore later
            try{
                getAttrs(props,(values)=>{  resolve(values); }); 
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); //restore activeCharcterId to what it was when the promise first ran
    });
}
//use the same pattern for each of the following...
function setAttrsAsync(propObj, options){
    var acid=getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid=setActiveCharacterId(acid);  
            try{
                setAttrs(propObj,options,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

function getSectionIDsAsync(sectionName){
    var acid = getActiveCharacterId(); 
    var prevAcid=null;               
    return new Promise((resolve,reject)=>{
            prevAcid = setActiveCharacterId(acid);  
            try{
                getSectionIDs(sectionName,(values)=>{ resolve(values); });
            }
            catch{ reject(); }
    }).finally(()=>{
        setActiveCharacterId(prevAcid); 
    });
}

</script>

<rolltemplate class="sheet-rolltemplate-custom">
    <div class="sheet-container sheet-color-{{color}}">
      <div class="sheet-header">
        {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
        {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
      </div>

      <div class="sheet-content">
        {{#allprops() title subtitle color Damage Slim-Roll Slim-To-Hit}}
        <div class="sheet-key">{{key}}</div>
        <div class="sheet-value">{{value}}</div>
        {{/allprops() title subtitle color Damage Slim-Roll Slim-To-Hit}}

        {{#^rollGreater() Roll Rating}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll Rating}}

        {{#rollGreater() Roll Rating}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll Rating}}

        {{#^rollGreater() Roll To-Hit}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Hit!</span></div>
        {{#Damage}}
            <div class="sheet-key">Damage</div>
            <div class="sheet-value">{{Damage}}</div>
        {{/Damage}}
        {{/^rollGreater() Roll To-Hit}}

        {{#rollGreater() Roll To-Hit}}
            {{#rollLess() To-Hit 1}}
                {{#rollTotal() Roll 1}}
                    {{#Slim-To-Hit}}
                        <div class="sheet-key">Slim-To-Hit</div>
                        <div class="sheet-value">{{Slim-To-Hit}}</div>
                    {{/Slim-To-Hit}}
                    {{#Slim-Roll}}
                        <div class="sheet-key">Slim-Roll</div>
                        <div class="sheet-value">{{Slim-Roll}}</div>
                    {{/Slim-Roll}}
                    {{#^rollGreater() Slim-Roll Slim-To-Hit}}
                        <div class="sheet-key">Result</div>
                        <div class="sheet-value"><span class="success">Hit!</span></div>
                        {{#Damage}}
                            <div class="sheet-key">Damage</div>
                            <div class="sheet-value">{{Damage}}</div>
                        {{/Damage}}
                    {{/^rollGreater() Slim-Roll Slim-To-Hit}}
                    {{#rollGreater() Slim-Roll Slim-To-Hit}}
                        <div class="sheet-key">Result</div>
                        <div class="sheet-value"><span class="failure">Miss!</span></div>
                    {{/rollGreater() Slim-Roll Slim-To-Hit}}
                {{/rollTotal() Roll 1}}
            {{/rollLess() To-Hit 1}}
            {{#^rollLess() To-Hit 1}}
                <div class="sheet-key">Result</div>
                <div class="sheet-value"><span class="failure">Miss!</span></div>
            {{/^rollLess() To-Hit 1}}
        {{/rollGreater() Roll To-Hit}}

        {{#^rollGreater() Roll To-Evade}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll To-Evade}}

        {{#rollGreater() Roll To-Evade}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Evade}}

        {{#^rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Success!</span></div>
        {{/^rollGreater() Roll To-Repair}}

        {{#rollGreater() Roll To-Repair}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Repair}}

        {{#^rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">Scanned!</span></div>
        {{/^rollGreater() Roll To-Scan}}

        {{#rollGreater() Roll To-Scan}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="failure">Failure</span></div>
        {{/rollGreater() Roll To-Scan}}

        {{#rollTotal() Remaining 0}}
        <div class="sheet-key">Result</div>
        <div class="sheet-value"><span class="success">No Damage!</span></div>
        {{/rollTotal() Remaining 0}}

        {{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
      </div>
    </div>
</rolltemplate>


<rolltemplate class="sheet-rolltemplate-menu">
    <div class="sheet-container sheet-color-{{color}}">
         <div class="sheet-header">
            {{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
            {{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
        </div>
         <div class="sheet-content">
            {{#allprops() title subtitle desc color}}
                <div class="sheet-key">{{key}}</div>
                <div class="sheet-value">{{value}}</div>
            {{/allprops() title subtitle desc color}}
            {{#desc}}
                <div class="sheet-desc">{{desc}}</div>
            {{/desc}}
        </div>
    </div>
</rolltemplate>